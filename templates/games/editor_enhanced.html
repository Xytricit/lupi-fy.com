<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>LupiForge Block Editor</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/blockly/10.4.3/blockly.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/blockly/10.4.3/javascript_compressed.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            font-family: Arial, sans-serif;
            height: 100vh;
            display: flex;
            flex-direction: column;
            background: #1a1a2e;
        }
        #header {
            background: #16213e;
            color: white;
            padding: 15px 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            box-shadow: 0 2px 10px rgba(0,0,0,0.3);
        }
        #header h1 {
            font-size: 24px;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        #projectName {
            background: #0f3460;
            border: 2px solid #533483;
            color: white;
            padding: 8px 15px;
            border-radius: 5px;
            font-size: 14px;
            width: 250px;
            margin-left: 20px;
        }
        #projectName::placeholder {
            color: #8b92a8;
        }
        .button-group {
            display: flex;
            gap: 10px;
            align-items: center;
        }
        button {
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            transition: all 0.3s ease;
        }
        #saveBtn {
            background: #27ae60;
            color: white;
        }
        #saveBtn:hover {
            background: #229954;
            transform: translateY(-2px);
        }
        #publishBtn {
            background: #e74c3c;
            color: white;
        }
        #publishBtn:hover {
            background: #c0392b;
            transform: translateY(-2px);
        }
        #exportBtn {
            background: #3498db;
            color: white;
        }
        #exportBtn:hover {
            background: #2980b9;
            transform: translateY(-2px);
        }
        #clearBtn {
            background: #95a5a6;
            color: white;
            padding: 8px 15px;
            font-size: 13px;
        }
        #clearBtn:hover {
            background: #7f8c8d;
        }
        #quickPreviewBtn {
            background: #9b59b6;
            color: white;
        }
        #quickPreviewBtn:hover {
            background: #8e44ad;
            transform: translateY(-2px);
        }
        #saveStatus {
            font-size: 12px;
            color: #95a5a6;
            font-style: italic;
        }
        #blocklyDiv {
            flex: 1;
            width: 100%;
            height: calc(100vh - 60px);
            background: #f8f9fa;
        }
        #output {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            background: #1e1e1e;
            color: #d4d4d4;
            padding: 15px;
            max-height: 300px;
            overflow-y: auto;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            border-top: 3px solid #533483;
            display: none;
        }
        #output.show {
            display: block;
        }
        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.7);
            justify-content: center;
            align-items: center;
        }
        .modal.show {
            display: flex;
        }
        .modal-content {
            background: #16213e;
            color: white;
            padding: 30px;
            border-radius: 10px;
            max-width: 500px;
            width: 90%;
            box-shadow: 0 5px 30px rgba(0,0,0,0.5);
        }
        .modal-content h2 {
            margin-bottom: 15px;
            color: #e74c3c;
        }
        .modal-content p {
            margin-bottom: 20px;
            line-height: 1.6;
        }
        .modal-buttons {
            display: flex;
            gap: 10px;
            justify-content: flex-end;
        }
        .toast {
            position: fixed;
            top: 80px;
            right: 20px;
            background: #27ae60;
            color: white;
            padding: 15px 25px;
            border-radius: 5px;
            box-shadow: 0 3px 15px rgba(0,0,0,0.3);
            display: none;
            z-index: 2000;
            animation: slideIn 0.3s ease;
        }
        .toast.show {
            display: block;
        }
        .toast.error {
            background: #e74c3c;
        }
        @keyframes slideIn {
            from {
                transform: translateX(400px);
                opacity: 0;
            }
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }
        /* Asset Panel Styles */
        .asset-panel {
            position: fixed;
            right: 0;
            top: 60px;
            width: 300px;
            height: calc(100vh - 60px);
            background: #16213e;
            border-left: 2px solid #533483;
            box-shadow: -2px 0 10px rgba(0,0,0,0.3);
            z-index: 100;
            display: flex;
            flex-direction: column;
            transition: transform 0.3s ease;
        }
        .asset-panel.collapsed {
            transform: translateX(300px);
        }
        .asset-header {
            background: #0f3460;
            padding: 15px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 2px solid #533483;
        }
        .asset-header h3 {
            color: white;
            font-size: 16px;
            margin: 0;
        }
        .toggle-btn {
            background: none;
            border: none;
            color: white;
            font-size: 20px;
            cursor: pointer;
            padding: 5px 10px;
            transition: transform 0.3s ease;
        }
        .asset-panel.collapsed .toggle-btn {
            transform: rotate(180deg);
        }
        .asset-content {
            flex: 1;
            overflow-y: auto;
            padding: 15px;
        }
        .upload-section {
            margin-bottom: 15px;
        }
        .upload-label {
            display: block;
            background: #27ae60;
            color: white;
            padding: 12px;
            border-radius: 5px;
            text-align: center;
            cursor: pointer;
            transition: background 0.3s ease;
        }
        .upload-label:hover {
            background: #229954;
        }
        .asset-tabs {
            display: flex;
            gap: 5px;
            margin-bottom: 15px;
        }
        .asset-tab {
            flex: 1;
            background: #0f3460;
            color: white;
            border: none;
            padding: 8px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 12px;
            transition: background 0.3s ease;
        }
        .asset-tab:hover {
            background: #533483;
        }
        .asset-tab.active {
            background: #533483;
        }
        .asset-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 10px;
        }
        .asset-item {
            background: #0f3460;
            border-radius: 5px;
            padding: 10px;
            position: relative;
            cursor: pointer;
            transition: transform 0.2s ease;
        }
        .asset-item:hover {
            transform: scale(1.05);
        }
        .asset-preview {
            width: 100%;
            height: 80px;
            object-fit: cover;
            border-radius: 5px;
            background: #1a1a2e;
        }
        .asset-name {
            color: white;
            font-size: 11px;
            margin-top: 5px;
            text-align: center;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        .asset-delete {
            position: absolute;
            top: 5px;
            right: 5px;
            background: #e74c3c;
            color: white;
            border: none;
            border-radius: 50%;
            width: 20px;
            height: 20px;
            font-size: 12px;
            cursor: pointer;
            display: none;
        }
        .asset-item:hover .asset-delete {
            display: block;
        }
        #blocklyDiv {
            width: calc(100% - 300px);
            margin-bottom: 0;
        }
        .asset-panel.collapsed ~ #blocklyDiv {
            width: 100%;
        }
        /* Preview Panel Styles */
        .preview-panel {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 300px;
            height: 400px;
            background: #1a1a2e;
            border-top: 3px solid #533483;
            z-index: 90;
            display: flex;
            flex-direction: column;
            transition: transform 0.3s ease;
        }
        .preview-panel.collapsed {
            transform: translateY(400px);
        }
        .preview-header {
            background: #16213e;
            padding: 10px 15px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 2px solid #533483;
        }
        .preview-header h3 {
            color: white;
            font-size: 16px;
            margin: 0;
        }
        .preview-controls {
            display: flex;
            gap: 5px;
        }
        .preview-btn {
            background: #533483;
            color: white;
            border: none;
            padding: 6px 12px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 12px;
            transition: background 0.3s ease;
        }
        .preview-btn:hover:not(:disabled) {
            background: #6c4f9c;
        }
        .preview-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        .preview-content {
            flex: 1;
            display: flex;
            justify-content: center;
            align-items: center;
            position: relative;
            overflow: hidden;
        }
        #gameCanvas {
            border: 2px solid #533483;
            background: #000;
            max-width: 100%;
            max-height: 100%;
        }
        .game-stats {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 10px;
            border-radius: 5px;
            font-size: 12px;
            font-family: monospace;
        }
        .game-stats div {
            margin: 5px 0;
        }
        #blocklyDiv {
            height: calc(100vh - 460px);
        }
        .preview-panel.collapsed ~ #blocklyDiv {
            height: calc(100vh - 60px);
        }
        /* Achievement Styles */
        .achievement-overlay {
            position: fixed;
            top: 80px;
            left: 50%;
            transform: translateX(-50%) translateY(-100px);
            z-index: 3000;
            opacity: 0;
            pointer-events: none;
            transition: all 0.5s ease;
        }
        .achievement-overlay.show {
            transform: translateX(-50%) translateY(0);
            opacity: 1;
        }
        .achievement-popup {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 20px 30px;
            border-radius: 10px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.5);
            text-align: center;
            min-width: 300px;
        }
        .achievement-icon {
            font-size: 48px;
            margin-bottom: 10px;
            animation: bounce 0.5s ease;
        }
        @keyframes bounce {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.2); }
        }
        .achievement-popup h2 {
            margin: 10px 0;
            font-size: 20px;
        }
        .achievement-popup p {
            margin: 10px 0;
            font-size: 14px;
        }
        .achievement-points {
            background: rgba(255,255,255,0.2);
            display: inline-block;
            padding: 5px 15px;
            border-radius: 20px;
            margin-top: 10px;
            font-weight: bold;
        }
        .score-display {
            text-align: center;
            margin: 20px 0;
        }
        .score-large {
            font-size: 48px;
            font-weight: bold;
            color: #27ae60;
        }
        /* Notification Styles */
        .notification-bell {
            position: relative;
            font-size: 24px;
            cursor: pointer;
            padding: 5px 10px;
            transition: transform 0.3s ease;
        }
        .notification-bell:hover {
            transform: scale(1.1);
        }
        .notification-badge {
            position: absolute;
            top: 0;
            right: 5px;
            background: #e74c3c;
            color: white;
            border-radius: 50%;
            width: 18px;
            height: 18px;
            font-size: 11px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
        }
        .notification-badge.hidden {
            display: none;
        }
        .notification-dropdown {
            position: fixed;
            top: 60px;
            right: 20px;
            width: 350px;
            max-height: 500px;
            background: #16213e;
            border-radius: 10px;
            box-shadow: 0 5px 30px rgba(0,0,0,0.5);
            z-index: 2000;
            display: none;
        }
        .notification-dropdown.show {
            display: block;
            animation: slideDown 0.3s ease;
        }
        @keyframes slideDown {
            from {
                opacity: 0;
                transform: translateY(-20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }
        .notification-header {
            padding: 15px;
            border-bottom: 2px solid #533483;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .notification-header h3 {
            color: white;
            font-size: 16px;
            margin: 0;
        }
        .mark-read-btn {
            background: none;
            border: none;
            color: #3498db;
            cursor: pointer;
            font-size: 12px;
        }
        .mark-read-btn:hover {
            text-decoration: underline;
        }
        .notification-list {
            max-height: 400px;
            overflow-y: auto;
        }
        .notification-item {
            padding: 15px;
            border-bottom: 1px solid #0f3460;
            cursor: pointer;
            transition: background 0.3s ease;
        }
        .notification-item:hover {
            background: #0f3460;
        }
        .notification-item.unread {
            background: rgba(83, 52, 131, 0.2);
        }
        .notification-title {
            color: white;
            font-weight: bold;
            margin-bottom: 5px;
        }
        .notification-message {
            color: #95a5a6;
            font-size: 13px;
            line-height: 1.4;
        }
        .notification-time {
            color: #7f8c8d;
            font-size: 11px;
            margin-top: 5px;
        }

        /* Header Icon Buttons */
        .header-icon-btn {
            background: none;
            border: none;
            font-size: 24px;
            cursor: pointer;
            padding: 5px 10px;
            transition: transform 0.3s ease;
        }
        .header-icon-btn:hover {
            transform: scale(1.2);
        }

        /* Autosave Indicator */
        .autosave-indicator {
            position: fixed;
            top: 70px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(22, 33, 62, 0.95);
            color: white;
            padding: 8px 20px;
            border-radius: 20px;
            font-size: 12px;
            z-index: 2000;
            transition: all 0.3s ease;
            opacity: 0;
            pointer-events: none;
        }
        .autosave-indicator.show {
            opacity: 1;
        }
        .autosave-indicator.saving {
            background: #f39c12;
        }
        .autosave-indicator.saved {
            background: #27ae60;
        }

        /* Debug Console */
        .debug-console {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 300px;
            height: 250px;
            background: #1e1e1e;
            border-top: 2px solid #533483;
            z-index: 95;
            transition: transform 0.3s ease;
            font-family: 'Courier New', monospace;
        }
        .debug-console.collapsed {
            transform: translateY(calc(100% - 40px));
        }
        .debug-header {
            background: #16213e;
            padding: 10px 15px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            color: white;
            font-size: 14px;
            cursor: pointer;
            border-bottom: 1px solid #533483;
        }
        .debug-controls {
            display: flex;
            gap: 5px;
        }
        .debug-btn {
            background: #533483;
            color: white;
            border: none;
            padding: 4px 10px;
            border-radius: 3px;
            cursor: pointer;
            font-size: 12px;
        }
        .debug-btn:hover {
            background: #6c4f9c;
        }
        .debug-output {
            padding: 10px;
            height: calc(100% - 40px);
            overflow-y: auto;
            color: #d4d4d4;
            font-size: 12px;
            line-height: 1.6;
        }
        .debug-log {
            color: #4ec9b0;
        }
        .debug-warn {
            color: #dcdcaa;
        }
        .debug-error {
            color: #f48771;
            font-weight: bold;
        }
        .debug-timestamp {
            color: #858585;
            margin-right: 8px;
        }
        .debug-preview-section {
            padding: 10px;
            border-top: 1px solid #533483;
            background: #0f0f0f;
            max-height: 500px;
            overflow-y: auto;
        }
        #previewSVG {
            cursor: pointer;
        }
        #previewSVG:hover text {
            fill: #00bfff;
        }

        /* Large Modal */
        .large-modal {
            max-width: 800px;
            width: 95%;
        }

        /* Modal Header */
        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 2px solid #533483;
        }
        .modal-header h2 {
            margin: 0;
            color: #e74c3c;
        }
        .close-btn {
            background: none;
            border: none;
            color: white;
            font-size: 24px;
            cursor: pointer;
            padding: 0;
            width: 30px;
            height: 30px;
            line-height: 30px;
            transition: transform 0.3s ease;
        }
        .close-btn:hover {
            transform: rotate(90deg);
        }

        /* Leaderboard Styles */
        .leaderboard-filters {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }
        .filter-btn {
            flex: 1;
            min-width: 120px;
            background: #0f3460;
            color: white;
            border: 2px solid #533483;
            padding: 10px 15px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.3s ease;
        }
        .filter-btn:hover {
            background: #533483;
            transform: translateY(-2px);
        }
        .filter-btn.active {
            background: #533483;
            border-color: #e74c3c;
        }
        .leaderboard-content {
            max-height: 400px;
            overflow-y: auto;
            margin-bottom: 20px;
        }
        .leaderboard-table {
            width: 100%;
            border-collapse: collapse;
        }
        .leaderboard-table thead {
            background: #0f3460;
            position: sticky;
            top: 0;
            z-index: 10;
        }
        .leaderboard-table th {
            padding: 12px;
            text-align: left;
            color: white;
            font-weight: 600;
        }
        .leaderboard-table td {
            padding: 12px;
            border-bottom: 1px solid #0f3460;
            color: white;
        }
        .leaderboard-table tr:hover {
            background: #0f3460;
        }
        .rank-medal {
            font-size: 20px;
        }
        .leaderboard-footer {
            display: flex;
            justify-content: space-around;
            padding: 15px;
            background: #0f3460;
            border-radius: 5px;
            color: white;
        }
        .highlight {
            color: #e74c3c;
            font-weight: bold;
            font-size: 18px;
        }

        .remix-btn {
            background: #9b59b6;
            color: white;
            border: none;
            padding: 6px 15px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 12px;
            margin-left: 10px;
            transition: all 0.3s ease;
        }
        .remix-btn:hover {
            background: #8e44ad;
        }

        /* Dashboard Styles */
        .dashboard-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-bottom: 30px;
        }
        .stat-card {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            padding: 20px;
            border-radius: 10px;
            text-align: center;
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
        }
        .stat-icon {
            font-size: 36px;
            margin-bottom: 10px;
        }
        .stat-label {
            color: rgba(255,255,255,0.8);
            font-size: 12px;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 10px;
        }
        .stat-value {
            color: white;
            font-size: 32px;
            font-weight: bold;
        }
        .dashboard-section {
            background: #0f3460;
            padding: 20px;
            border-radius: 10px;
            margin-bottom: 20px;
        }
        .dashboard-section h3 {
            color: white;
            margin-bottom: 15px;
            font-size: 18px;
        }
        .games-list {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
            gap: 15px;
        }
        .game-card {
            background: #16213e;
            padding: 15px;
            border-radius: 8px;
            border: 2px solid #533483;
            transition: all 0.3s ease;
        }
        .game-card:hover {
            border-color: #e74c3c;
            transform: translateY(-5px);
        }
        .game-title {
            color: white;
            font-weight: bold;
            margin-bottom: 10px;
        }
        .game-stats {
            display: flex;
            justify-content: space-between;
            font-size: 12px;
            color: #95a5a6;
            margin-bottom: 10px;
        }
        .game-status {
            display: inline-block;
            padding: 4px 12px;
            border-radius: 20px;
            font-size: 11px;
            font-weight: bold;
        }
        .status-public {
            background: #27ae60;
            color: white;
        }
        .status-pending {
            background: #f39c12;
            color: white;
        }
        .status-draft {
            background: #95a5a6;
            color: white;
        }
        .revenue-list {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        .revenue-item {
            background: #16213e;
            padding: 15px;
            border-radius: 5px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .revenue-game {
            color: white;
            font-weight: bold;
        }
        .revenue-amount {
            color: #27ae60;
            font-size: 18px;
            font-weight: bold;
        }

        /* Moderation Styles */
        .moderator-only {
            border: 2px solid #e74c3c;
        }
        .moderation-stats {
            display: flex;
            gap: 20px;
            margin-bottom: 20px;
            padding: 15px;
            background: #0f3460;
            border-radius: 5px;
        }
        .mod-stat {
            flex: 1;
            text-align: center;
            color: white;
        }
        .mod-stat-label {
            display: block;
            font-size: 12px;
            color: #95a5a6;
            margin-bottom: 5px;
        }
        .mod-stat-value {
            font-size: 24px;
            font-weight: bold;
            color: #e74c3c;
        }
        .moderation-queue {
            max-height: 500px;
            overflow-y: auto;
        }
        .mod-item {
            background: #0f3460;
            padding: 15px;
            border-radius: 5px;
            margin-bottom: 15px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-left: 4px solid #f39c12;
        }
        .mod-item-info {
            flex: 1;
        }
        .mod-item-title {
            color: white;
            font-weight: bold;
            font-size: 16px;
            margin-bottom: 5px;
        }
        .mod-item-meta {
            color: #95a5a6;
            font-size: 13px;
        }
        .mod-item-actions {
            display: flex;
            gap: 10px;
        }
        .mod-btn {
            padding: 8px 20px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s ease;
        }
        .mod-btn.approve {
            background: #27ae60;
            color: white;
        }
        .mod-btn.approve:hover {
            background: #229954;
        }
        .mod-btn.reject {
            background: #e74c3c;
            color: white;
        }
        .mod-btn.reject:hover {
            background: #c0392b;
        }
        .mod-btn.review {
            background: #3498db;
            color: white;
        }
        .mod-btn.review:hover {
            background: #2980b9;
        }
        .mod-preview-content {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }
        .mod-game-info {
            background: #0f3460;
            padding: 15px;
            border-radius: 5px;
        }
        .mod-game-info h3 {
            color: white;
            margin-bottom: 10px;
        }
        .mod-game-meta {
            color: #95a5a6;
            font-size: 14px;
            display: flex;
            gap: 20px;
        }
        .mod-preview-canvas {
            display: flex;
            justify-content: center;
            background: #000;
            padding: 20px;
            border-radius: 5px;
        }
        #modGameCanvas {
            border: 2px solid #533483;
        }
        .mod-actions {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }
        #modFeedback {
            width: 100%;
            padding: 12px;
            background: #0f3460;
            border: 2px solid #533483;
            border-radius: 5px;
            color: white;
            font-family: Arial, sans-serif;
            resize: vertical;
        }
        .mod-buttons {
            display: flex;
            gap: 10px;
            justify-content: flex-end;
        }




        /* Settings Styles */
        .settings-tabs {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            border-bottom: 2px solid #533483;
            flex-wrap: wrap;
        }
        .settings-tab {
            background: none;
            color: white;
            border: none;
            padding: 12px 20px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.3s ease;
            border-bottom: 3px solid transparent;
        }
        .settings-tab:hover {
            background: #0f3460;
        }
        .settings-tab.active {
            border-bottom-color: #9b59b6;
            color: #9b59b6;
        }
        .settings-tab-content {
            display: none;
            max-height: 500px;
            overflow-y: auto;
        }
        .settings-tab-content.active {
            display: block;
        }
        .settings-section {
            background: #0f3460;
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 20px;
        }
        .settings-section h3 {
            color: white;
            margin-bottom: 15px;
            font-size: 16px;
            border-bottom: 2px solid #533483;
            padding-bottom: 10px;
        }
        .profile-avatar-section {
            display: flex;
            align-items: center;
            gap: 20px;
            margin-bottom: 20px;
        }
        .profile-avatar-large {
            width: 80px;
            height: 80px;
            border-radius: 50%;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 40px;
        }
        .change-avatar-btn {
            background: #9b59b6;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        .change-avatar-btn:hover {
            background: #8e44ad;
        }
        .save-settings-btn {
            width: 100%;
            padding: 12px;
            background: #27ae60;
            color: white;
            border: none;
            border-radius: 5px;
            font-size: 14px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        .save-settings-btn:hover {
            background: #229954;
        }
        .danger-zone {
            border: 2px solid #e74c3c;
        }
        .danger-btn {
            background: #e74c3c;
            color: white;
            border: none;
            padding: 12px 20px;
            border-radius: 5px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s ease;
        }
        .danger-btn:hover {
            background: #c0392b;
        }
    </style>
        {% if current_user %}
        {{ current_user|json_script:"currentUser" }}
        {% endif %}
</head>
<body>
<script>
    // Expose current user to frontend safely
    window.LUPIFORGE_CURRENT_USER = {};
    try{
        const el = document.getElementById('currentUser');
        if(el) window.LUPIFORGE_CURRENT_USER = JSON.parse(el.textContent || '{}');
    }catch(e){ window.LUPIFORGE_CURRENT_USER = {}; }
</script>
    <div id="header">
        <div style="display: flex; align-items: center;">
            <h1>üéÆ LupiForge Block Editor</h1>
            <input type="text" id="projectName" placeholder="My Awesome Game" maxlength="50">
        </div>
        <div class="button-group">
            <button id="leaderboardBtn" class="header-icon-btn" title="Leaderboard">üèÜ</button>

            <button id="dashboardBtn" class="header-icon-btn" title="Dashboard">üìä</button>
            <button id="moderationBtn" class="header-icon-btn moderator-only" title="Moderation" style="display: none;">üõ°Ô∏è</button>

            <button id="settingsBtn" class="header-icon-btn" title="Settings">‚öôÔ∏è</button>
            <div id="notificationBell" class="notification-bell">
                üîî
                <span id="notificationCount" class="notification-badge">0</span>
            </div>
            <span id="saveStatus">Never saved</span>
            <button id="clearBtn">üóëÔ∏è Clear</button>
            <button id="saveBtn">üíæ Save</button>
            <button id="quickPreviewBtn">üëÅÔ∏è Quick Preview</button>
            <button id="publishBtn">üöÄ Publish</button>
            <button id="exportBtn">üì§ Export Code</button>
        </div>
    </div>
    <div id="blocklyDiv"></div>
    <div id="output"></div>

    <!-- Publish Modal -->
    <div id="publishModal" class="modal">
        <div class="modal-content">
            <h2>üöÄ Publish Game</h2>
            <p><strong>Game Title:</strong> <span id="modalGameTitle"></span></p>
            <p>Your game will be submitted to moderators for approval. Once approved, it will be visible to all players!</p>
            <p><strong>Ready to publish?</strong></p>
            <div class="modal-buttons">
                <button id="cancelPublish" style="background: #95a5a6;">Cancel</button>
                <button id="confirmPublish" style="background: #e74c3c;">Publish Now</button>
            </div>
        </div>
    </div>

    <!-- Toast Notification -->
    <div id="toast" class="toast"></div>
    <div id="autosaveIndicator" class="autosave-indicator">üíæ Saving...</div>

    <!-- Asset Manager Panel -->
    <div id="assetPanel" class="asset-panel">
        <div class="asset-header">
            <h3>üì¶ Asset Library</h3>
            <button id="toggleAssets" class="toggle-btn">‚ñº</button>
        </div>
        <div class="asset-content">
            <div class="upload-section">
                <label class="upload-label">
                    <input type="file" id="assetUpload" accept="image/*,audio/*" multiple style="display: none;">
                    <span>‚ûï Upload Assets</span>
                </label>
            </div>
            <div class="upload-section">
                <label class="upload-label">
                    <input type="file" id="animationUpload" accept="image/png,image/jpeg" style="display: none;">
                    <span>üé¨ Upload Sprite Sheet</span>
                </label>
            </div>
            <div class="asset-tabs">
                <button class="asset-tab active" data-type="sprites">üé® Sprites</button>
                <button class="asset-tab" data-type="sounds">üîä Sounds</button>
                <button class="asset-tab" data-type="backgrounds">üñºÔ∏è Backgrounds</button>
                <button class="asset-tab" data-type="animations">üé¨ Animations</button>
            </div>
            <div id="assetGrid" class="asset-grid">
                <!-- Assets will be populated here -->
            </div>
        </div>
    </div>

    <!-- Game Preview Panel -->
    <div id="previewPanel" class="preview-panel collapsed">
        <div class="preview-header">
            <h3>üéÆ Game Preview</h3>
            <div class="preview-controls">
                <button id="playGame" class="preview-btn">‚ñ∂Ô∏è Play</button>
                <button id="stopGame" class="preview-btn" disabled>‚èπÔ∏è Stop</button>
                <button id="restartGame" class="preview-btn" disabled>üîÑ Restart</button>
                <button id="toggleDebug" class="preview-btn" style="background: #f39c12;">üêõ Debug</button>
                <button id="closePreview" class="preview-btn">‚úï</button>
            </div>
        </div>
        <div class="preview-content">
            <canvas id="gameCanvas" width="800" height="600"></canvas>
            <div id="gameStats" class="game-stats">
                <div>Score: <span id="previewScore">0</span></div>
                <div>FPS: <span id="previewFPS">60</span></div>
            </div>
        </div>
    </div>

    <!-- Debug Console -->
    <div id="debugConsole" class="debug-console collapsed">
        <div class="debug-header">
            <span>üñ•Ô∏è Debug Console</span>
            <div class="debug-controls">
                <button id="clearConsole" class="debug-btn">üóëÔ∏è Clear</button>
                <button id="toggleConsole" class="debug-btn">‚ñº</button>
            </div>
        </div>
        <div id="debugOutput" class="debug-output"></div>
        <div id="debugPreviewSection" class="debug-preview-section" style="display: none;">
            <svg id="previewSVG" viewBox="0 0 800 600" xmlns="http://www.w3.org/2000/svg" style="width: 100%; border: 2px solid #3498db; margin-top: 10px; background: #1a1a1a; border-radius: 5px;">
                <text x="400" y="300" text-anchor="middle" dy="0.3em" font-size="24" fill="#3498db" font-weight="bold">üì∫ PREVIEW</text>
                <text x="400" y="330" text-anchor="middle" dy="0.3em" font-size="14" fill="#95a5a6">Live Game Preview</text>
            </svg>
            <canvas id="debugGameCanvas" width="800" height="600" style="width: 100%; border: 2px solid #3498db; margin-top: 10px; background: #000; border-radius: 5px; display: none;"></canvas>
        </div>
    </div>

    <!-- Achievement Panel -->
    <div id="achievementPanel" class="achievement-overlay">
        <div class="achievement-popup">
            <div class="achievement-icon">üèÜ</div>
            <h2 id="achievementTitle">Achievement Unlocked!</h2>
            <p id="achievementDesc">First Blood - Create your first game</p>
            <div class="achievement-points">+50 XP</div>
        </div>
    </div>

    <!-- Score Submission Modal -->
    <div id="scoreModal" class="modal">
        <div class="modal-content">
            <h2>üéØ Submit Score</h2>
            <div class="score-display">
                <div class="score-large" id="finalScore">0</div>
                <p>points</p>
            </div>
            <input type="text" id="playerName" placeholder="Enter your name" maxlength="20" 
                   style="width: 100%; padding: 10px; margin: 15px 0; border-radius: 5px; border: 2px solid #533483; background: #0f3460; color: white;">
            <div class="modal-buttons">
                <button id="cancelScore" style="background: #95a5a6;">Cancel</button>
                <button id="submitScore" style="background: #27ae60;">Submit Score</button>
            </div>
        </div>
    </div>

    <!-- Notification Dropdown -->
    <div id="notificationDropdown" class="notification-dropdown">
        <div class="notification-header">
            <h3>üîî Notifications</h3>
            <button id="markAllRead" class="mark-read-btn">Mark all read</button>
        </div>
        <div id="notificationList" class="notification-list">
            <!-- Notifications populated here -->
        </div>
    </div>

    <!-- Leaderboard Modal -->
    <div id="leaderboardModal" class="modal">
        <div class="modal-content large-modal">
            <div class="modal-header">
                <h2>üèÜ Global Leaderboard</h2>
                <button id="closeLeaderboard" class="close-btn">‚úï</button>
            </div>
            <div class="leaderboard-filters">
                <button class="filter-btn active" data-period="daily">üìÖ Daily</button>
                <button class="filter-btn" data-period="weekly">üìä Weekly</button>
                <button class="filter-btn" data-period="monthly">üìà Monthly</button>
                <button class="filter-btn" data-period="alltime">üåü All Time</button>
            </div>
            <div class="leaderboard-content">
                <table class="leaderboard-table">
                    <thead>
                        <tr>
                            <th>Rank</th>
                            <th>Player</th>
                            <th>Game</th>
                            <th>Score</th>
                            <th>Date</th>
                        </tr>
                    </thead>
                    <tbody id="leaderboardTableBody">
                        <!-- Populated by JavaScript -->
                    </tbody>
                </table>
            </div>
            <div class="leaderboard-footer">
                <div class="user-rank">Your Rank: <span id="userRank" class="highlight">#--</span></div>
                <div class="user-best">Your Best: <span id="userBest" class="highlight">0</span></div>
            </div>
        </div>
    </div>



    <!-- Remix Modal -->
    <div id="remixModal" class="modal">
        <div class="modal-content">
            <h2>üé® Remix Game</h2>
            <p>Create your own version of <strong id="remixGameTitle"></strong>?</p>
            <p style="font-size: 14px; color: #95a5a6;">You'll get a copy of the game to edit and publish as your own.</p>
            <div class="modal-buttons">
                <button id="cancelRemix" style="background: #95a5a6;">Cancel</button>
                <button id="confirmRemix" style="background: #3498db;">Remix Now</button>
            </div>
        </div>
    </div>

    <!-- Creator Dashboard Modal -->
    <div id="dashboardModal" class="modal">
        <div class="modal-content large-modal">
            <div class="modal-header">
                <h2>üìä Creator Dashboard</h2>
                <button id="closeDashboard" class="close-btn">‚úï</button>
            </div>
            <div class="dashboard-grid">
                <div class="stat-card">
                    <div class="stat-icon">üéÆ</div>
                    <div class="stat-label">Total Games</div>
                    <div class="stat-value" id="totalGames">0</div>
                </div>
                <div class="stat-card">
                    <div class="stat-icon">‚ñ∂Ô∏è</div>
                    <div class="stat-label">Total Plays</div>
                    <div class="stat-value" id="totalPlays">0</div>
                </div>
                <div class="stat-card">
                    <div class="stat-icon">üë•</div>
                    <div class="stat-label">Followers</div>
                    <div class="stat-value" id="totalFollowers">0</div>
                </div>
                <div class="stat-card">
                    <div class="stat-icon">üí∞</div>
                    <div class="stat-label">Revenue</div>
                    <div class="stat-value" id="totalRevenue">$0</div>
                </div>
            </div>
            <div class="dashboard-section">
                <h3>üìà Performance This Week</h3>
                <canvas id="playsChart" width="400" height="200"></canvas>
            </div>
            <div class="dashboard-section">
                <h3>üéÆ Your Games</h3>
                <div id="gamesList" class="games-list"></div>
            </div>
            <div class="dashboard-section">
                <h3>üí∞ Revenue Breakdown</h3>
                <div class="revenue-list" id="revenueList"></div>
            </div>
        </div>
    </div>

    <!-- Moderation Queue Modal -->
    <div id="moderationModal" class="modal">
        <div class="modal-content large-modal">
            <div class="modal-header">
                <h2>üõ°Ô∏è Moderation Queue</h2>
                <button id="closeModeration" class="close-btn">‚úï</button>
            </div>
            <div class="moderation-stats">
                <div class="mod-stat">
                    <span class="mod-stat-label">Pending:</span>
                    <span id="pendingCount" class="mod-stat-value">0</span>
                </div>
                <div class="mod-stat">
                    <span class="mod-stat-label">Approved Today:</span>
                    <span id="approvedCount" class="mod-stat-value">0</span>
                </div>
                <div class="mod-stat">
                    <span class="mod-stat-label">Rejected Today:</span>
                    <span id="rejectedCount" class="mod-stat-value">0</span>
                </div>
            </div>
            <div id="moderationQueue" class="moderation-queue"></div>
        </div>
    </div>

    <!-- Moderation Preview Modal -->
    <div id="moderationPreviewModal" class="modal">
        <div class="modal-content large-modal">
            <div class="modal-header">
                <h2>üéÆ Review Game</h2>
                <button id="closeModPreview" class="close-btn">‚úï</button>
            </div>
            <div class="mod-preview-content">
                <div class="mod-game-info">
                    <h3 id="modGameTitle">Game Title</h3>
                    <div class="mod-game-meta">
                        <span>By: <strong id="modGameAuthor">Author</strong></span>
                        <span>Submitted: <strong id="modGameDate">Date</strong></span>
                    </div>
                </div>
                <div class="mod-preview-canvas">
                    <canvas id="modGameCanvas" width="800" height="600"></canvas>
                </div>
                <div class="mod-actions">
                    <textarea id="modFeedback" placeholder="Add feedback (optional)" rows="3"></textarea>
                    <div class="mod-buttons">
                        <button id="rejectGame" class="mod-btn reject">‚ùå Reject</button>
                        <button id="approveGame" class="mod-btn approve">‚úÖ Approve</button>
                    </div>
                </div>
            </div>
        </div>
    </div>



    <!-- User Profile Settings Modal -->
    <div id="settingsModal" class="modal">
        <div class="modal-content large-modal">
            <div class="modal-header">
                <h2>‚öôÔ∏è Profile & Settings</h2>
                <button id="closeSettings" class="close-btn">‚úï</button>
            </div>
            <div class="settings-tabs">
                <button class="settings-tab active" data-tab="profile">üë§ Profile</button>
                <button class="settings-tab" data-tab="preferences">üé® Preferences</button>
                <button class="settings-tab" data-tab="privacy">üîí Privacy</button>
                <button class="settings-tab" data-tab="account">üîë Account</button>
            </div>
            <div id="profileTab" class="settings-tab-content active">
                <div class="settings-section">
                    <h3>Profile Information</h3>
                    <div class="profile-avatar-section">
                        <div class="profile-avatar-large">üë§</div>
                        <button class="change-avatar-btn">Change Avatar</button>
                    </div>
                    <div class="form-group">
                        <label>Username</label>
                        <input type="text" id="username" value="GameDev123" maxlength="20">
                    </div>
                    <div class="form-group">
                        <label>Bio</label>
                        <textarea id="bio" rows="4" maxlength="200" placeholder="Tell us about yourself..."></textarea>
                    </div>
                    <div class="form-group">
                        <label>Role</label>
                        <select id="userRole">
                            <option value="player">Player</option>
                            <option value="developer">Developer</option>
                            <option value="moderator">Moderator</option>
                            <option value="admin">Admin</option>
                        </select>
                    </div>
                    <button class="save-settings-btn">üíæ Save Profile</button>
                </div>
            </div>
            <div id="preferencesTab" class="settings-tab-content">
                <div class="settings-section">
                    <h3>Appearance</h3>
                    <div class="form-group">
                        <label>Theme</label>
                        <select id="theme">
                            <option value="dark">üåô Dark Mode</option>
                            <option value="light">‚òÄÔ∏è Light Mode</option>
                            <option value="auto">üîÑ Auto</option>
                        </select>
                    </div>
                    <div class="form-group">
                        <label><input type="checkbox" id="animations" checked> Enable Animations</label>
                    </div>
                </div>
                <div class="settings-section">
                    <h3>Notifications</h3>
                    <div class="form-group">
                        <label><input type="checkbox" id="notifyGames" checked> Game Approvals</label>
                    </div>
                    <div class="form-group">
                        <label><input type="checkbox" id="notifyFollowers" checked> New Followers</label>
                    </div>
                    <div class="form-group">
                        <label><input type="checkbox" id="notifyComments" checked> Comments on Games</label>
                    </div>
                </div>
                <div class="settings-section">
                    <h3>Editor</h3>
                    <div class="form-group">
                        <label>Auto-Save Interval</label>
                        <select id="autoSaveInterval">
                            <option value="10">10 seconds</option>
                            <option value="30" selected>30 seconds</option>
                            <option value="60">1 minute</option>
                            <option value="0">Disabled</option>
                        </select>
                    </div>
                    <div class="form-group">
                        <label><input type="checkbox" id="snapToGrid" checked> Snap Blocks to Grid</label>
                    </div>
                </div>
                <button class="save-settings-btn">üíæ Save Preferences</button>
            </div>
            <div id="privacyTab" class="settings-tab-content">
                <div class="settings-section">
                    <h3>Privacy Settings</h3>
                    <div class="form-group">
                        <label>Profile Visibility</label>
                        <select id="profileVisibility">
                            <option value="public">Public</option>
                            <option value="friends">Friends Only</option>
                            <option value="private">Private</option>
                        </select>
                    </div>
                    <div class="form-group">
                        <label><input type="checkbox" id="showStats" checked> Show Statistics on Profile</label>
                    </div>
                    <div class="form-group">
                        <label><input type="checkbox" id="allowMessages" checked> Allow Direct Messages</label>
                    </div>
                    <div class="form-group">
                        <label><input type="checkbox" id="showOnline"> Show Online Status</label>
                    </div>
                </div>
                <button class="save-settings-btn">üíæ Save Privacy Settings</button>
            </div>
            <div id="accountTab" class="settings-tab-content">
                <div class="settings-section">
                    <h3>Account Security</h3>
                    <div class="form-group">
                        <label>Email</label>
                        <input type="email" id="email" value="user@example.com">
                    </div>
                    <div class="form-group">
                        <label>Current Password</label>
                        <input type="password" id="currentPassword" placeholder="‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢">
                    </div>
                    <div class="form-group">
                        <label>New Password</label>
                        <input type="password" id="newPassword" placeholder="‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢">
                    </div>
                    <div class="form-group">
                        <label>Confirm Password</label>
                        <input type="password" id="confirmPassword" placeholder="‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢">
                    </div>
                    <button class="save-settings-btn">üîí Change Password</button>
                </div>
                <div class="settings-section danger-zone">
                    <h3>‚ö†Ô∏è Danger Zone</h3>
                    <button class="danger-btn">üóëÔ∏è Delete Account</button>
                    <p style="font-size: 12px; color: #95a5a6; margin-top: 10px;">This action cannot be undone.</p>
                </div>
            </div>
        </div>
    </div>

    <xml id="toolbox" style="display: none">
        <category name="Events" colour="#4a90e2">
            <block type="on_game_start"></block>
            <block type="on_scene_load"></block>
            <block type="on_key_press"></block>
            <block type="on_mouse_click"></block>
            <block type="on_collision_tagged"></block>
            <block type="on_object_destroyed"></block>
            <block type="on_score_change"></block>
            <block type="on_area_enter"></block>
            <block type="on_level_complete"></block>
            <block type="on_timer"></block>
        </category>
        
        <category name="Logic & Flow" colour="#5b67a5">
            <block type="controls_if"></block>
            <block type="switch_case"></block>
            <block type="while_loop"></block>
            <block type="repeat_until"></block>
            <block type="loop_break"></block>
            <block type="loop_continue"></block>
            <block type="delay"></block>
            <block type="cooldown"></block>
            <block type="logic_compare"></block>
            <block type="logic_operation"></block>
            <block type="logic_boolean"></block>
            <block type="random_choice"></block>
            <block type="weighted_random"></block>
        </category>
        
        <category name="Functions" colour="#9b59b6">
            <block type="define_function"></block>
            <block type="call_function"></block>
        </category>
        
        <category name="Movement" colour="#9b59b6">
            <block type="move_player"></block>
            <block type="set_velocity"></block>
            <block type="apply_gravity"></block>
            <block type="apply_friction"></block>
            <block type="jump_buffered"></block>
            <block type="dash"></block>
            <block type="knockback"></block>
            <block type="move_along_path"></block>
            <block type="find_path_to"></block>
        </category>
        
        <category name="AI Behavior" colour="#e67e22">
            <block type="ai_patrol"></block>
            <block type="ai_chase"></block>
            <block type="ai_flee"></block>
        </category>
        
        <category name="Objects" colour="#e67e22">
            <block type="spawn_sprite"></block>
            <block type="destroy_sprite"></block>
            <block type="collision_response"></block>
        </category>
        
        <category name="Keyframes & Animation" colour="#9b59b6">
            <block type="create_keyframe"></block>
            <block type="set_keyframe_property"></block>
            <block type="animate_keyframes"></block>
        </category>
        
        <category name="Sprite Sheet Animations" colour="#f39c12">
            <block type="play_animation"></block>
            <block type="stop_animation"></block>
            <block type="animation_with_keyframes"></block>
        </category>
        
        <category name="Inventory" colour="#f39c12">
            <block type="inventory_add"></block>
            <block type="inventory_remove"></block>
            <block type="inventory_has"></block>
            <block type="pickup_create"></block>
        </category>
        
        <category name="Powerups & Buffs" colour="#27ae60">
            <block type="apply_powerup"></block>
            <block type="apply_debuff"></block>
            <block type="has_buff"></block>
        </category>
        
        <category name="Camera" colour="#3498db">
            <block type="camera_follow"></block>
            <block type="camera_clamp"></block>
        </category>
        
        <category name="State & Data" colour="#f39c12">
            <block type="set_variable"></block>
            <block type="get_variable"></block>
            <block type="create_array"></block>
            <block type="array_push"></block>
        </category>
        
        <category name="Health & Lives" colour="#e74c3c">
            <block type="set_health"></block>
            <block type="add_health"></block>
            <block type="set_lives"></block>
            <block type="add_score"></block>
        </category>
        
        <category name="Save/Load" colour="#16a085">
            <block type="save_game"></block>
            <block type="load_game"></block>
        </category>
        
        <category name="Math" colour="#5b995b">
            <block type="math_number"></block>
            <block type="math_arithmetic"></block>
        </category>
    </xml>

    <script>
        // Define custom blocks
        Blockly.Blocks['on_game_start'] = {
            init: function() {
                this.appendDummyInput()
                    .appendField("üé¨ On Game Start");
                this.appendStatementInput("DO")
                    .setCheck(null)
                    .appendField("do");
                this.setColour("#4a90e2");
                this.setTooltip("Runs when the game starts");
                this.setHelpUrl("");
            }
        };

        Blockly.Blocks['on_key_press'] = {
            init: function() {
                this.appendDummyInput()
                    .appendField("‚å®Ô∏è On Key Press")
                    .appendField(new Blockly.FieldDropdown([
                        ["‚Üë Up", "UP"],
                        ["‚Üì Down", "DOWN"],
                        ["‚Üê Left", "LEFT"],
                        ["‚Üí Right", "RIGHT"],
                        ["Space", "SPACE"]
                    ]), "KEY");
                this.appendStatementInput("DO")
                    .setCheck(null)
                    .appendField("do");
                this.setColour("#4a90e2");
                this.setTooltip("Runs when a key is pressed");
                this.setHelpUrl("");
            }
        };

        Blockly.Blocks['on_collision'] = {
            init: function() {
                this.appendDummyInput()
                    .appendField("üí• On Collision")
                    .appendField(new Blockly.FieldDropdown([
                        ["Player", "PLAYER"],
                        ["Enemy", "ENEMY"],
                        ["Coin", "COIN"],
                        ["Wall", "WALL"]
                    ]), "OBJECT1")
                    .appendField("with")
                    .appendField(new Blockly.FieldDropdown([
                        ["Enemy", "ENEMY"],
                        ["Coin", "COIN"],
                        ["Wall", "WALL"],
                        ["Player", "PLAYER"]
                    ]), "OBJECT2");
                this.appendStatementInput("DO")
                    .setCheck(null)
                    .appendField("do");
                this.setColour("#4a90e2");
                this.setTooltip("Runs when objects collide");
                this.setHelpUrl("");
            }
        };

        Blockly.Blocks['on_timer'] = {
            init: function() {
                this.appendDummyInput()
                    .appendField("‚è±Ô∏è Every")
                    .appendField(new Blockly.FieldNumber(1, 0.1, 10, 0.1), "SECONDS")
                    .appendField("seconds");
                this.appendStatementInput("DO")
                    .setCheck(null)
                    .appendField("do");
                this.setColour("#4a90e2");
                this.setTooltip("Runs repeatedly at interval");
                this.setHelpUrl("");
            }
        };

        Blockly.Blocks['move_player'] = {
            init: function() {
                this.appendDummyInput()
                    .appendField("üèÉ Move Player")
                    .appendField(new Blockly.FieldDropdown([
                        ["‚Üë Up", "UP"],
                        ["‚Üì Down", "DOWN"],
                        ["‚Üê Left", "LEFT"],
                        ["‚Üí Right", "RIGHT"]
                    ]), "DIRECTION")
                    .appendField("by")
                    .appendField(new Blockly.FieldNumber(10, 1, 100), "AMOUNT")
                    .appendField("pixels");
                this.setPreviousStatement(true, null);
                this.setNextStatement(true, null);
                this.setColour("#e67e22");
                this.setTooltip("Move the player in a direction");
                this.setHelpUrl("");
            }
        };

        Blockly.Blocks['spawn_sprite'] = {
            init: function() {
                const getOptions = () => AssetTagSystem.getAssetDropdownOptions();
                
                this.appendDummyInput()
                    .appendField("‚ú® Spawn")
                    .appendField(new Blockly.FieldDropdown(getOptions), "SPRITE")
                    .appendField("at x:")
                    .appendField(new Blockly.FieldNumber(0, -500, 500), "X")
                    .appendField("y:")
                    .appendField(new Blockly.FieldNumber(0, -500, 500), "Y");
                this.setPreviousStatement(true, null);
                this.setNextStatement(true, null);
                this.setColour("#e67e22");
                this.setTooltip("Spawn a sprite at position. Tags appear with üè∑Ô∏è, asset names with üì¶");
                this.setHelpUrl("");
            }
        };

        Blockly.Blocks['destroy_sprite'] = {
            init: function() {
                this.appendDummyInput()
                    .appendField("üí£ Destroy")
                    .appendField(new Blockly.FieldDropdown([
                        ["This sprite", "THIS"],
                        ["All enemies", "ALL_ENEMIES"],
                        ["All coins", "ALL_COINS"]
                    ]), "TARGET");
                this.setPreviousStatement(true, null);
                this.setNextStatement(true, null);
                this.setColour("#e67e22");
                this.setTooltip("Destroy sprites");
                this.setHelpUrl("");
            }
        };

        Blockly.Blocks['add_score'] = {
            init: function() {
                this.appendDummyInput()
                    .appendField("üèÜ Add Score")
                    .appendField(new Blockly.FieldNumber(10, -1000, 1000), "POINTS")
                    .appendField("points");
                this.setPreviousStatement(true, null);
                this.setNextStatement(true, null);
                this.setColour("#e67e22");
                this.setTooltip("Add points to score");
                this.setHelpUrl("");
            }
        };

        Blockly.Blocks['create_keyframe'] = {
            init: function() {
                const getTagOptions = () => {
                    const tags = AssetTagSystem.getAllTags();
                    const options = [["-- Select Tag --", ""]];
                    tags.forEach(tag => {
                        options.push([`üè∑Ô∏è ${tag}`, tag]);
                    });
                    return options;
                };
                
                this.appendDummyInput()
                    .appendField("‚è±Ô∏è Create Keyframe for")
                    .appendField(new Blockly.FieldDropdown(getTagOptions), "TAG")
                    .appendField("at")
                    .appendField(new Blockly.FieldNumber(0, 0, 10000, 100), "TIME")
                    .appendField("ms");
                this.setPreviousStatement(true, null);
                this.setNextStatement(true, null);
                this.setColour("#9b59b6");
                this.setTooltip("Create a keyframe at a specific time for all entities with a tag");
                this.setHelpUrl("");
            }
        };

        Blockly.Blocks['set_keyframe_property'] = {
            init: function() {
                this.appendDummyInput()
                    .appendField("üéØ Set Keyframe")
                    .appendField(new Blockly.FieldDropdown([
                        ["Position X", "posX"],
                        ["Position Y", "posY"],
                        ["Scale X", "scaleX"],
                        ["Scale Y", "scaleY"],
                        ["Rotation", "rotation"],
                        ["Opacity", "opacity"],
                        ["Velocity X", "velX"],
                        ["Velocity Y", "velY"]
                    ]), "PROPERTY")
                    .appendField("to")
                    .appendField(new Blockly.FieldNumber(0, -1000, 1000, 1), "VALUE");
                this.setPreviousStatement(true, null);
                this.setNextStatement(true, null);
                this.setColour("#9b59b6");
                this.setTooltip("Set a property value for the current keyframe");
                this.setHelpUrl("");
            }
        };

        Blockly.Blocks['animate_keyframes'] = {
            init: function() {
                const getTagOptions = () => {
                    const tags = AssetTagSystem.getAllTags();
                    const options = [["-- Select Tag --", ""]];
                    tags.forEach(tag => {
                        options.push([`üè∑Ô∏è ${tag}`, tag]);
                    });
                    return options;
                };
                
                this.appendDummyInput()
                    .appendField("üé¨ Animate")
                    .appendField(new Blockly.FieldDropdown(getTagOptions), "TAG")
                    .appendField("from")
                    .appendField(new Blockly.FieldNumber(0, 0, 10000, 100), "START_TIME")
                    .appendField("ms to")
                    .appendField(new Blockly.FieldNumber(1000, 0, 10000, 100), "END_TIME")
                    .appendField("ms");
                
                this.appendDummyInput()
                    .appendField("Easing:")
                    .appendField(new Blockly.FieldDropdown([
                        ["Linear", "linear"],
                        ["Ease In", "easeIn"],
                        ["Ease Out", "easeOut"],
                        ["Ease In-Out", "easeInOut"]
                    ]), "EASING");
                    
                this.setPreviousStatement(true, null);
                this.setNextStatement(true, null);
                this.setColour("#9b59b6");
                this.setTooltip("Animate all entities with tag using keyframes");
                this.setHelpUrl("");
            }
        };

        Blockly.Blocks['play_animation'] = {
            init: function() {
                const getAnimationOptions = () => {
                    const options = [["-- Select Animation --", ""]];
                    Object.values(AssetManager.assets.animations || []).forEach(anim => {
                        options.push([`üé¨ ${anim.name}`, anim.name]);
                    });
                    return options;
                };
                
                this.appendDummyInput()
                    .appendField("üé¨ Play Animation")
                    .appendField(new Blockly.FieldDropdown(getAnimationOptions), "ANIMATION")
                    .appendField("on tag")
                    .appendField(new Blockly.FieldDropdown(() => {
                        const tags = AssetTagSystem.getAllTags();
                        const options = [["-- Select Tag --", ""]];
                        tags.forEach(tag => options.push([`üè∑Ô∏è${tag}`, tag]));
                        return options;
                    }), "TAG");
                
                this.appendDummyInput()
                    .appendField("Loop:")
                    .appendField(new Blockly.FieldCheckbox(true), "LOOP");
                    
                this.setPreviousStatement(true, null);
                this.setNextStatement(true, null);
                this.setColour("#f39c12");
                this.setTooltip("Play a sprite sheet animation on entities with a specific tag");
                this.setHelpUrl("");
            }
        };

        Blockly.Blocks['stop_animation'] = {
            init: function() {
                const getAnimationOptions = () => {
                    const options = [["-- Select Animation --", ""]];
                    Object.values(AssetManager.assets.animations || []).forEach(anim => {
                        options.push([`üé¨ ${anim.name}`, anim.name]);
                    });
                    return options;
                };
                
                this.appendDummyInput()
                    .appendField("‚èπÔ∏è Stop Animation")
                    .appendField(new Blockly.FieldDropdown(getAnimationOptions), "ANIMATION")
                    .appendField("on tag")
                    .appendField(new Blockly.FieldDropdown(() => {
                        const tags = AssetTagSystem.getAllTags();
                        const options = [["-- Select Tag --", ""]];
                        tags.forEach(tag => options.push([`üè∑Ô∏è${tag}`, tag]));
                        return options;
                    }), "TAG");
                
                this.setPreviousStatement(true, null);
                this.setNextStatement(true, null);
                this.setColour("#f39c12");
                this.setTooltip("Stop a playing animation on entities with a specific tag");
                this.setHelpUrl("");
            }
        };

        Blockly.Blocks['animation_with_keyframes'] = {
            init: function() {
                const getAnimationOptions = () => {
                    const options = [["-- Select Animation --", ""]];
                    Object.values(AssetManager.assets.animations || []).forEach(anim => {
                        options.push([`üé¨ ${anim.name}`, anim.name]);
                    });
                    return options;
                };
                
                this.appendDummyInput()
                    .appendField("üéûÔ∏è Animate with Keyframes")
                    .appendField(new Blockly.FieldDropdown(getAnimationOptions), "ANIMATION")
                    .appendField("on tag")
                    .appendField(new Blockly.FieldDropdown(() => {
                        const tags = AssetTagSystem.getAllTags();
                        const options = [["-- Select Tag --", ""]];
                        tags.forEach(tag => options.push([`üè∑Ô∏è${tag}`, tag]));
                        return options;
                    }), "TAG");
                
                this.appendDummyInput()
                    .appendField("Duration:")
                    .appendField(new Blockly.FieldNumber(1000, 0, 10000, 100), "DURATION")
                    .appendField("ms");
                
                this.appendStatementInput("KEYFRAMES")
                    .setCheck(null)
                    .appendField("with keyframes:");
                
                this.setPreviousStatement(true, null);
                this.setNextStatement(true, null);
                this.setColour("#f39c12");
                this.setTooltip("Play animation and apply keyframe transformations simultaneously");
                this.setHelpUrl("");
            }
        };

        // === MOVEMENT BLOCKS ===
        Blockly.Blocks['set_velocity'] = {
            init: function() {
                this.appendDummyInput()
                    .appendField("üöÄ Set Velocity")
                    .appendField(new Blockly.FieldDropdown([
                        ["X", "X"], ["Y", "Y"]
                    ]), "AXIS")
                    .appendField("to")
                    .appendField(new Blockly.FieldNumber(0, -500, 500), "VALUE");
                this.setPreviousStatement(true, null);
                this.setNextStatement(true, null);
                this.setColour("#9b59b6");
            }
        };

        Blockly.Blocks['apply_gravity'] = {
            init: function() {
                this.appendDummyInput()
                    .appendField("üåç Apply Gravity")
                    .appendField(new Blockly.FieldNumber(9.8, 0, 100, 0.1), "FORCE");
                this.setPreviousStatement(true, null);
                this.setNextStatement(true, null);
                this.setColour("#9b59b6");
            }
        };

        Blockly.Blocks['apply_friction'] = {
            init: function() {
                this.appendDummyInput()
                    .appendField("üî• Apply Friction")
                    .appendField(new Blockly.FieldNumber(0.9, 0, 1, 0.01), "AMOUNT");
                this.setPreviousStatement(true, null);
                this.setNextStatement(true, null);
                this.setColour("#9b59b6");
            }
        };

        // === COLLISION RESPONSE BLOCKS ===
        Blockly.Blocks['collision_response'] = {
            init: function() {
                this.appendDummyInput()
                    .appendField("üí• On Collision with")
                    .appendField(new Blockly.FieldDropdown([
                        ["Enemy", "ENEMY"],
                        ["Wall", "WALL"],
                        ["Coin", "COIN"],
                        ["Player", "PLAYER"]
                    ]), "TARGET")
                    .appendField("Response:")
                    .appendField(new Blockly.FieldDropdown([
                        ["Solid", "SOLID"],
                        ["Trigger", "TRIGGER"],
                        ["Bounce", "BOUNCE"],
                        ["Damage", "DAMAGE"]
                    ]), "RESPONSE");
                this.appendStatementInput("DO")
                    .setCheck(null)
                    .appendField("do");
                this.setColour("#e74c3c");
            }
        };

        // === CAMERA BLOCKS ===
        Blockly.Blocks['camera_follow'] = {
            init: function() {
                this.appendDummyInput()
                    .appendField("üì∑ Camera Follow")
                    .appendField(new Blockly.FieldDropdown([
                        ["Player", "PLAYER"],
                        ["Target", "TARGET"]
                    ]), "TARGET")
                    .appendField("Smoothing:")
                    .appendField(new Blockly.FieldNumber(0.1, 0, 1, 0.01), "SMOOTH");
                this.setPreviousStatement(true, null);
                this.setNextStatement(true, null);
                this.setColour("#3498db");
            }
        };

        Blockly.Blocks['camera_clamp'] = {
            init: function() {
                this.appendDummyInput()
                    .appendField("üìê Clamp Camera to Bounds")
                    .appendField("min X:")
                    .appendField(new Blockly.FieldNumber(0, -1000, 1000), "MINX")
                    .appendField("max X:")
                    .appendField(new Blockly.FieldNumber(800, -1000, 5000), "MAXX");
                this.setPreviousStatement(true, null);
                this.setNextStatement(true, null);
                this.setColour("#3498db");
            }
        };

        // === STATE & DATA BLOCKS ===
        Blockly.Blocks['set_variable'] = {
            init: function() {
                this.appendDummyInput()
                    .appendField("üìù Set Variable")
                    .appendField(new Blockly.FieldTextInput("myVar"), "VARNAME")
                    .appendField("to")
                    .appendField(new Blockly.FieldNumber(0), "VALUE");
                this.setPreviousStatement(true, null);
                this.setNextStatement(true, null);
                this.setColour("#f39c12");
            }
        };

        Blockly.Blocks['get_variable'] = {
            init: function() {
                this.appendDummyInput()
                    .appendField("üìñ Get Variable")
                    .appendField(new Blockly.FieldTextInput("myVar"), "VARNAME");
                this.setOutput(true, "Number");
                this.setColour("#f39c12");
            }
        };

        Blockly.Blocks['create_array'] = {
            init: function() {
                this.appendDummyInput()
                    .appendField("üìö Create Array")
                    .appendField(new Blockly.FieldTextInput("enemies"), "ARRAYNAME");
                this.setPreviousStatement(true, null);
                this.setNextStatement(true, null);
                this.setColour("#f39c12");
            }
        };

        Blockly.Blocks['array_push'] = {
            init: function() {
                this.appendDummyInput()
                    .appendField("‚ûï Add to Array")
                    .appendField(new Blockly.FieldTextInput("enemies"), "ARRAYNAME");
                this.appendValueInput("ITEM")
                    .setCheck(null)
                    .appendField("Item:");
                this.setPreviousStatement(true, null);
                this.setNextStatement(true, null);
                this.setColour("#f39c12");
            }
        };

        // === HEALTH & CORE SYSTEMS ===
        Blockly.Blocks['set_health'] = {
            init: function() {
                this.appendDummyInput()
                    .appendField("‚ù§Ô∏è Set Health")
                    .appendField(new Blockly.FieldNumber(100, 0, 1000), "VALUE");
                this.setPreviousStatement(true, null);
                this.setNextStatement(true, null);
                this.setColour("#e74c3c");
            }
        };

        Blockly.Blocks['add_health'] = {
            init: function() {
                this.appendDummyInput()
                    .appendField("üíä Add Health")
                    .appendField(new Blockly.FieldNumber(10, -100, 100), "AMOUNT");
                this.setPreviousStatement(true, null);
                this.setNextStatement(true, null);
                this.setColour("#27ae60");
            }
        };

        Blockly.Blocks['set_lives'] = {
            init: function() {
                this.appendDummyInput()
                    .appendField("üí´ Set Lives")
                    .appendField(new Blockly.FieldNumber(3, 0, 99), "VALUE");
                this.setPreviousStatement(true, null);
                this.setNextStatement(true, null);
                this.setColour("#e74c3c");
            }
        };

        // === SAVE/LOAD BLOCKS ===
        Blockly.Blocks['save_game'] = {
            init: function() {
                this.appendDummyInput()
                    .appendField("üíæ Save Game State");
                this.setPreviousStatement(true, null);
                this.setNextStatement(true, null);
                this.setColour("#16a085");
            }
        };

        Blockly.Blocks['load_game'] = {
            init: function() {
                this.appendDummyInput()
                    .appendField("üìÇ Load Game State");
                this.setPreviousStatement(true, null);
                this.setNextStatement(true, null);
                this.setColour("#16a085");
            }
        };

        // === ADVANCED LOGIC BLOCKS ===
        Blockly.Blocks['switch_case'] = {
            init: function() {
                this.appendValueInput("VALUE")
                    .appendField("üîÄ Switch");
                this.appendStatementInput("CASE0")
                    .appendField("Case")
                    .appendField(new Blockly.FieldTextInput("1"), "MATCH0");
                this.appendStatementInput("DEFAULT")
                    .appendField("Default");
                this.setColour("#5b67a5");
                this.setPreviousStatement(true, null);
                this.setNextStatement(true, null);
            }
        };

        Blockly.Blocks['while_loop'] = {
            init: function() {
                this.appendValueInput("CONDITION")
                    .setCheck("Boolean")
                    .appendField("üîÅ While");
                this.appendStatementInput("DO")
                    .appendField("do");
                this.setColour("#5b67a5");
                this.setPreviousStatement(true, null);
                this.setNextStatement(true, null);
            }
        };

        Blockly.Blocks['repeat_until'] = {
            init: function() {
                this.appendValueInput("CONDITION")
                    .setCheck("Boolean")
                    .appendField("üîÑ Repeat Until");
                this.appendStatementInput("DO")
                    .appendField("do");
                this.setColour("#5b67a5");
                this.setPreviousStatement(true, null);
                this.setNextStatement(true, null);
            }
        };

        Blockly.Blocks['loop_break'] = {
            init: function() {
                this.appendDummyInput()
                    .appendField("üõë Break Loop");
                this.setColour("#5b67a5");
                this.setPreviousStatement(true, null);
            }
        };

        Blockly.Blocks['loop_continue'] = {
            init: function() {
                this.appendDummyInput()
                    .appendField("‚è≠Ô∏è Continue Loop");
                this.setColour("#5b67a5");
                this.setPreviousStatement(true, null);
            }
        };

        Blockly.Blocks['delay'] = {
            init: function() {
                this.appendDummyInput()
                    .appendField("‚è±Ô∏è Delay")
                    .appendField(new Blockly.FieldNumber(1, 0.1, 10, 0.1), "SECONDS")
                    .appendField("seconds");
                this.appendStatementInput("THEN")
                    .appendField("then");
                this.setColour("#5b67a5");
                this.setPreviousStatement(true, null);
                this.setNextStatement(true, null);
            }
        };

        Blockly.Blocks['cooldown'] = {
            init: function() {
                this.appendDummyInput()
                    .appendField("‚ùÑÔ∏è Cooldown")
                    .appendField(new Blockly.FieldTextInput("shoot"), "NAME")
                    .appendField(new Blockly.FieldNumber(1, 0.1, 60), "DURATION")
                    .appendField("sec");
                this.appendStatementInput("DO")
                    .appendField("do");
                this.setColour("#5b67a5");
                this.setPreviousStatement(true, null);
                this.setNextStatement(true, null);
            }
        };

        Blockly.Blocks['random_choice'] = {
            init: function() {
                this.appendDummyInput()
                    .appendField("üé≤ Random")
                    .appendField(new Blockly.FieldNumber(1, 1, 100), "MIN")
                    .appendField("to")
                    .appendField(new Blockly.FieldNumber(10, 1, 100), "MAX");
                this.setOutput(true, "Number");
                this.setColour("#5b67a5");
            }
        };

        Blockly.Blocks['weighted_random'] = {
            init: function() {
                this.appendDummyInput()
                    .appendField("üéØ Weighted Random");
                this.appendValueInput("WEIGHT1")
                    .appendField("Option 1:");
                this.appendValueInput("WEIGHT2")
                    .appendField("Option 2:");
                this.setOutput(true, "Number");
                this.setColour("#5b67a5");
            }
        };

        Blockly.Blocks['define_function'] = {
            init: function() {
                this.appendDummyInput()
                    .appendField("‚ö° Function")
                    .appendField(new Blockly.FieldTextInput("myFunction"), "NAME");
                this.appendStatementInput("DO")
                    .appendField("do");
                this.setColour("#9b59b6");
                this.setPreviousStatement(true, null);
                this.setNextStatement(true, null);
            }
        };

        Blockly.Blocks['call_function'] = {
            init: function() {
                this.appendDummyInput()
                    .appendField("üìû Call")
                    .appendField(new Blockly.FieldTextInput("myFunction"), "NAME");
                this.setColour("#9b59b6");
                this.setPreviousStatement(true, null);
                this.setNextStatement(true, null);
            }
        };

        // === INVENTORY & POWERUP BLOCKS ===
        Blockly.Blocks['inventory_add'] = {
            init: function() {
                this.appendDummyInput()
                    .appendField("üéí Add to Inventory")
                    .appendField(new Blockly.FieldTextInput("item"), "ITEM")
                    .appendField("quantity:")
                    .appendField(new Blockly.FieldNumber(1, 1, 99), "QUANTITY");
                this.setPreviousStatement(true, null);
                this.setNextStatement(true, null);
                this.setColour("#f39c12");
            }
        };

        Blockly.Blocks['inventory_remove'] = {
            init: function() {
                this.appendDummyInput()
                    .appendField("üóëÔ∏è Remove from Inventory")
                    .appendField(new Blockly.FieldTextInput("item"), "ITEM")
                    .appendField("quantity:")
                    .appendField(new Blockly.FieldNumber(1, 1, 99), "QUANTITY");
                this.setPreviousStatement(true, null);
                this.setNextStatement(true, null);
                this.setColour("#f39c12");
            }
        };

        Blockly.Blocks['inventory_has'] = {
            init: function() {
                this.appendDummyInput()
                    .appendField("üì¶ Has Item")
                    .appendField(new Blockly.FieldTextInput("item"), "ITEM");
                this.setOutput(true, "Boolean");
                this.setColour("#f39c12");
            }
        };

        Blockly.Blocks['apply_powerup'] = {
            init: function() {
                this.appendDummyInput()
                    .appendField("‚ö° Apply Powerup")
                    .appendField(new Blockly.FieldDropdown([
                        ["Speed Boost", "speed"],
                        ["Invincibility", "invincible"],
                        ["Double Jump", "doublejump"],
                        ["Shield", "shield"]
                    ]), "TYPE")
                    .appendField("duration:")
                    .appendField(new Blockly.FieldNumber(5, 1, 60), "DURATION");
                this.setPreviousStatement(true, null);
                this.setNextStatement(true, null);
                this.setColour("#27ae60");
            }
        };

        Blockly.Blocks['apply_debuff'] = {
            init: function() {
                this.appendDummyInput()
                    .appendField("üêå Apply Debuff")
                    .appendField(new Blockly.FieldDropdown([
                        ["Slow", "slow"],
                        ["Poison", "poison"],
                        ["Stun", "stun"],
                        ["Weak", "weak"]
                    ]), "TYPE")
                    .appendField("duration:")
                    .appendField(new Blockly.FieldNumber(3, 1, 30), "DURATION");
                this.setPreviousStatement(true, null);
                this.setNextStatement(true, null);
                this.setColour("#e74c3c");
            }
        };

        Blockly.Blocks['has_buff'] = {
            init: function() {
                this.appendDummyInput()
                    .appendField("‚ú® Has Buff")
                    .appendField(new Blockly.FieldTextInput("speed"), "BUFF");
                this.setOutput(true, "Boolean");
                this.setColour("#27ae60");
            }
        };

        Blockly.Blocks['pickup_create'] = {
            init: function() {
                this.appendDummyInput()
                    .appendField("üíé Create Pickup")
                    .appendField(new Blockly.FieldDropdown([
                        ["Coin", "coin"],
                        ["Health", "health"],
                        ["Key", "key"],
                        ["Powerup", "powerup"]
                    ]), "TYPE")
                    .appendField("at x:")
                    .appendField(new Blockly.FieldNumber(0, -1000, 1000), "X")
                    .appendField("y:")
                    .appendField(new Blockly.FieldNumber(0, -1000, 1000), "Y");
                this.setPreviousStatement(true, null);
                this.setNextStatement(true, null);
                this.setColour("#f39c12");
            }
        };

        // === ADVANCED MOVEMENT & AI BLOCKS ===
        Blockly.Blocks['move_along_path'] = {
            init: function() {
                this.appendDummyInput()
                    .appendField("üõ§Ô∏è Move")
                    .appendField(new Blockly.FieldDropdown([["this", "this"], ["player", "player"]]), "OBJECT")
                    .appendField("along path")
                    .appendField(new Blockly.FieldTextInput("path1"), "PATH")
                    .appendField("speed:")
                    .appendField(new Blockly.FieldNumber(100, 1, 500), "SPEED");
                this.setPreviousStatement(true, null);
                this.setNextStatement(true, null);
                this.setColour("#9b59b6");
            }
        };

        Blockly.Blocks['find_path_to'] = {
            init: function() {
                this.appendDummyInput()
                    .appendField("üó∫Ô∏è Find Path to")
                    .appendField(new Blockly.FieldDropdown([["player", "player"], ["target", "target"]]), "TARGET");
                this.setPreviousStatement(true, null);
                this.setNextStatement(true, null);
                this.setColour("#9b59b6");
            }
        };

        Blockly.Blocks['ai_patrol'] = {
            init: function() {
                this.appendDummyInput()
                    .appendField("üö∂ AI Patrol between")
                    .appendField(new Blockly.FieldNumber(0, -1000, 1000), "X1")
                    .appendField("and")
                    .appendField(new Blockly.FieldNumber(400, -1000, 1000), "X2");
                this.setPreviousStatement(true, null);
                this.setNextStatement(true, null);
                this.setColour("#e67e22");
            }
        };

        Blockly.Blocks['ai_chase'] = {
            init: function() {
                this.appendDummyInput()
                    .appendField("üèÉ AI Chase")
                    .appendField(new Blockly.FieldDropdown([["player", "player"], ["target", "target"]]), "TARGET")
                    .appendField("speed:")
                    .appendField(new Blockly.FieldNumber(150, 1, 500), "SPEED");
                this.setPreviousStatement(true, null);
                this.setNextStatement(true, null);
                this.setColour("#e67e22");
            }
        };

        Blockly.Blocks['ai_flee'] = {
            init: function() {
                this.appendDummyInput()
                    .appendField("üò± AI Flee from")
                    .appendField(new Blockly.FieldDropdown([["player", "player"], ["danger", "danger"]]), "TARGET")
                    .appendField("speed:")
                    .appendField(new Blockly.FieldNumber(200, 1, 500), "SPEED");
                this.setPreviousStatement(true, null);
                this.setNextStatement(true, null);
                this.setColour("#e67e22");
            }
        };

        Blockly.Blocks['jump_buffered'] = {
            init: function() {
                this.appendDummyInput()
                    .appendField("‚¨ÜÔ∏è Buffered Jump")
                    .appendField("force:")
                    .appendField(new Blockly.FieldNumber(300, 1, 1000), "FORCE")
                    .appendField("buffer:")
                    .appendField(new Blockly.FieldNumber(0.2, 0.05, 1, 0.05), "BUFFER");
                this.setPreviousStatement(true, null);
                this.setNextStatement(true, null);
                this.setColour("#9b59b6");
            }
        };

        Blockly.Blocks['dash'] = {
            init: function() {
                this.appendDummyInput()
                    .appendField("üí® Dash")
                    .appendField(new Blockly.FieldDropdown([["left", "LEFT"], ["right", "RIGHT"], ["up", "UP"], ["down", "DOWN"]]), "DIRECTION")
                    .appendField("distance:")
                    .appendField(new Blockly.FieldNumber(150, 1, 500), "DISTANCE");
                this.setPreviousStatement(true, null);
                this.setNextStatement(true, null);
                this.setColour("#9b59b6");
            }
        };

        Blockly.Blocks['knockback'] = {
            init: function() {
                this.appendDummyInput()
                    .appendField("üí• Knockback")
                    .appendField("force:")
                    .appendField(new Blockly.FieldNumber(200, 1, 1000), "FORCE")
                    .appendField("angle:")
                    .appendField(new Blockly.FieldNumber(45, 0, 360), "ANGLE");
                this.setPreviousStatement(true, null);
                this.setNextStatement(true, null);
                this.setColour("#9b59b6");
            }
        };

        // === ADVANCED EVENT BLOCKS ===
        Blockly.Blocks['on_scene_load'] = {
            init: function() {
                this.appendDummyInput()
                    .appendField("üé¨ On Scene Load")
                    .appendField(new Blockly.FieldTextInput("main"), "SCENE");
                this.appendStatementInput("DO")
                    .appendField("do");
                this.setColour("#4a90e2");
            }
        };

        Blockly.Blocks['on_collision_tagged'] = {
            init: function() {
                this.appendDummyInput()
                    .appendField("üí• On")
                    .appendField(new Blockly.FieldDropdown([["player", "player"], ["enemy", "enemy"], ["coin", "coin"]]), "TAG1")
                    .appendField("hits")
                    .appendField(new Blockly.FieldDropdown([["enemy", "enemy"], ["wall", "wall"], ["pickup", "pickup"]]), "TAG2");
                this.appendStatementInput("DO")
                    .appendField("do");
                this.setColour("#4a90e2");
            }
        };

        Blockly.Blocks['on_mouse_click'] = {
            init: function() {
                this.appendDummyInput()
                    .appendField("üñ±Ô∏è On Mouse Click");
                this.appendStatementInput("DO")
                    .appendField("do");
                this.setColour("#4a90e2");
            }
        };

        Blockly.Blocks['on_object_destroyed'] = {
            init: function() {
                this.appendDummyInput()
                    .appendField("üíÄ When")
                    .appendField(new Blockly.FieldDropdown([["enemy", "enemy"], ["player", "player"]]), "TAG")
                    .appendField("destroyed");
                this.appendStatementInput("DO")
                    .appendField("do");
                this.setColour("#4a90e2");
            }
        };

        Blockly.Blocks['on_score_change'] = {
            init: function() {
                this.appendDummyInput()
                    .appendField("üìä When Score")
                    .appendField(new Blockly.FieldDropdown([["increases", "increase"], ["decreases", "decrease"]]), "TYPE");
                this.appendStatementInput("DO")
                    .appendField("do");
                this.setColour("#4a90e2");
            }
        };

        Blockly.Blocks['on_area_enter'] = {
            init: function() {
                this.appendDummyInput()
                    .appendField("üö™ On Enter Zone")
                    .appendField(new Blockly.FieldTextInput("zone1"), "ZONE");
                this.appendStatementInput("DO")
                    .appendField("do");
                this.setColour("#4a90e2");
            }
        };

        Blockly.Blocks['on_level_complete'] = {
            init: function() {
                this.appendDummyInput()
                    .appendField("üéâ On Level Complete");
                this.appendStatementInput("DO")
                    .appendField("do");
                this.setColour("#4a90e2");
            }
        };

        // Code generators
        Blockly.JavaScript['on_game_start'] = function(block) {
            var statements = Blockly.JavaScript.statementToCode(block, 'DO');
            return 'onGameStart(() => {\n' + statements + '});\n';
        };

        Blockly.JavaScript['on_key_press'] = function(block) {
            var key = block.getFieldValue('KEY');
            var statements = Blockly.JavaScript.statementToCode(block, 'DO');
            return 'onKeyPress("' + key + '", () => {\n' + statements + '});\n';
        };

        Blockly.JavaScript['on_collision'] = function(block) {
            var obj1 = block.getFieldValue('OBJECT1');
            var obj2 = block.getFieldValue('OBJECT2');
            var statements = Blockly.JavaScript.statementToCode(block, 'DO');
            return 'onCollision("' + obj1 + '", "' + obj2 + '", () => {\n' + statements + '});\n';
        };

        Blockly.JavaScript['on_timer'] = function(block) {
            var seconds = block.getFieldValue('SECONDS');
            var statements = Blockly.JavaScript.statementToCode(block, 'DO');
            return 'everySeconds(' + seconds + ', () => {\n' + statements + '});\n';
        };

        Blockly.JavaScript['move_player'] = function(block) {
            var direction = block.getFieldValue('DIRECTION');
            var amount = block.getFieldValue('AMOUNT');
            return 'movePlayer("' + direction + '", ' + amount + ');\n';
        };

        Blockly.JavaScript['spawn_sprite'] = function(block) {
            var sprite = block.getFieldValue('SPRITE');
            var x = block.getFieldValue('X');
            var y = block.getFieldValue('Y');
            return 'spawnSprite("' + sprite + '", ' + x + ', ' + y + ');\n';
        };

        Blockly.JavaScript['destroy_sprite'] = function(block) {
            var target = block.getFieldValue('TARGET');
            return 'destroySprite("' + target + '");\n';
        };

        Blockly.JavaScript['add_score'] = function(block) {
            var points = block.getFieldValue('POINTS');
            return 'addScore(' + points + ');\n';
        };

        Blockly.JavaScript['create_keyframe'] = function(block) {
            const tag = block.getFieldValue('TAG');
            const time = block.getFieldValue('TIME');
            return `createKeyframeForTag("${tag}", ${time});\n`;
        };

        Blockly.JavaScript['set_keyframe_property'] = function(block) {
            const property = block.getFieldValue('PROPERTY');
            const value = block.getFieldValue('VALUE');
            return `setKeyframeProperty("${property}", ${value});\n`;
        };

        Blockly.JavaScript['animate_keyframes'] = function(block) {
            const tag = block.getFieldValue('TAG');
            const startTime = block.getFieldValue('START_TIME');
            const endTime = block.getFieldValue('END_TIME');
            const easing = block.getFieldValue('EASING');
            return `animateKeyframes("${tag}", ${startTime}, ${endTime}, "${easing}");\n`;
        };

        Blockly.JavaScript['play_animation'] = function(block) {
            const animation = block.getFieldValue('ANIMATION');
            const tag = block.getFieldValue('TAG');
            const loop = block.getFieldValue('LOOP') === 'TRUE';
            return `playAnimationOnTag("${animation}", "${tag}", {loop: ${loop}});\n`;
        };

        Blockly.JavaScript['stop_animation'] = function(block) {
            const animation = block.getFieldValue('ANIMATION');
            const tag = block.getFieldValue('TAG');
            return `stopAnimationOnTag("${animation}", "${tag}");\n`;
        };

        Blockly.JavaScript['animation_with_keyframes'] = function(block) {
            const animation = block.getFieldValue('ANIMATION');
            const tag = block.getFieldValue('TAG');
            const duration = block.getFieldValue('DURATION');
            const keyframeStatements = Blockly.JavaScript.statementToCode(block, 'KEYFRAMES');
            return `playAnimationWithKeyframes("${animation}", "${tag}", ${duration}, () => {\n${keyframeStatements}});\n`;
        };

        // === MOVEMENT GENERATORS ===
        Blockly.JavaScript['set_velocity'] = function(block) {
            const axis = block.getFieldValue('AXIS');
            const value = block.getFieldValue('VALUE');
            return `setVelocity("${axis}", ${value});\n`;
        };

        Blockly.JavaScript['apply_gravity'] = function(block) {
            const force = block.getFieldValue('FORCE');
            return `applyGravity(${force});\n`;
        };

        Blockly.JavaScript['apply_friction'] = function(block) {
            const amount = block.getFieldValue('AMOUNT');
            return `applyFriction(${amount});\n`;
        };

        // === COLLISION GENERATORS ===
        Blockly.JavaScript['collision_response'] = function(block) {
            const target = block.getFieldValue('TARGET');
            const response = block.getFieldValue('RESPONSE');
            const statements = Blockly.JavaScript.statementToCode(block, 'DO');
            return `onCollisionResponse("${target}", "${response}", () => {\n${statements}});\n`;
        };

        // === CAMERA GENERATORS ===
        Blockly.JavaScript['camera_follow'] = function(block) {
            const target = block.getFieldValue('TARGET');
            const smooth = block.getFieldValue('SMOOTH');
            return `cameraFollow("${target}", ${smooth});\n`;
        };

        Blockly.JavaScript['camera_clamp'] = function(block) {
            const minX = block.getFieldValue('MINX');
            const maxX = block.getFieldValue('MAXX');
            return `cameraClamp(${minX}, ${maxX});\n`;
        };

        // === STATE GENERATORS ===
        Blockly.JavaScript['set_variable'] = function(block) {
            const varName = block.getFieldValue('VARNAME');
            const value = block.getFieldValue('VALUE');
            return `gameState["${varName}"] = ${value};\n`;
        };

        Blockly.JavaScript['get_variable'] = function(block) {
            const varName = block.getFieldValue('VARNAME');
            return [`gameState["${varName}"]`, Blockly.JavaScript.ORDER_MEMBER];
        };

        Blockly.JavaScript['create_array'] = function(block) {
            const arrayName = block.getFieldValue('ARRAYNAME');
            return `gameState["${arrayName}"] = [];\n`;
        };

        Blockly.JavaScript['array_push'] = function(block) {
            const arrayName = block.getFieldValue('ARRAYNAME');
            const item = Blockly.JavaScript.valueToCode(block, 'ITEM', Blockly.JavaScript.ORDER_NONE) || 'null';
            return `gameState["${arrayName}"].push(${item});\n`;
        };

        // === HEALTH GENERATORS ===
        Blockly.JavaScript['set_health'] = function(block) {
            const value = block.getFieldValue('VALUE');
            return `setHealth(${value});\n`;
        };

        Blockly.JavaScript['add_health'] = function(block) {
            const amount = block.getFieldValue('AMOUNT');
            return `addHealth(${amount});\n`;
        };

        Blockly.JavaScript['set_lives'] = function(block) {
            const value = block.getFieldValue('VALUE');
            return `setLives(${value});\n`;
        };

        // === SAVE/LOAD GENERATORS ===
        Blockly.JavaScript['save_game'] = function(block) {
            return `saveGameState();\n`;
        };

        Blockly.JavaScript['load_game'] = function(block) {
            return `loadGameState();\n`;
        };

        // === SNIPPET 2 CODE GENERATORS ===
        Blockly.JavaScript['on_scene_load'] = function(block) {
            const scene = block.getFieldValue('SCENE');
            const statements = Blockly.JavaScript.statementToCode(block, 'DO');
            return `onSceneLoad("${scene}", () => {\n${statements}});\n`;
        };

        Blockly.JavaScript['on_collision_tagged'] = function(block) {
            const tag1 = block.getFieldValue('TAG1');
            const tag2 = block.getFieldValue('TAG2');
            const statements = Blockly.JavaScript.statementToCode(block, 'DO');
            return `onCollisionTagged("${tag1}", "${tag2}", () => {\n${statements}});\n`;
        };

        Blockly.JavaScript['on_mouse_click'] = function(block) {
            const statements = Blockly.JavaScript.statementToCode(block, 'DO');
            return `onMouseClick(() => {\n${statements}});\n`;
        };

        Blockly.JavaScript['on_object_destroyed'] = function(block) {
            const tag = block.getFieldValue('TAG');
            const statements = Blockly.JavaScript.statementToCode(block, 'DO');
            return `onObjectDestroyed("${tag}", () => {\n${statements}});\n`;
        };

        Blockly.JavaScript['on_score_change'] = function(block) {
            const type = block.getFieldValue('TYPE');
            const statements = Blockly.JavaScript.statementToCode(block, 'DO');
            return `onScoreChange("${type}", () => {\n${statements}});\n`;
        };

        Blockly.JavaScript['on_area_enter'] = function(block) {
            const zone = block.getFieldValue('ZONE');
            const statements = Blockly.JavaScript.statementToCode(block, 'DO');
            return `onAreaEnter("${zone}", () => {\n${statements}});\n`;
        };

        Blockly.JavaScript['on_level_complete'] = function(block) {
            const statements = Blockly.JavaScript.statementToCode(block, 'DO');
            return `onLevelComplete(() => {\n${statements}});\n`;
        };

        // === SNIPPET 3 CODE GENERATORS ===
        Blockly.JavaScript['move_along_path'] = function(block) {
            const object = block.getFieldValue('OBJECT');
            const path = block.getFieldValue('PATH');
            const speed = block.getFieldValue('SPEED');
            return `moveAlongPath("${object}", "${path}", ${speed});\n`;
        };

        Blockly.JavaScript['find_path_to'] = function(block) {
            const target = block.getFieldValue('TARGET');
            return `findPathTo("${target}");\n`;
        };

        Blockly.JavaScript['ai_patrol'] = function(block) {
            const x1 = block.getFieldValue('X1');
            const x2 = block.getFieldValue('X2');
            return `aiPatrol(${x1}, ${x2});\n`;
        };

        Blockly.JavaScript['ai_chase'] = function(block) {
            const target = block.getFieldValue('TARGET');
            const speed = block.getFieldValue('SPEED');
            return `aiChase("${target}", ${speed});\n`;
        };

        Blockly.JavaScript['ai_flee'] = function(block) {
            const target = block.getFieldValue('TARGET');
            const speed = block.getFieldValue('SPEED');
            return `aiFlee("${target}", ${speed});\n`;
        };

        Blockly.JavaScript['jump_buffered'] = function(block) {
            const force = block.getFieldValue('FORCE');
            const buffer = block.getFieldValue('BUFFER');
            return `jumpBuffered(${force}, ${buffer});\n`;
        };

        Blockly.JavaScript['dash'] = function(block) {
            const direction = block.getFieldValue('DIRECTION');
            const distance = block.getFieldValue('DISTANCE');
            return `dash("${direction}", ${distance});\n`;
        };

        Blockly.JavaScript['knockback'] = function(block) {
            const force = block.getFieldValue('FORCE');
            const angle = block.getFieldValue('ANGLE');
            return `knockback(${force}, ${angle});\n`;
        };

        // === SNIPPET 4 CODE GENERATORS ===
        Blockly.JavaScript['inventory_add'] = function(block) {
            const item = block.getFieldValue('ITEM');
            const quantity = block.getFieldValue('QUANTITY');
            return `inventoryAdd("${item}", ${quantity});\n`;
        };

        Blockly.JavaScript['inventory_remove'] = function(block) {
            const item = block.getFieldValue('ITEM');
            const quantity = block.getFieldValue('QUANTITY');
            return `inventoryRemove("${item}", ${quantity});\n`;
        };

        Blockly.JavaScript['inventory_has'] = function(block) {
            const item = block.getFieldValue('ITEM');
            return [`inventoryHas("${item}")`, Blockly.JavaScript.ORDER_FUNCTION_CALL];
        };

        Blockly.JavaScript['apply_powerup'] = function(block) {
            const type = block.getFieldValue('TYPE');
            const duration = block.getFieldValue('DURATION');
            return `applyPowerup("${type}", ${duration});\n`;
        };

        Blockly.JavaScript['apply_debuff'] = function(block) {
            const type = block.getFieldValue('TYPE');
            const duration = block.getFieldValue('DURATION');
            return `applyDebuff("${type}", ${duration});\n`;
        };

        Blockly.JavaScript['has_buff'] = function(block) {
            const buff = block.getFieldValue('BUFF');
            return [`hasBuff("${buff}")`, Blockly.JavaScript.ORDER_FUNCTION_CALL];
        };

        Blockly.JavaScript['pickup_create'] = function(block) {
            const type = block.getFieldValue('TYPE');
            const x = block.getFieldValue('X');
            const y = block.getFieldValue('Y');
            return `createPickup("${type}", ${x}, ${y});\n`;
        };

        // === SNIPPET 1 CODE GENERATORS ===
        Blockly.JavaScript['switch_case'] = function(block) {
            const value = Blockly.JavaScript.valueToCode(block, 'VALUE', Blockly.JavaScript.ORDER_NONE) || '0';
            const match0 = block.getFieldValue('MATCH0');
            const case0 = Blockly.JavaScript.statementToCode(block, 'CASE0');
            const defaultCase = Blockly.JavaScript.statementToCode(block, 'DEFAULT');
            return `switch(${value}) {\n  case ${match0}:\n${case0}\n    break;\n  default:\n${defaultCase}\n}\n`;
        };

        Blockly.JavaScript['while_loop'] = function(block) {
            const condition = Blockly.JavaScript.valueToCode(block, 'CONDITION', Blockly.JavaScript.ORDER_NONE) || 'false';
            const statements = Blockly.JavaScript.statementToCode(block, 'DO');
            return `while(${condition}) {\n${statements}}\n`;
        };

        Blockly.JavaScript['repeat_until'] = function(block) {
            const condition = Blockly.JavaScript.valueToCode(block, 'CONDITION', Blockly.JavaScript.ORDER_NONE) || 'true';
            const statements = Blockly.JavaScript.statementToCode(block, 'DO');
            return `do {\n${statements}} while(!(${condition}));\n`;
        };

        Blockly.JavaScript['loop_break'] = function(block) {
            return 'break;\n';
        };

        Blockly.JavaScript['loop_continue'] = function(block) {
            return 'continue;\n';
        };

        Blockly.JavaScript['delay'] = function(block) {
            const seconds = block.getFieldValue('SECONDS');
            const statements = Blockly.JavaScript.statementToCode(block, 'THEN');
            return `delay(${seconds}, () => {\n${statements}});\n`;
        };

        Blockly.JavaScript['cooldown'] = function(block) {
            const name = block.getFieldValue('NAME');
            const duration = block.getFieldValue('DURATION');
            const statements = Blockly.JavaScript.statementToCode(block, 'DO');
            return `cooldown("${name}", ${duration}, () => {\n${statements}});\n`;
        };

        Blockly.JavaScript['random_choice'] = function(block) {
            const min = block.getFieldValue('MIN');
            const max = block.getFieldValue('MAX');
            return [`randomInt(${min}, ${max})`, Blockly.JavaScript.ORDER_FUNCTION_CALL];
        };

        Blockly.JavaScript['weighted_random'] = function(block) {
            const weight1 = Blockly.JavaScript.valueToCode(block, 'WEIGHT1', Blockly.JavaScript.ORDER_NONE) || '1';
            const weight2 = Blockly.JavaScript.valueToCode(block, 'WEIGHT2', Blockly.JavaScript.ORDER_NONE) || '1';
            return [`weightedRandom([${weight1}, ${weight2}])`, Blockly.JavaScript.ORDER_FUNCTION_CALL];
        };

        Blockly.JavaScript['define_function'] = function(block) {
            const name = block.getFieldValue('NAME');
            const statements = Blockly.JavaScript.statementToCode(block, 'DO');
            return `function ${name}() {\n${statements}}\n`;
        };

        Blockly.JavaScript['call_function'] = function(block) {
            const name = block.getFieldValue('NAME');
            return `${name}();\n`;
        };

        // Initialize Blockly workspace
        let workspace;
        const STORAGE_KEY = 'lupiforge_project_' + (window.LUPIFORGE_CURRENT_USER && window.LUPIFORGE_CURRENT_USER.id ? window.LUPIFORGE_CURRENT_USER.id : 'guest');

        // Utility functions
        function showToast(message, isError = false) {
            const toast = document.getElementById('toast');
            toast.textContent = message;
            toast.className = 'toast show' + (isError ? ' error' : '');
            setTimeout(() => toast.classList.remove('show'), 3000);
        }

        function updateSaveStatus() {
            const status = document.getElementById('saveStatus');
            const now = new Date();
            status.textContent = `Saved at ${now.toLocaleTimeString()}`;
        }

        function saveProject() {
            const projectName = document.getElementById('projectName').value.trim() || 'Untitled Game';
            const xml = Blockly.Xml.workspaceToDom(workspace);
            const xmlText = Blockly.Xml.domToText(xml);
            const code = Blockly.JavaScript.workspaceToCode(workspace);

            const projectData = {
                name: projectName,
                xml: xmlText,
                code: code,
                timestamp: new Date().toISOString()
            };

            localStorage.setItem(STORAGE_KEY, JSON.stringify(projectData));
            updateSaveStatus();
            showToast('‚úÖ Project saved locally');
            console.log('Project saved locally:', projectData);

            // Also attempt to persist to server (best-effort). Uses CSRF cookie.
            try{
                const csrftoken = (document.cookie.match(/csrftoken=([^;]+)/)||[])[1] || '';
                fetch('{% url "save_game" %}', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-CSRFToken': csrftoken,
                        'X-Requested-With': 'XMLHttpRequest'
                    },
                    body: JSON.stringify({
                        title: projectName,
                        description: 'Saved from in-browser editor',
                        logic_json: { xml: xmlText, code: code }
                    })
                }).then(async res => {
                    if(!res.ok) throw new Error('Save failed');
                    const data = await res.json();
                    showToast('üíæ Saved to your account');
                    console.log('Server save response:', data);
                }).catch(err => {
                    console.warn('Server save failed:', err);
                });
            }catch(e){ console.warn('Error persisting to server', e); }

            // Check achievements
            const blockCount = workspace.getAllBlocks(false).length;
            if (blockCount >= 1) {
                AchievementManager.check('first_game');
            }
            if (blockCount >= 10) {
                AchievementManager.check('ten_blocks');
            }
            AchievementManager.check('first_save');
        }

        function loadProject() {
            const saved = localStorage.getItem(STORAGE_KEY);
            if (saved) {
                try {
                    const projectData = JSON.parse(saved);
                    document.getElementById('projectName').value = projectData.name;
                    const xml = Blockly.utils.xml.textToDom(projectData.xml);
                    Blockly.Xml.domToWorkspace(xml, workspace);
                    
                    const savedDate = new Date(projectData.timestamp);
                    document.getElementById('saveStatus').textContent = 
                        `Loaded from ${savedDate.toLocaleDateString()}`;
                    
                    console.log('Project loaded:', projectData);
                    showToast('üìÇ Project loaded!');
                } catch (e) {
                    console.error('Failed to load project:', e);
                    showToast('‚ùå Failed to load project', true);
                }
            }
        }

        function clearProject() {
            if (confirm('‚ö†Ô∏è Are you sure you want to clear the workspace? This cannot be undone.')) {
                workspace.clear();
                document.getElementById('projectName').value = '';
                localStorage.removeItem(STORAGE_KEY);
                document.getElementById('saveStatus').textContent = 'Never saved';
                showToast('üóëÔ∏è Workspace cleared');
            }
        }

        function preparePublish() {
            const projectName = document.getElementById('projectName').value.trim();
            if (!projectName) {
                showToast('‚ùå Please enter a game title first!', true);
                return;
            }

            const blockCount = workspace.getAllBlocks(false).length;
            if (blockCount === 0) {
                showToast('‚ùå Your game needs blocks to publish!', true);
                return;
            }

            document.getElementById('modalGameTitle').textContent = projectName;
            document.getElementById('publishModal').classList.add('show');
        }

        function publishGame() {
            const projectName = document.getElementById('projectName').value.trim();
            const xml = Blockly.Xml.workspaceToDom(workspace);
            const xmlText = Blockly.Xml.domToText(xml);
            const code = Blockly.JavaScript.workspaceToCode(workspace);

            const publishData = {
                title: projectName,
                logic_json: xmlText,
                generated_code: code,
                visibility: 'pending',
                submitted_at: new Date().toISOString()
            };

            // In production, this would be: POST /games/api/publish/
            console.log('Game ready for publication:', publishData);
            console.log('API Endpoint: POST /games/api/publish/');
            console.log('Headers: {"Authorization": "Bearer <token>", "Content-Type": "application/json"}');
            
            document.getElementById('publishModal').classList.remove('show');
            showToast('üöÄ Game submitted for review!');
            
            // Show what would be sent to backend
            const output = document.getElementById('output');
            output.textContent = `üì§ PUBLISH DATA (Ready for API):\n\n${JSON.stringify(publishData, null, 2)}`;
            output.classList.add('show');

            // Check achievement
            AchievementManager.check('first_publish');

            // Add notification
            NotificationManager.add(
                'üöÄ Game Submitted!',
                'Your game is now pending moderator review.',
                'pending'
            );
            
            // Simulate moderator response after 5 seconds (demo only)
            setTimeout(() => {
                NotificationManager.simulateModeratorFeedback('approved');
            }, 5000);
        }

        // Leaderboard Manager
        const LeaderboardManager = {
            currentPeriod: 'daily',
            scores: [],

            init() {
                this.generateMockData();
                this.attachEvents();
            },

            attachEvents() {
                document.getElementById('leaderboardBtn').addEventListener('click', () => this.show());
                document.getElementById('closeLeaderboard').addEventListener('click', () => {
                    document.getElementById('leaderboardModal').classList.remove('show');
                });
                document.querySelectorAll('.filter-btn').forEach(btn => {
                    btn.addEventListener('click', (e) => {
                        document.querySelectorAll('.filter-btn').forEach(b => b.classList.remove('active'));
                        e.target.classList.add('active');
                        this.currentPeriod = e.target.dataset.period;
                        this.loadLeaderboard();
                    });
                });
            },

            show() {
                document.getElementById('leaderboardModal').classList.add('show');
                this.loadLeaderboard();
            },

            loadLeaderboard() {
                console.log('Loading leaderboard for period:', this.currentPeriod);
                console.log('API Endpoint: GET /games/api/leaderboard/?period=' + this.currentPeriod);
                this.render();
            },

            generateMockData() {
                const names = ['Alex', 'Jordan', 'Sam', 'Casey', 'Morgan', 'Taylor', 'Riley', 'Avery', 'Quinn', 'Skyler'];
                const games = ['Space Invaders', 'Platformer Pro', 'Puzzle Master', 'Racing Game', 'Adventure Quest'];
                for (let i = 0; i < 50; i++) {
                    this.scores.push({
                        rank: i + 1,
                        player: names[Math.floor(Math.random() * names.length)] + Math.floor(Math.random() * 100),
                        game: games[Math.floor(Math.random() * games.length)],
                        score: Math.floor(Math.random() * 10000) + 1000,
                        date: new Date(Date.now() - Math.random() * 7 * 24 * 60 * 60 * 1000).toLocaleDateString(),
                        isCurrentUser: i === 15
                    });
                }
            },

            render() {
                const tbody = document.getElementById('leaderboardTableBody');
                const topScores = this.scores.slice(0, 100);
                tbody.innerHTML = topScores.map(score => {
                    const rankDisplay = score.rank <= 3 ? 
                        `<span class="rank-medal">${['ü•á', 'ü•à', 'ü•â'][score.rank - 1]}</span>` : 
                        `#${score.rank}`;
                    const rowClass = score.isCurrentUser ? 'style="background: rgba(231, 76, 60, 0.2);"' : '';
                    return `<tr ${rowClass}><td>${rankDisplay}</td><td>${score.player}${score.isCurrentUser ? ' üë§' : ''}</td><td>${score.game}</td><td><strong>${score.score.toLocaleString()}</strong></td><td>${score.date}</td></tr>`;
                }).join('');
                const userScore = this.scores.find(s => s.isCurrentUser);
                if (userScore) {
                    document.getElementById('userRank').textContent = `#${userScore.rank}`;
                    document.getElementById('userBest').textContent = userScore.score.toLocaleString();
                }
            }
        };



        // Dashboard Manager with Enhanced Analytics
        const DashboardManager = {
            stats: {totalGames: 0, totalPlays: 0, totalFollowers: 0, totalRevenue: 0, avgPlays: 0, conversionRate: 0},
            games: [],
            revenue: [],
            chart: null,
            playTrends: [],

            init() {
                this.generateMockData();
                this.attachEvents();
            },

            attachEvents() {
                document.getElementById('dashboardBtn').addEventListener('click', () => this.show());
                document.getElementById('closeDashboard').addEventListener('click', () => {
                    document.getElementById('dashboardModal').classList.remove('show');
                });
            },

            show() {
                document.getElementById('dashboardModal').classList.add('show');
                this.loadDashboard();
            },

            loadDashboard() {
                console.log('Loading creator dashboard');
                console.log('API Endpoint: GET /games/api/creator/dashboard/');
                this.calculateAnalytics();
                this.renderStats();
                this.renderGames();
                this.renderRevenue();
                this.renderChart();
            },

            calculateAnalytics() {
                if (this.games.length > 0) {
                    const totalPlays = this.games.reduce((sum, g) => sum + g.plays, 0);
                    const totalLikes = this.games.reduce((sum, g) => sum + g.likes, 0);
                    this.stats.avgPlays = Math.floor(totalPlays / this.games.length);
                    this.stats.conversionRate = this.games.length > 0 ? Math.round((totalLikes / totalPlays) * 100) : 0;
                    this.stats.publicGames = this.games.filter(g => g.status === 'public').length;
                    this.stats.totalLikes = totalLikes;
                }
            },

            generateMockData() {
                this.stats.totalGames = Math.floor(Math.random() * 20) + 5;
                this.stats.totalPlays = Math.floor(Math.random() * 10000) + 1000;
                this.stats.totalFollowers = Math.floor(Math.random() * 500) + 50;
                this.stats.totalRevenue = Math.floor(Math.random() * 1000) + 100;
                
                const gameNames = ['Space Adventure', 'Platform Hero', 'Puzzle Quest', 'Racing Thunder', 'Battle Royale'];
                const statuses = ['public', 'pending', 'draft'];
                for (let i = 0; i < 8; i++) {
                    this.games.push({
                        id: i + 1,
                        title: gameNames[i % gameNames.length] + ' ' + (i + 1),
                        plays: Math.floor(Math.random() * 1000),
                        likes: Math.floor(Math.random() * 100),
                        status: statuses[Math.floor(Math.random() * statuses.length)],
                        created: new Date(Date.now() - Math.random() * 30 * 24 * 60 * 60 * 1000).toLocaleDateString()
                    });
                }
                for (let i = 0; i < 5; i++) {
                    this.revenue.push({game: gameNames[i], amount: Math.floor(Math.random() * 200) + 50});
                }
                this.playTrends = [120, 190, 150, 220, 280, 310, 290];
            },

            renderStats() {
                document.getElementById('totalGames').textContent = this.stats.totalGames;
                document.getElementById('totalPlays').textContent = this.stats.totalPlays.toLocaleString();
                document.getElementById('totalFollowers').textContent = this.stats.totalFollowers;
                document.getElementById('totalRevenue').textContent = '$' + this.stats.totalRevenue;
                
                const statsExtended = document.getElementById('statsExtended');
                if (statsExtended) {
                    statsExtended.innerHTML = `
                        <div class="stat-card">
                            <div class="stat-icon">üìä</div>
                            <div class="stat-label">Avg Plays/Game</div>
                            <div class="stat-value">${this.stats.avgPlays || 0}</div>
                        </div>
                        <div class="stat-card">
                            <div class="stat-icon">üíØ</div>
                            <div class="stat-label">Conversion Rate</div>
                            <div class="stat-value">${this.stats.conversionRate || 0}%</div>
                        </div>
                        <div class="stat-card">
                            <div class="stat-icon">‚úÖ</div>
                            <div class="stat-label">Published Games</div>
                            <div class="stat-value">${this.stats.publicGames || 0}</div>
                        </div>
                        <div class="stat-card">
                            <div class="stat-icon">‚ù§Ô∏è</div>
                            <div class="stat-label">Total Likes</div>
                            <div class="stat-value">${this.stats.totalLikes || 0}</div>
                        </div>
                    `;
                }
            },

            renderGames() {
                const container = document.getElementById('gamesList');
                if (!container) return;
                
                const sortedGames = [...this.games].sort((a, b) => b.plays - a.plays);
                container.innerHTML = sortedGames.map(game => {
                    const engagementRate = game.plays > 0 ? Math.round((game.likes / game.plays) * 100) : 0;
                    return `
                        <div class="game-card">
                            <div class="game-title">${game.title}</div>
                            <div class="game-stats">
                                <span>‚ñ∂Ô∏è ${game.plays} plays</span>
                                <span>‚ù§Ô∏è ${game.likes} likes</span>
                                <span>üìà ${engagementRate}% engagement</span>
                            </div>
                            <div>
                                <span class="game-status status-${game.status}">
                                    ${game.status.toUpperCase()}
                                </span>
                                <span style="font-size: 11px; color: #95a5a6; margin-left: 10px;">Created: ${game.created}</span>
                            </div>
                        </div>
                    `;
                }).join('');
            },

            renderRevenue() {
                const container = document.getElementById('revenueList');
                if (!container) return;
                
                const sortedRevenue = [...this.revenue].sort((a, b) => b.amount - a.amount);
                const totalRevenue = sortedRevenue.reduce((sum, item) => sum + item.amount, 0);
                
                container.innerHTML = sortedRevenue.map(item => {
                    const percentage = Math.round((item.amount / totalRevenue) * 100);
                    return `
                        <div class="revenue-item">
                            <div class="revenue-game">${item.game}</div>
                            <div style="flex: 1; margin: 0 10px; background: #0f3460; height: 20px; border-radius: 3px; overflow: hidden;">
                                <div style="background: linear-gradient(90deg, #667eea 0%, #764ba2 100%); width: ${percentage}%; height: 100%;"></div>
                            </div>
                            <div class="revenue-amount">$${item.amount} (${percentage}%)</div>
                        </div>
                    `;
                }).join('');
            },

            renderChart() {
                const canvas = document.getElementById('playsChart');
                if (!canvas) return;
                
                const ctx = canvas.getContext('2d');
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                const days = ['Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat', 'Sun'];
                const data = this.playTrends;
                const maxValue = Math.max(...data);
                const barWidth = canvas.width / days.length - 20;
                const scale = (canvas.height - 40) / maxValue;
                
                ctx.strokeStyle = '#667eea';
                ctx.lineWidth = 2;
                ctx.beginPath();
                data.forEach((value, i) => {
                    const x = i * (barWidth + 20) + 20 + barWidth / 2;
                    const height = value * scale;
                    const y = canvas.height - height - 20;
                    if (i === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                });
                ctx.stroke();
                
                data.forEach((value, i) => {
                    const x = i * (barWidth + 20) + 20;
                    const height = value * scale;
                    const y = canvas.height - height - 20;
                    ctx.fillStyle = '#667eea';
                    ctx.fillRect(x, y, barWidth, height);
                    ctx.fillStyle = 'white';
                    ctx.font = 'bold 12px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText(value, x + barWidth / 2, y - 8);
                    ctx.font = '11px Arial';
                    ctx.fillText(days[i], x + barWidth / 2, canvas.height - 5);
                });
            }
        };

        // Moderation Manager
        const ModerationManager = {
            queue: [],
            currentGame: null,
            isModerator: false,

            init() {
                this.checkModeratorRole();
                if (this.isModerator) {
                    document.getElementById('moderationBtn').style.display = 'block';
                    this.generateMockQueue();
                    this.attachEvents();
                }
            },

            checkModeratorRole() {
                const userRole = localStorage.getItem('user_role') || 'player';
                this.isModerator = userRole === 'moderator' || userRole === 'admin';
                console.log('User role:', userRole, 'Is moderator:', this.isModerator);
            },

            attachEvents() {
                document.getElementById('moderationBtn').addEventListener('click', () => this.show());
                document.getElementById('closeModeration').addEventListener('click', () => {
                    document.getElementById('moderationModal').classList.remove('show');
                });
                document.getElementById('closeModPreview').addEventListener('click', () => {
                    document.getElementById('moderationPreviewModal').classList.remove('show');
                });
                document.getElementById('approveGame').addEventListener('click', () => this.approveGame());
                document.getElementById('rejectGame').addEventListener('click', () => this.rejectGame());
            },

            show() {
                document.getElementById('moderationModal').classList.add('show');
                this.loadQueue();
            },

            loadQueue() {
                console.log('Loading moderation queue');
                console.log('API Endpoint: GET /games/api/moderation/queue/');
                this.renderStats();
                this.renderQueue();
            },

            generateMockQueue() {
                const names = ['Player1', 'Creator2', 'Designer3', 'Gamer4', 'Builder5'];
                const games = ['Epic Adventure', 'Puzzle Master', 'Racing Pro', 'Space Battle', 'Platform Hero'];
                for (let i = 0; i < 10; i++) {
                    this.queue.push({
                        id: i + 1,
                        title: games[i % games.length] + ' v' + (i + 1),
                        author: names[i % names.length],
                        submitted: new Date(Date.now() - Math.random() * 48 * 60 * 60 * 1000).toLocaleString(),
                        status: 'pending'
                    });
                }
            },

            renderStats() {
                const pending = this.queue.filter(g => g.status === 'pending').length;
                const approved = Math.floor(Math.random() * 20) + 5;
                const rejected = Math.floor(Math.random() * 10) + 2;
                document.getElementById('pendingCount').textContent = pending;
                document.getElementById('approvedCount').textContent = approved;
                document.getElementById('rejectedCount').textContent = rejected;
            },

            renderQueue() {
                const container = document.getElementById('moderationQueue');
                const pending = this.queue.filter(g => g.status === 'pending');
                if (pending.length === 0) {
                    container.innerHTML = '<p style="text-align: center; color: #95a5a6; padding: 40px;">‚úÖ All caught up! No games pending review.</p>';
                    return;
                }
                container.innerHTML = pending.map(game => `
                    <div class="mod-item">
                        <div class="mod-item-info">
                            <div class="mod-item-title">${game.title}</div>
                            <div class="mod-item-meta">
                                By ${game.author} ‚Ä¢ Submitted ${game.submitted}
                            </div>
                        </div>
                        <div class="mod-item-actions">
                            <button class="mod-btn review" onclick="ModerationManager.reviewGame(${game.id})">üëÅÔ∏è Review</button>
                            <button class="mod-btn approve" onclick="ModerationManager.quickApprove(${game.id})">‚úÖ</button>
                            <button class="mod-btn reject" onclick="ModerationManager.quickReject(${game.id})">‚ùå</button>
                        </div>
                    </div>
                `).join('');
            },

            reviewGame(gameId) {
                this.currentGame = this.queue.find(g => g.id === gameId);
                document.getElementById('modGameTitle').textContent = this.currentGame.title;
                document.getElementById('modGameAuthor').textContent = this.currentGame.author;
                document.getElementById('modGameDate').textContent = this.currentGame.submitted;
                document.getElementById('moderationPreviewModal').classList.add('show');
                this.renderGamePreview();
            },

            renderGamePreview() {
                const canvas = document.getElementById('modGameCanvas');
                const ctx = canvas.getContext('2d');
                ctx.fillStyle = '#000';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                ctx.fillStyle = '#27ae60';
                ctx.font = '24px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('Game Preview', canvas.width / 2, canvas.height / 2);
                ctx.fillText(this.currentGame.title, canvas.width / 2, canvas.height / 2 + 40);
            },

            quickApprove(gameId) {
                if (confirm('Quick approve this game?')) {
                    this.performApproval(gameId, '');
                }
            },

            quickReject(gameId) {
                const feedback = prompt('Reason for rejection:');
                if (feedback) {
                    this.performRejection(gameId, feedback);
                }
            },

            approveGame() {
                const feedback = document.getElementById('modFeedback').value;
                this.performApproval(this.currentGame.id, feedback);
                document.getElementById('moderationPreviewModal').classList.remove('show');
            },

            rejectGame() {
                const feedback = document.getElementById('modFeedback').value;
                if (!feedback) {
                    showToast('‚ùå Please provide feedback for rejection', true);
                    return;
                }
                this.performRejection(this.currentGame.id, feedback);
                document.getElementById('moderationPreviewModal').classList.remove('show');
            },

            performApproval(gameId, feedback) {
                const game = this.queue.find(g => g.id === gameId);
                game.status = 'approved';
                console.log('Game approved:', gameId, feedback);
                console.log('API Endpoint: POST /games/api/approve/', {game_id: gameId, feedback});
                showToast(`‚úÖ ${game.title} approved!`);
                NotificationManager.add('üéâ Game Approved!', `Your game "${game.title}" has been approved and is now live!`, 'approved');
                this.loadQueue();
            },

            performRejection(gameId, feedback) {
                const game = this.queue.find(g => g.id === gameId);
                game.status = 'rejected';
                console.log('Game rejected:', gameId, feedback);
                console.log('API Endpoint: POST /games/api/reject/', {game_id: gameId, feedback});
                showToast(`‚ùå ${game.title} rejected`);
                NotificationManager.add('‚ùå Game Needs Revision', `Your game "${game.title}" needs changes: ${feedback}`, 'rejected');
                this.loadQueue();
            }
        };



        // Settings Manager
        const SettingsManager = {
            settings: {profile: {}, preferences: {}, privacy: {}, account: {}},

            init() {
                this.loadSettings();
                this.attachEvents();
            },

            attachEvents() {
                document.getElementById('settingsBtn').addEventListener('click', () => this.show());
                document.getElementById('closeSettings').addEventListener('click', () => {
                    document.getElementById('settingsModal').classList.remove('show');
                });
                document.querySelectorAll('.settings-tab').forEach(tab => {
                    tab.addEventListener('click', (e) => {
                        document.querySelectorAll('.settings-tab').forEach(t => t.classList.remove('active'));
                        e.target.classList.add('active');
                        document.querySelectorAll('.settings-tab-content').forEach(c => c.classList.remove('active'));
                        const tabName = e.target.dataset.tab;
                        document.getElementById(tabName + 'Tab').classList.add('active');
                    });
                });
                document.querySelectorAll('.save-settings-btn').forEach(btn => {
                    btn.addEventListener('click', (e) => {
                        const section = e.target.closest('.settings-tab-content').id.replace('Tab', '');
                        this.saveSettings(section);
                    });
                });
                document.querySelector('.change-avatar-btn').addEventListener('click', () => {
                    const avatars = ['üë§', 'üéÆ', '‚ö°', 'üåü', 'üíé', 'üî•', 'üöÄ', '‚≠ê'];
                    const random = avatars[Math.floor(Math.random() * avatars.length)];
                    document.querySelector('.profile-avatar-large').textContent = random;
                    showToast('‚úÖ Avatar changed!');
                });
                document.getElementById('userRole').addEventListener('change', (e) => {
                    localStorage.setItem('user_role', e.target.value);
                    showToast(`Role changed to ${e.target.value}`);
                    if (e.target.value === 'moderator' || e.target.value === 'admin') {
                        ModerationManager.checkModeratorRole();
                        ModerationManager.init();
                    }
                });
                document.querySelector('.danger-btn').addEventListener('click', () => {
                    if (confirm('‚ö†Ô∏è Are you sure you want to delete your account? This cannot be undone!')) {
                        if (confirm('‚ö†Ô∏è FINAL WARNING: All your games, scores, and data will be permanently deleted!')) {
                            this.deleteAccount();
                        }
                    }
                });
            },

            show() {
                document.getElementById('settingsModal').classList.add('show');
                this.populateFields();
            },

            loadSettings() {
                const saved = localStorage.getItem('lupiforge_settings');
                if (saved) {
                    try { this.settings = JSON.parse(saved); } catch(e){ this.settings = {}; }
                } else {
                    this.settings = {
                        profile: {username: '', bio: '', role: 'player'},
                        preferences: {theme: 'dark', animations: true, notifyGames: true, notifyFollowers: true, notifyComments: true, autoSaveInterval: 30, snapToGrid: true},
                        privacy: {profileVisibility: 'public', showStats: true, allowMessages: true, showOnline: false},
                        account: {email: ''}
                    };
                }

                // If user is authenticated, attempt to load real profile & settings from server
                try {
                    const me = window.LUPIFORGE_CURRENT_USER || {};
                    if (me.is_authenticated) {
                        fetch('/games/api/creator/dashboard/')
                            .then(resp => {
                                if (!resp.ok) throw new Error('Network response was not ok');
                                return resp.json();
                            })
                            .then(data => {
                                this.settings.profile.username = me.username || data.username || this.settings.profile.username;
                                this.settings.profile.bio = data.bio || this.settings.profile.bio || '';
                                this.settings.profile.role = data.role || this.settings.profile.role || 'player';

                                // Merge preferences/privacy if provided by API
                                if (data.preferences) this.settings.preferences = Object.assign(this.settings.preferences || {}, data.preferences);
                                if (data.privacy) this.settings.privacy = Object.assign(this.settings.privacy || {}, data.privacy);

                                this.settings.account.email = me.email || data.email || this.settings.account.email || '';
                                try { localStorage.setItem('lupiforge_settings', JSON.stringify(this.settings)); } catch(e){}
                                try { this.populateFields(); } catch(e){}
                            })
                            .catch(err => { console.warn('Could not load creator dashboard data', err); });
                    }
                } catch(e) { /* ignore */ }
            },

            populateFields() {
                document.getElementById('username').value = this.settings.profile.username || '';
                document.getElementById('bio').value = this.settings.profile.bio || '';
                document.getElementById('userRole').value = localStorage.getItem('user_role') || 'player';
                document.getElementById('theme').value = this.settings.preferences.theme || 'dark';
                document.getElementById('animations').checked = this.settings.preferences.animations !== false;
                document.getElementById('notifyGames').checked = this.settings.preferences.notifyGames !== false;
                document.getElementById('notifyFollowers').checked = this.settings.preferences.notifyFollowers !== false;
                document.getElementById('notifyComments').checked = this.settings.preferences.notifyComments !== false;
                document.getElementById('autoSaveInterval').value = this.settings.preferences.autoSaveInterval || 30;
                document.getElementById('snapToGrid').checked = this.settings.preferences.snapToGrid !== false;
                document.getElementById('profileVisibility').value = this.settings.privacy.profileVisibility || 'public';
                document.getElementById('showStats').checked = this.settings.privacy.showStats !== false;
                document.getElementById('allowMessages').checked = this.settings.privacy.allowMessages !== false;
                document.getElementById('showOnline').checked = this.settings.privacy.showOnline === true;
                document.getElementById('email').value = this.settings.account.email || '';
            },

            saveSettings(section) {
                switch(section) {
                    case 'profile':
                        this.settings.profile = {
                            username: document.getElementById('username').value,
                            bio: document.getElementById('bio').value,
                            role: document.getElementById('userRole').value
                        };
                        break;
                    case 'preferences':
                        this.settings.preferences = {
                            theme: document.getElementById('theme').value,
                            animations: document.getElementById('animations').checked,
                            notifyGames: document.getElementById('notifyGames').checked,
                            notifyFollowers: document.getElementById('notifyFollowers').checked,
                            notifyComments: document.getElementById('notifyComments').checked,
                            autoSaveInterval: parseInt(document.getElementById('autoSaveInterval').value),
                            snapToGrid: document.getElementById('snapToGrid').checked
                        };
                        break;
                    case 'privacy':
                        this.settings.privacy = {
                            profileVisibility: document.getElementById('profileVisibility').value,
                            showStats: document.getElementById('showStats').checked,
                            allowMessages: document.getElementById('allowMessages').checked,
                            showOnline: document.getElementById('showOnline').checked
                        };
                        break;
                    case 'account':
                        const currentPassword = document.getElementById('currentPassword').value;
                        const newPassword = document.getElementById('newPassword').value;
                        const confirmPassword = document.getElementById('confirmPassword').value;
                        if (newPassword && newPassword !== confirmPassword) {
                            showToast('‚ùå Passwords do not match!', true);
                            return;
                        }
                        this.settings.account.email = document.getElementById('email').value;
                        if (newPassword) {
                            console.log('Changing password');
                            console.log('API Endpoint: POST /games/api/change-password/');
                            showToast('üîí Password changed successfully!');
                            document.getElementById('currentPassword').value = '';
                            document.getElementById('newPassword').value = '';
                            document.getElementById('confirmPassword').value = '';
                        }
                        break;
                }
                localStorage.setItem('lupiforge_settings', JSON.stringify(this.settings));
                console.log('Settings saved:', section, this.settings[section]);
                console.log('API Endpoint: POST /games/api/settings/', {section, data: this.settings[section]});
                showToast('‚úÖ Settings saved!');
            },

            deleteAccount() {
                console.log('Deleting account');
                console.log('API Endpoint: DELETE /games/api/account/');
                localStorage.clear();
                showToast('Account deleted. Redirecting...');
                setTimeout(() => {
                    window.location.href = '/logout/';
                }, 2000);
            }
        };

        // === AUTOSAVE MANAGER ===
        const AutosaveManager = {
            saveTimeout: null,
            indicator: null,

            init() {
                this.indicator = document.getElementById('autosaveIndicator');
                
                workspace.addChangeListener((event) => {
                    if (event.type === Blockly.Events.UI) return;
                    this.triggerAutosave();
                });

                document.getElementById('projectName').addEventListener('input', () => {
                    this.triggerAutosave();
                });
            },

            triggerAutosave() {
                clearTimeout(this.saveTimeout);
                this.showIndicator('saving');

                this.saveTimeout = setTimeout(() => {
                    this.performSave();
                }, 1000);
            },

            performSave() {
                const projectName = document.getElementById('projectName').value.trim() || 'Untitled Game';
                const xml = Blockly.Xml.workspaceToDom(workspace);
                const xmlText = Blockly.Xml.domToText(xml);
                const code = Blockly.JavaScript.workspaceToCode(workspace);

                const projectData = {
                    name: projectName,
                    xml: xmlText,
                    code: code,
                    timestamp: new Date().toISOString()
                };

                localStorage.setItem(STORAGE_KEY, JSON.stringify(projectData));
                this.showIndicator('saved');
                
                console.log('Autosaved:', projectData.name);

                setTimeout(() => this.hideIndicator(), 2000);
            },

            showIndicator(state) {
                this.indicator.className = `autosave-indicator show ${state}`;
                this.indicator.textContent = state === 'saving' ? 'üíæ Saving...' : '‚úì Saved';
            },

            hideIndicator() {
                this.indicator.classList.remove('show');
            }
        };

        // === DEBUG CONSOLE ===
        const DebugConsole = {
            output: null,
            isCollapsed: true,
            stateMonitor: null,
            watchedVars: [],

            init() {
                this.output = document.getElementById('debugOutput');
                
                const stateSection = document.createElement('div');
                stateSection.id = 'stateMonitor';
                stateSection.style.cssText = 'border-top: 1px solid #533483; padding: 10px; margin-top: 10px; display: none;';
                this.output.parentElement.insertBefore(stateSection, this.output.nextSibling);
                this.stateMonitor = stateSection;
                
                document.getElementById('toggleConsole').addEventListener('click', (e) => {
                    e.stopPropagation();
                    this.toggle();
                });
                
                document.getElementById('clearConsole').addEventListener('click', (e) => {
                    e.stopPropagation();
                    this.clear();
                });
                
                document.querySelector('.debug-header').addEventListener('click', () => {
                    this.toggle();
                });
            },

            toggle() {
                const console = document.getElementById('debugConsole');
                this.isCollapsed = !this.isCollapsed;
                console.classList.toggle('collapsed', this.isCollapsed);
                document.getElementById('toggleConsole').textContent = this.isCollapsed ? '‚ñ≤' : '‚ñº';
            },

            clear() {
                this.output.innerHTML = '';
                this.log('Console cleared');
            },

            log(message, type = 'log') {
                const timestamp = new Date().toLocaleTimeString();
                const entry = document.createElement('div');
                entry.className = `debug-${type}`;
                entry.innerHTML = `<span class="debug-timestamp">[${timestamp}]</span>${message}`;
                this.output.appendChild(entry);
                this.output.scrollTop = this.output.scrollHeight;
            },

            warn(message) {
                this.log(message, 'warn');
            },

            error(message) {
                this.log(message, 'error');
                if (this.isCollapsed) {
                    this.toggle();
                }
            },

            updateState(gameState) {
                if (!gameState) return;
                
                this.stateMonitor.style.display = 'block';
                
                const stateHTML = `
                    <div style="color: #4ec9b0; font-weight: bold; margin-bottom: 10px;">üìä LIVE STATE</div>
                    <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 10px; font-size: 11px;">
                        <div><span style="color: #dcdcaa;">Score:</span> <span style="color: white;">${gameState.score || 0}</span></div>
                        <div><span style="color: #dcdcaa;">Health:</span> <span style="color: white;">${gameState.health || 0}</span></div>
                        <div><span style="color: #dcdcaa;">Lives:</span> <span style="color: white;">${gameState.lives || 0}</span></div>
                        <div><span style="color: #dcdcaa;">Entities:</span> <span style="color: white;">${gameState.entities?.length || 0}</span></div>
                        <div><span style="color: #dcdcaa;">Camera X:</span> <span style="color: white;">${Math.round(gameState.camera?.x || 0)}</span></div>
                        <div><span style="color: #dcdcaa;">Camera Y:</span> <span style="color: white;">${Math.round(gameState.camera?.y || 0)}</span></div>
                    </div>
                    ${Object.keys(gameState).filter(k => !['score', 'health', 'lives', 'camera', 'entities'].includes(k)).length > 0 ? 
                        `<div style="margin-top: 10px; border-top: 1px solid #533483; padding-top: 10px;">
                            <div style="color: #dcdcaa; font-weight: bold; margin-bottom: 5px;">Custom Variables:</div>
                            ${Object.keys(gameState).filter(k => !['score', 'health', 'lives', 'camera', 'entities'].includes(k))
                                .map(key => `<div style="font-size: 11px;"><span style="color: #dcdcaa;">${key}:</span>
                                <span style="color: white;">${JSON.stringify(gameState[key])}</span></div>`)
                                .join('')}
                        </div>` : ''
                    }
                `;
                
                this.stateMonitor.innerHTML = stateHTML;
            },

            hideState() {
                this.stateMonitor.style.display = 'none';
            }
        };

        // === GAME RUNTIME CLASS ===
        class GameRuntime {
            constructor() {
                this.canvas = null;
                this.ctx = null;
                this.gameState = {
                    score: 0,
                    health: 100,
                    lives: 3,
                    camera: { x: 0, y: 0, targetX: 0, targetY: 0, smooth: 0.1 },
                    inventory: {},
                    buffs: {},
                    cooldowns: {},
                    zones: []
                };
                this.entities = [];
                this.background = null;
                this.keys = {};
                this.mouse = { x: 0, y: 0, clicked: false };
                this.eventHandlers = {
                    onStart: [],
                    onKeyPress: {},
                    onKeyRelease: {},
                    onMouseClick: [],
                    onCollision: [],
                    onTimer: [],
                    onSceneLoad: {},
                    onObjectDestroyed: {},
                    onScoreChange: [],
                    onAreaEnter: {},
                    onLevelComplete: []
                };
                this.userFunctions = {};
                this.delayedCalls = [];
                this.aiStates = new Map();
            }

            initialize(canvas, ctx, code) {
                this.canvas = canvas;
                this.ctx = ctx;
                this.resetState();
                this.setupInput();
                this.compileGameCode(code);
                this.triggerStartEvents();
            }

            resetState() {
                this.gameState = {
                    score: 0,
                    health: 100,
                    lives: 3,
                    camera: { x: 0, y: 0, targetX: 0, targetY: 0, smooth: 0.1 },
                    inventory: {},
                    buffs: {},
                    cooldowns: {},
                    zones: [],
                    entities: []
                };
                this.entities = [];
                this.keys = {};
                this.mouse = { x: 0, y: 0, clicked: false };
                this.delayedCalls = [];
                this.aiStates.clear();
            }

            setupInput() {
                this.canvas.addEventListener('mousemove', (e) => {
                    const rect = this.canvas.getBoundingClientRect();
                    this.mouse.x = e.clientX - rect.left;
                    this.mouse.y = e.clientY - rect.top;
                });

                this.canvas.addEventListener('click', (e) => {
                    this.mouse.clicked = true;
                    this.triggerMouseClick();
                    setTimeout(() => this.mouse.clicked = false, 100);
                });

                window.addEventListener('keydown', (e) => {
                    if (!this.keys[e.key]) {
                        this.keys[e.key] = true;
                        this.triggerKeyEvents(e.key, 'press');
                    }
                });

                window.addEventListener('keyup', (e) => {
                    this.keys[e.key] = false;
                    this.triggerKeyEvents(e.key, 'release');
                });
            }

            setBackground(imageData) {
                const img = new Image();
                img.onload = () => {
                    this.background = img;
                };
                img.src = imageData;
            }

            compileGameCode(code) {
                const sandbox = {
                    onGameStart: (fn) => this.eventHandlers.onStart.push(fn),
                    onSceneLoad: (scene, fn) => {
                        if (!this.eventHandlers.onSceneLoad[scene]) this.eventHandlers.onSceneLoad[scene] = [];
                        this.eventHandlers.onSceneLoad[scene].push(fn);
                    },
                    onKeyPress: (key, fn) => {
                        if (!this.eventHandlers.onKeyPress[key]) this.eventHandlers.onKeyPress[key] = [];
                        this.eventHandlers.onKeyPress[key].push(fn);
                    },
                    onMouseClick: (fn) => this.eventHandlers.onMouseClick.push(fn),
                    onCollision: (obj1, obj2, fn) => this.eventHandlers.onCollision.push({ obj1, obj2, fn }),
                    onCollisionTagged: (tag1, tag2, fn) => this.eventHandlers.onCollision.push({ tag1, tag2, fn, usesTags: true }),
                    onObjectDestroyed: (tag, fn) => {
                        if (!this.eventHandlers.onObjectDestroyed[tag]) this.eventHandlers.onObjectDestroyed[tag] = [];
                        this.eventHandlers.onObjectDestroyed[tag].push(fn);
                    },
                    onScoreChange: (type, fn) => this.eventHandlers.onScoreChange.push({ type, fn }),
                    onAreaEnter: (zone, fn) => {
                        if (!this.eventHandlers.onAreaEnter[zone]) this.eventHandlers.onAreaEnter[zone] = [];
                        this.eventHandlers.onAreaEnter[zone].push(fn);
                    },
                    onLevelComplete: (fn) => this.eventHandlers.onLevelComplete.push(fn),
                    everySeconds: (seconds, fn) => this.eventHandlers.onTimer.push({ interval: seconds * 1000, lastTrigger: 0, fn }),
                    
                    movePlayer: (dir, amt) => this.movePlayer(dir, amt),
                    setVelocity: (axis, val) => this.setVelocity(axis, val),
                    applyGravity: (force) => this.applyGravity(force),
                    applyFriction: (amt) => this.applyFriction(amt),
                    jumpBuffered: (force, buffer) => this.jumpBuffered(force, buffer),
                    dash: (dir, dist) => this.dash(dir, dist),
                    knockback: (force, angle) => this.knockback(force, angle),
                    moveAlongPath: (obj, path, speed) => this.moveAlongPath(obj, path, speed),
                    findPathTo: (target) => this.findPathTo(target),
                    
                    aiPatrol: (x1, x2) => this.aiPatrol(x1, x2),
                    aiChase: (target, speed) => this.aiChase(target, speed),
                    aiFlee: (target, speed) => this.aiFlee(target, speed),
                    
                    spawnSprite: (type, x, y) => this.spawnSprite(type, x, y),
                    destroySprite: (target) => this.destroySprite(target),
                    
                    inventoryAdd: (item, qty) => this.inventoryAdd(item, qty),
                    inventoryRemove: (item, qty) => this.inventoryRemove(item, qty),
                    inventoryHas: (item) => this.inventoryHas(item),
                    
                    applyPowerup: (type, dur) => this.applyPowerup(type, dur),
                    applyDebuff: (type, dur) => this.applyDebuff(type, dur),
                    hasBuff: (buff) => this.hasBuff(buff),
                    createPickup: (type, x, y) => this.createPickup(type, x, y),
                    
                    cameraFollow: (target, smooth) => this.cameraFollow(target, smooth),
                    cameraClamp: (minX, maxX) => this.cameraClamp(minX, maxX),
                    
                    setHealth: (val) => this.gameState.health = val,
                    addHealth: (amt) => this.gameState.health = Math.max(0, this.gameState.health + amt),
                    setLives: (val) => this.gameState.lives = val,
                    addScore: (pts) => {
                        const oldScore = this.gameState.score;
                        this.gameState.score += pts;
                        this.triggerScoreChange(pts > 0 ? 'increase' : 'decrease');
                    },
                    
                    delay: (seconds, fn) => this.delay(seconds, fn),
                    cooldown: (name, duration, fn) => this.cooldown(name, duration, fn),
                    randomInt: (min, max) => Math.floor(Math.random() * (max - min + 1)) + min,
                    weightedRandom: (weights) => {
                        const total = weights.reduce((a, b) => a + b, 0);
                        let random = Math.random() * total;
                        for (let i = 0; i < weights.length; i++) {
                            if (random < weights[i]) return i;
                            random -= weights[i];
                        }
                        return weights.length - 1;
                    },
                    
                    saveGameState: () => this.saveGameState(),
                    loadGameState: () => this.loadGameState(),
                    
                    gameState: this.gameState
                };

                try {
                    const fn = new Function(...Object.keys(sandbox), code);
                    fn(...Object.values(sandbox));
                    DebugConsole.log('‚úÖ Game code compiled successfully');
                } catch (error) {
                    DebugConsole.error('‚ùå Compilation Error: ' + error.message);
                    throw error;
                }
            }

            triggerStartEvents() {
                this.eventHandlers.onStart.forEach(fn => {
                    try {
                        fn();
                    } catch (error) {
                        DebugConsole.error('Start Event Error: ' + error.message);
                    }
                });
            }

            triggerKeyEvents(key, type) {
                const keyMap = {
                    'ArrowUp': 'UP',
                    'ArrowDown': 'DOWN',
                    'ArrowLeft': 'LEFT',
                    'ArrowRight': 'RIGHT',
                    ' ': 'SPACE'
                };
                const mappedKey = keyMap[key] || key.toUpperCase();
                
                const handlers = type === 'press' ? this.eventHandlers.onKeyPress : this.eventHandlers.onKeyRelease;
                if (handlers && handlers[mappedKey]) {
                    handlers[mappedKey].forEach(fn => {
                        try {
                            fn();
                        } catch (error) {
                            DebugConsole.error(`Key ${type} error: ${error.message}`);
                        }
                    });
                }
            }

            triggerMouseClick() {
                this.eventHandlers.onMouseClick.forEach(fn => {
                    try {
                        fn();
                    } catch (error) {
                        DebugConsole.error('Mouse click error: ' + error.message);
                    }
                });
            }

            triggerScoreChange(type) {
                this.eventHandlers.onScoreChange
                    .filter(h => h.type === type)
                    .forEach(h => {
                        try {
                            h.fn();
                        } catch (error) {
                            DebugConsole.error('Score change error: ' + error.message);
                        }
                    });
            }

            update(deltaTime) {
                const now = Date.now();
                
                this.eventHandlers.onTimer.forEach(timer => {
                    if (now - timer.lastTrigger >= timer.interval) {
                        timer.lastTrigger = now;
                        try {
                            timer.fn();
                        } catch (error) {
                            DebugConsole.error('Timer error: ' + error.message);
                        }
                    }
                });

                this.delayedCalls = this.delayedCalls.filter(call => {
                    if (now >= call.time) {
                        try {
                            call.fn();
                        } catch (error) {
                            DebugConsole.error('Delayed call error: ' + error.message);
                        }
                        return false;
                    }
                    return true;
                });

                Object.keys(this.gameState.buffs).forEach(buff => {
                    if (this.gameState.buffs[buff] < now) {
                        delete this.gameState.buffs[buff];
                    }
                });

                const cam = this.gameState.camera;
                cam.x += (cam.targetX - cam.x) * cam.smooth;
                cam.y += (cam.targetY - cam.y) * cam.smooth;

                DebugConsole.updateState(this.gameState);
            }

            render() {
                this.ctx.fillStyle = '#000';
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

                if (this.background) {
                    this.ctx.drawImage(this.background, 0, 0, this.canvas.width, this.canvas.height);
                }

                this.ctx.save();
                this.ctx.translate(-this.gameState.camera.x, -this.gameState.camera.y);

                this.entities.forEach(entity => {
                    if (entity.currentAnimationFrame) {
                        const anim = entity.currentAnimationFrame.animation;
                        const frameIdx = entity.currentAnimationFrame.frameIndex;
                        const spriteImage = entity.currentAnimationFrame.spriteImage;
                        
                        if (spriteImage && spriteImage.complete && spriteImage.naturalWidth > 0) {
                            const frameCol = frameIdx % anim.framesPerRow;
                            const frameRow = Math.floor(frameIdx / anim.framesPerRow);
                            const srcX = Math.round(frameCol * anim.frameWidth);
                            const srcY = Math.round(frameRow * anim.frameHeight);
                            
                            const offset = (anim.frameOffsets && anim.frameOffsets[frameIdx]) || { centerX: anim.frameWidth / 2, bottomY: anim.frameHeight };
                            
                            const drawX = Math.round(entity.x - offset.centerX);
                            const drawY = Math.round(entity.y - offset.bottomY);
                            
                            try {
                                this.ctx.drawImage(
                                    spriteImage,
                                    srcX, srcY, anim.frameWidth, anim.frameHeight,
                                    drawX, drawY, anim.frameWidth, anim.frameHeight
                                );
                            } catch (e) {
                                console.warn(`Animation render error: ${e.message}`);
                                this.ctx.fillStyle = entity.color || '#27ae60';
                                this.ctx.fillRect(entity.x, entity.y, entity.width, entity.height);
                            }
                        } else {
                            this.ctx.fillStyle = entity.color || '#27ae60';
                            this.ctx.fillRect(entity.x, entity.y, entity.width, entity.height);
                        }
                    } else if (entity.sprite) {
                        this.ctx.drawImage(entity.sprite, entity.x, entity.y, entity.width, entity.height);
                    } else {
                        this.ctx.fillStyle = entity.color || '#27ae60';
                        this.ctx.fillRect(entity.x, entity.y, entity.width, entity.height);
                    }
                    
                    if (window.debugOverlays && window.debugOverlays.enabled) {
                        this.ctx.strokeStyle = '#ffff00';
                        this.ctx.strokeRect(entity.x, entity.y, entity.width, entity.height);
                        this.ctx.fillStyle = '#ffff00';
                        this.ctx.font = '10px monospace';
                        this.ctx.fillText(entity.type, entity.x, entity.y - 5);
                    }
                });

                this.ctx.restore();

                if (window.debugOverlays && window.debugOverlays.enabled) {
                    this.renderDebugOverlays();
                }
            }

            renderDebugOverlays() {
                this.ctx.fillStyle = 'rgba(255, 255, 0, 0.8)';
                this.ctx.font = '12px monospace';
                this.ctx.fillText(`Entities: ${this.entities.length}`, 10, 20);
                this.ctx.fillText(`Health: ${this.gameState.health}`, 10, 35);
                this.ctx.fillText(`Score: ${this.gameState.score}`, 10, 50);
                this.ctx.fillText(`Buffs: ${Object.keys(this.gameState.buffs).length}`, 10, 65);
            }

            movePlayer(dir, amt) {
                const player = this.entities.find(e => e.tags && e.tags.includes('player'));
                if (!player) return;
                
                const movement = {
                    'UP': { x: 0, y: -amt },
                    'DOWN': { x: 0, y: amt },
                    'LEFT': { x: -amt, y: 0 },
                    'RIGHT': { x: amt, y: 0 }
                };
                
                if (movement[dir]) {
                    player.x += movement[dir].x;
                    player.y += movement[dir].y;
                }
            }

            jumpBuffered(force, buffer) {
                DebugConsole.log(`Jump buffered: force=${force}, buffer=${buffer}s`);
            }

            dash(dir, dist) {
                DebugConsole.log(`Dash ${dir} distance=${dist}`);
            }

            knockback(force, angle) {
                DebugConsole.log(`Knockback: force=${force}, angle=${angle}¬∞`);
            }

            moveAlongPath(obj, path, speed) {
                DebugConsole.log(`Move ${obj} along ${path} at speed ${speed}`);
            }

            findPathTo(target) {
                DebugConsole.log(`Pathfinding to ${target}`);
            }

            aiPatrol(x1, x2) {
                const entity = this.entities[this.entities.length - 1];
                if (!entity) return;
                
                if (!this.aiStates.has(entity.id)) {
                    this.aiStates.set(entity.id, { patrolDir: 1, x1, x2 });
                }
                
                const state = this.aiStates.get(entity.id);
                entity.x += state.patrolDir * 2;
                
                if (entity.x >= x2) state.patrolDir = -1;
                if (entity.x <= x1) state.patrolDir = 1;
            }

            aiChase(target, speed) {
                const entity = this.entities[this.entities.length - 1];
                const targetEntity = this.entities.find(e => e.tags && e.tags.includes(target));
                
                if (!entity || !targetEntity) return;
                
                const dx = targetEntity.x - entity.x;
                const dy = targetEntity.y - entity.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                
                if (dist > 0) {
                    entity.x += (dx / dist) * speed * 0.016;
                    entity.y += (dy / dist) * speed * 0.016;
                }
            }

            aiFlee(target, speed) {
                const entity = this.entities[this.entities.length - 1];
                const targetEntity = this.entities.find(e => e.tags && e.tags.includes(target));
                
                if (!entity || !targetEntity) return;
                
                const dx = entity.x - targetEntity.x;
                const dy = entity.y - targetEntity.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                
                if (dist > 0) {
                    entity.x += (dx / dist) * speed * 0.016;
                    entity.y += (dy / dist) * speed * 0.016;
                }
            }

            inventoryAdd(item, qty) {
                this.gameState.inventory[item] = (this.gameState.inventory[item] || 0) + qty;
                DebugConsole.log(`Added ${qty}x ${item} to inventory`);
            }

            inventoryRemove(item, qty) {
                if (this.gameState.inventory[item]) {
                    this.gameState.inventory[item] = Math.max(0, this.gameState.inventory[item] - qty);
                    DebugConsole.log(`Removed ${qty}x ${item} from inventory`);
                }
            }

            inventoryHas(item) {
                return (this.gameState.inventory[item] || 0) > 0;
            }

            applyPowerup(type, duration) {
                this.gameState.buffs[type] = Date.now() + (duration * 1000);
                DebugConsole.log(`Applied powerup: ${type} for ${duration}s`);
            }

            applyDebuff(type, duration) {
                this.gameState.buffs[`debuff_${type}`] = Date.now() + (duration * 1000);
                DebugConsole.log(`Applied debuff: ${type} for ${duration}s`);
            }

            hasBuff(buff) {
                return this.gameState.buffs[buff] && this.gameState.buffs[buff] > Date.now();
            }

            createPickup(type, x, y) {
                this.spawnSprite(type, x, y);
                DebugConsole.log(`Created pickup: ${type} at (${x}, ${y})`);
            }

            delay(seconds, fn) {
                this.delayedCalls.push({
                    time: Date.now() + (seconds * 1000),
                    fn
                });
            }

            cooldown(name, duration, fn) {
                const now = Date.now();
                const cooldownEnd = this.gameState.cooldowns[name] || 0;
                
                if (now >= cooldownEnd) {
                    this.gameState.cooldowns[name] = now + (duration * 1000);
                    try {
                        fn();
                    } catch (error) {
                        DebugConsole.error(`Cooldown '${name}' error: ${error.message}`);
                    }
                }
            }

            spawnSprite(type, x, y) {
                const entity = {
                    id: Date.now() + Math.random(),
                    type,
                    x,
                    y,
                    width: 32,
                    height: 32,
                    tags: [type]
                };
                
                const animation = Object.values(AssetManager.assets.animations || []).find(a => a.name === type);
                if (animation) {
                    if (!gameAnimationRuntime.spriteSheetCache.has(animation.id)) {
                        const img = new Image();
                        img.src = animation.spriteSheet;
                        gameAnimationRuntime.spriteSheetCache.set(animation.id, img);
                    }
                    
                    entity.currentAnimationFrame = {
                        animation: animation,
                        frameIndex: 0,
                        spriteImage: gameAnimationRuntime.spriteSheetCache.get(animation.id)
                    };
                    entity.width = animation.frameWidth;
                    entity.height = animation.frameHeight;
                }
                
                this.entities.push(entity);
                this.gameState.entities = this.entities;
                DebugConsole.log(`Spawned ${type} at (${x}, ${y})`);
            }

            destroySprite(target) {
                const before = this.entities.length;
                
                if (target === 'THIS') {
                    this.entities.pop();
                } else if (target.startsWith('ALL_')) {
                    const tag = target.replace('ALL_', '').toLowerCase();
                    this.entities = this.entities.filter(e => !e.tags || !e.tags.includes(tag));
                } else {
                    this.entities = this.entities.filter(e => e.type !== target);
                }
                
                this.gameState.entities = this.entities;
                DebugConsole.log(`Destroyed ${before - this.entities.length} entities`);
            }

            saveGameState() {
                const saveData = {
                    score: this.gameState.score,
                    health: this.gameState.health,
                    lives: this.gameState.lives,
                    inventory: this.gameState.inventory,
                    timestamp: Date.now()
                };
                localStorage.setItem('lupiforge_gamesave', JSON.stringify(saveData));
                DebugConsole.log('Game state saved');
            }

            loadGameState() {
                const saved = localStorage.getItem('lupiforge_gamesave');
                if (saved) {
                    const saveData = JSON.parse(saved);
                    this.gameState.score = saveData.score;
                    this.gameState.health = saveData.health;
                    this.gameState.lives = saveData.lives;
                    this.gameState.inventory = saveData.inventory;
                    DebugConsole.log('Game state loaded');
                }
            }

            cameraFollow(target, smooth) {
                this.gameState.camera.smooth = smooth;
                const targetEntity = this.entities.find(e => e.tags && e.tags.includes(target));
                if (targetEntity) {
                    this.gameState.camera.targetX = targetEntity.x - this.canvas.width / 2;
                    this.gameState.camera.targetY = targetEntity.y - this.canvas.height / 2;
                }
            }

            cameraClamp(minX, maxX) {
                this.gameState.camera.x = Math.max(minX, Math.min(maxX, this.gameState.camera.x));
            }

            setVelocity(axis, val) {
                DebugConsole.log(`Set ${axis} velocity to ${val}`);
            }

            applyGravity(force) {
                DebugConsole.log(`Applied gravity force: ${force}`);
            }

            applyFriction(amt) {
                DebugConsole.log(`Applied friction: ${amt}`);
            }

            getScore() {
                return this.gameState.score;
            }

            stop() {
                DebugConsole.log('Game runtime stopped');
                DebugConsole.hideState();
            }
        }

        document.addEventListener('DOMContentLoaded', function() {
            document.getElementById('previewSVG').addEventListener('click', () => {
                const svg = document.getElementById('previewSVG');
                const canvas = document.getElementById('debugGameCanvas');
                if (canvas.style.display === 'none') {
                    svg.style.display = 'none';
                    canvas.style.display = 'block';
                } else {
                    svg.style.display = 'block';
                    canvas.style.display = 'none';
                }
            });
        });

        document.addEventListener('DOMContentLoaded', function() {
            console.log('üöÄ Initializing LupiForge Complete Editor...');
            
            // Check if a game_id is provided in the URL (from dashboard click)
            const urlParams = new URLSearchParams(window.location.search);
            const gameId = urlParams.get('game_id');
            
            if (gameId) {
                console.log('üìÇ Loading game with ID:', gameId);
                // Fetch the game data from the backend
                fetch('/games/api/user/games/', {credentials: 'same-origin'})
                    .then(resp => {
                        if (!resp.ok) throw new Error('Failed to fetch games');
                        return resp.json();
                    })
                    .then(data => {
                        const game = (data.games || []).find(g => g.id === gameId);
                        if (game && game.title) {
                            document.getElementById('projectName').value = game.title;
                        }
                    })
                    .catch(err => console.warn('Could not load game data:', err));
            }
            
            workspace = Blockly.inject('blocklyDiv', {
                toolbox: document.getElementById('toolbox'),
                scrollbars: true,
                trashcan: true,
                zoom: {
                    controls: true,
                    wheel: true,
                    startScale: 1.0,
                    maxScale: 3,
                    minScale: 0.3,
                    scaleSpeed: 1.2
                },
                grid: {
                    spacing: 20,
                    length: 3,
                    colour: '#ccc',
                    snap: true
                },
                move: {
                    scrollbars: true,
                    drag: true,
                    wheel: true
                }
            });

            console.log('‚úÖ Blockly workspace initialized successfully');

            // Load saved project
            loadProject();

            // If no saved project, add starter block
            if (workspace.getAllBlocks(false).length === 0) {
                const xml = Blockly.utils.xml.textToDom(
                    '<xml><block type="on_game_start" x="50" y="50"></block></xml>'
                );
                Blockly.Xml.domToWorkspace(xml, workspace);
                // If project name is empty, set a helpful default based on the logged-in user
                try{
                    const pn = document.getElementById('projectName');
                    if (pn && !pn.value) {
                        const me = window.LUPIFORGE_CURRENT_USER || {};
                        if (me && me.username) pn.value = `${me.username}'s Game`;
                        else pn.value = 'My Game';
                    }
                }catch(e){/* ignore */}
            }

            // Button event listeners
            document.getElementById('saveBtn').addEventListener('click', saveProject);
            document.getElementById('clearBtn').addEventListener('click', clearProject);
            document.getElementById('quickPreviewBtn').addEventListener('click', () => PreviewManager.play());
            document.getElementById('publishBtn').addEventListener('click', preparePublish);
            
            document.getElementById('exportBtn').addEventListener('click', function() {
                const code = Blockly.JavaScript.workspaceToCode(workspace);
                const output = document.getElementById('output');
                output.textContent = code || '// No blocks in workspace';
                output.classList.add('show');
                console.log('Generated code:', code);
            });

            // Modal controls
            document.getElementById('cancelPublish').addEventListener('click', function() {
                document.getElementById('publishModal').classList.remove('show');
            });
            
            document.getElementById('confirmPublish').addEventListener('click', publishGame);

            // Auto-save every 30 seconds
            setInterval(function() {
                if (workspace.getAllBlocks(false).length > 0) {
                    saveProject();
                }
            }, 30000);

            // Save on workspace change (debounced)
            let saveTimeout;
            workspace.addChangeListener(function() {
                clearTimeout(saveTimeout);
                saveTimeout = setTimeout(saveProject, 2000);
            });

            // Initialize all feature systems
            console.log('üì¶ Initializing all feature systems...');
            
            console.log('üì¶ Initializing Asset Manager...');
            AssetManager.init();
            AssetTagSystem.init();
            
            console.log('üéÆ Initializing Preview Manager...');
            PreviewManager.init();
            
            console.log('üíæ Initializing Autosave System...');
            AutosaveManager.init();
            
            console.log('üñ•Ô∏è Initializing Debug Console...');
            DebugConsole.init();
            
            console.log('üèÜ Initializing Achievement System...');
            AchievementManager.load();
            
            console.log('üéØ Initializing Score Manager...');
            ScoreManager.init();
            
            console.log('üîî Initializing Notifications...');
            NotificationManager.init();
            
            console.log('üìä Initializing Leaderboard...');
            LeaderboardManager.init();
            
            console.log('üìà Initializing Dashboard...');
            DashboardManager.init();
            
            console.log('üõ°Ô∏è Initializing Moderation...');
            ModerationManager.init();
            
            console.log('‚öôÔ∏è Initializing Settings...');
            SettingsManager.init();

            console.log('‚úÖ ALL SYSTEMS OPERATIONAL!');
            console.log('üìã Features Available:');
            console.log('  - ‚úÖ Blockly Editor with 20+ custom blocks (movement, camera, state, health, collision)');
            console.log('  - ‚úÖ Asset Manager (upload sprites/sounds/backgrounds with preview)');
            console.log('  - ‚úÖ Game Preview Panel with GameRuntime engine');
            console.log('  - ‚úÖ Real-time Autosave with visual indicator');
            console.log('  - ‚úÖ Debug Console with error tracking');
            console.log('  - ‚úÖ Debug Overlays (bounding boxes, entity count)');
            console.log('  - ‚úÖ Save & Publish to Moderation');
            console.log('  - ‚úÖ Achievement System');
            console.log('  - ‚úÖ Score Submission');
            console.log('  - ‚úÖ Global Leaderboard');
            console.log('  - ‚úÖ Social Features (Follow/Remix)');
            console.log('  - ‚úÖ Creator Dashboard with Analytics');
            console.log('  - ‚úÖ Moderation Queue (Moderators only)');
            console.log('  - ‚úÖ Multiplayer Lobby');
            console.log('  - ‚úÖ Profile & Settings');
            console.log('  - ‚úÖ Notification System');
        });

        // Asset Manager Functions
        const AssetManager = {
            assets: {
                sprites: [],
                sounds: [],
                backgrounds: [],
                animations: []
            },
            currentType: 'sprites',
            backgroundAsset: null,

            init() {
                this.loadAssets();
                this.attachEvents();
                this.render();
                this.attachAnimationUpload();
            },

            loadAssets() {
                const saved = localStorage.getItem('lupiforge_assets');
                if (saved) {
                    const data = JSON.parse(saved);
                    this.assets = {
                        sprites: (data.assets && data.assets.sprites) || [],
                        sounds: (data.assets && data.assets.sounds) || [],
                        backgrounds: (data.assets && data.assets.backgrounds) || [],
                        animations: (data.assets && data.assets.animations) || []
                    };
                    this.backgroundAsset = data.backgroundAsset || null;
                }
            },

            saveAssets() {
                const assetsCopy = {
                    sprites: this.assets.sprites,
                    sounds: this.assets.sounds,
                    backgrounds: this.assets.backgrounds,
                    animations: this.assets.animations.map(anim => ({
                        ...anim,
                        spriteSheet: null
                    }))
                };
                
                try {
                    localStorage.setItem('lupiforge_assets', JSON.stringify({
                        assets: assetsCopy,
                        backgroundAsset: this.backgroundAsset
                    }));
                } catch (e) {
                    console.warn('Asset save to localStorage failed, using IndexedDB:', e.message);
                    this.saveAssetsToIndexedDB();
                }
                
                this.saveSpriteSheetsToDB();
            },
            
            saveAssetsToIndexedDB() {
                const request = indexedDB.open('lupiforge_db', 1);
                request.onupgradeneeded = (e) => {
                    const db = e.target.result;
                    if (!db.objectStoreNames.contains('assets')) {
                        db.createObjectStore('assets', { keyPath: 'id' });
                    }
                };
                request.onsuccess = (e) => {
                    const db = e.target.result;
                    const store = db.transaction('assets', 'readwrite').objectStore('assets');
                    store.put({ id: 'all', data: this.assets });
                };
            },
            
            saveSpriteSheetsToDB() {
                const request = indexedDB.open('lupiforge_db', 1);
                request.onupgradeneeded = (e) => {
                    const db = e.target.result;
                    if (!db.objectStoreNames.contains('spriteSheets')) {
                        db.createObjectStore('spriteSheets', { keyPath: 'id' });
                    }
                };
                request.onsuccess = (e) => {
                    const db = e.target.result;
                    const store = db.transaction('spriteSheets', 'readwrite').objectStore('spriteSheets');
                    this.assets.animations.forEach(anim => {
                        store.put({ id: anim.id, spriteSheet: anim.spriteSheet });
                    });
                };
            },
            
            loadSpriteSheetFromDB(animationId) {
                return new Promise((resolve) => {
                    const request = indexedDB.open('lupiforge_db', 1);
                    request.onsuccess = (e) => {
                        const db = e.target.result;
                        const store = db.transaction('spriteSheets', 'readonly').objectStore('spriteSheets');
                        const getRequest = store.get(animationId);
                        getRequest.onsuccess = () => {
                            resolve(getRequest.result ? getRequest.result.spriteSheet : null);
                        };
                    };
                });
            },

            attachAnimationUpload() {
                const input = document.getElementById('animationUpload');
                if (input) {
                    input.addEventListener('change', (e) => {
                        this.handleAnimationUpload(e.target.files[0]);
                        e.target.value = '';
                    });
                }
            },

            handleAnimationUpload(file) {
                if (!file) return;
                
                const reader = new FileReader();
                reader.onload = (e) => {
                    const img = new Image();
                    img.onload = () => {
                        this.showSpriteSheetConfig(file.name, e.target.result, img.width, img.height);
                    };
                    img.src = e.target.result;
                };
                reader.readAsDataURL(file);
            },

            showSpriteSheetConfig(filename, dataUrl, imgWidth, imgHeight) {
                const modal = document.createElement('div');
                modal.className = 'modal show';
                modal.style.zIndex = '10000';
                
                const scale = Math.min(400 / imgWidth, 400 / imgHeight);
                const displayWidth = imgWidth * scale;
                const displayHeight = imgHeight * scale;
                
                modal.innerHTML = `
                    <div class="modal-content" style="max-width: 900px; max-height: 90vh; overflow-y: auto;">
                        <h2>üé¨ Configure Sprite Sheet: ${filename}</h2>
                        
                        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin: 20px 0;">
                            <div>
                                <h4 style="color: #ccc; margin-bottom: 10px;">üìç Crop Animation Region</h4>
                                <p style="color: #aaa; font-size: 11px; margin-bottom: 10px;">Click and drag on the image to select crop area</p>
                                
                                <div style="position: relative; display: inline-block; background: #0f3460; padding: 5px; border-radius: 4px;">
                                    <canvas id="cropCanvas" style="border: 2px solid #533483; cursor: crosshair; display: block; background: white;"></canvas>
                                </div>
                                
                                <div style="margin-top: 10px; color: #ccc; font-size: 12px;">
                                    <p>Crop: <span id="cropInfo" style="color: #27ae60;">Select area</span></p>
                                </div>
                                
                                <div style="margin-top: 10px; display: flex; gap: 8px;">
                                    <button id="resetCropBtn" style="flex: 1; padding: 8px; background: #533483; color: white; border: none; border-radius: 4px; cursor: pointer;">Reset</button>
                                    <button id="useCropBtn" style="flex: 1; padding: 8px; background: #27ae60; color: white; border: none; border-radius: 4px; cursor: pointer;">Use Crop</button>
                                </div>
                                
                                <div id="cropPreview" style="margin-top: 10px; display: none;">
                                    <p style="color: #ccc; font-size: 11px; margin-bottom: 5px;">Preview:</p>
                                    <canvas id="previewCanvas" style="border: 1px solid #533483; border-radius: 4px; max-width: 100%; display: block; background: white;"></canvas>
                                </div>
                            </div>
                            
                            <div>
                                <h4 style="color: #ccc; margin-bottom: 10px;">‚öôÔ∏è Frame Configuration</h4>
                                
                                <label style="display: block; margin-bottom: 15px; color: #ccc;">
                                    <div style="font-size: 12px; margin-bottom: 5px;">Animation Name</div>
                                    <input type="text" id="animName" placeholder="e.g., walk, jump, idle" style="width: 100%; padding: 8px; border: 1px solid #533483; border-radius: 4px; background: #0f3460; color: white; box-sizing: border-box;" autocomplete="off">
                                    <small style="color: #aaa; font-size: 10px; margin-top: 3px; display: block;">Letters, numbers, spaces, and underscores</small>
                                </label>
                                
                                <label style="display: block; margin-bottom: 15px; color: #ccc;">
                                    <div style="font-size: 12px; margin-bottom: 5px;">Frames Per Row</div>
                                    <input type="number" id="framesPerRow" value="4" min="1" style="width: 100%; padding: 8px; border: 1px solid #533483; border-radius: 4px; background: #0f3460; color: white; box-sizing: border-box;">
                                </label>
                                
                                <label style="display: block; margin-bottom: 15px; color: #ccc;">
                                    <div style="font-size: 12px; margin-bottom: 5px;">Total Frames</div>
                                    <input type="number" id="totalFrames" value="8" min="1" style="width: 100%; padding: 8px; border: 1px solid #533483; border-radius: 4px; background: #0f3460; color: white; box-sizing: border-box;">
                                </label>
                                
                                <label style="display: block; margin-bottom: 15px; color: #ccc;">
                                    <div style="font-size: 12px; margin-bottom: 5px;">Frame Duration (ms)</div>
                                    <input type="number" id="frameDuration" value="100" min="10" step="10" style="width: 100%; padding: 8px; border: 1px solid #533483; border-radius: 4px; background: #0f3460; color: white; box-sizing: border-box;">
                                </label>
                                
                                <label style="display: flex; align-items: center; gap: 10px; color: #ccc; margin-bottom: 15px;">
                                    <input type="checkbox" id="autoTag">
                                    <span style="font-size: 12px;">Tag entities with animation name</span>
                                </label>
                                
                                <div style="padding: 10px; background: #0f3460; border-radius: 4px; border-left: 3px solid #533483;">
                                    <p style="color: #aaa; font-size: 11px; margin: 0;">üí° Tip: Use the crop tool to select just the animation row you want (e.g., WALK row).</p>
                                </div>
                            </div>
                        </div>
                        
                        <div class="modal-buttons">
                            <button onclick="this.closest('.modal').remove()" style="background: #95a5a6;">Cancel</button>
                            <button id="createAnimBtn" style="background: #27ae60; cursor: pointer;">Create Animation</button>
                        </div>
                    </div>
                `;
                
                document.body.appendChild(modal);
                
                const cropCanvas = modal.querySelector('#cropCanvas');
                const previewCanvas = modal.querySelector('#previewCanvas');
                const ctx = cropCanvas.getContext('2d');
                const previewCtx = previewCanvas.getContext('2d');
                
                let img = new Image();
                img.onload = () => {
                    cropCanvas.width = displayWidth;
                    cropCanvas.height = displayHeight;
                    ctx.drawImage(img, 0, 0, displayWidth, displayHeight);
                };
                img.src = dataUrl;
                
                let cropRect = { x: 0, y: 0, w: displayWidth, h: displayHeight / 4, isDragging: false, resizeHandle: null };
                
                const drawCropOverlay = () => {
                    ctx.drawImage(img, 0, 0, displayWidth, displayHeight);
                    ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
                    ctx.fillRect(0, 0, displayWidth, cropRect.y);
                    ctx.fillRect(0, cropRect.y + cropRect.h, displayWidth, displayHeight - (cropRect.y + cropRect.h));
                    ctx.fillRect(0, cropRect.y, cropRect.x, cropRect.h);
                    ctx.fillRect(cropRect.x + cropRect.w, cropRect.y, displayWidth - (cropRect.x + cropRect.w), cropRect.h);
                    
                    ctx.strokeStyle = '#27ae60';
                    ctx.lineWidth = 2;
                    ctx.strokeRect(cropRect.x, cropRect.y, cropRect.w, cropRect.h);
                    
                    ctx.fillStyle = '#27ae60';
                    const handles = [
                        {x: cropRect.x - 5, y: cropRect.y - 5, id: 'tl'},
                        {x: cropRect.x + cropRect.w - 5, y: cropRect.y - 5, id: 'tr'},
                        {x: cropRect.x - 5, y: cropRect.y + cropRect.h - 5, id: 'bl'},
                        {x: cropRect.x + cropRect.w - 5, y: cropRect.y + cropRect.h - 5, id: 'br'}
                    ];
                    handles.forEach(h => ctx.fillRect(h.x, h.y, 10, 10));
                    
                    const cropW = (cropRect.w / displayWidth) * imgWidth;
                    const cropH = (cropRect.h / displayHeight) * imgHeight;
                    modal.querySelector('#cropInfo').textContent = `${Math.round(cropW)} √ó ${Math.round(cropH)}px`;
                };
                
                cropCanvas.addEventListener('mousedown', (e) => {
                    const rect = cropCanvas.getBoundingClientRect();
                    const x = e.clientX - rect.left;
                    const y = e.clientY - rect.top;
                    
                    cropRect.isDragging = true;
                    cropRect.startX = x;
                    cropRect.startY = y;
                });
                
                cropCanvas.addEventListener('mousemove', (e) => {
                    if (!cropRect.isDragging) return;
                    
                    const rect = cropCanvas.getBoundingClientRect();
                    const x = e.clientX - rect.left;
                    const y = e.clientY - rect.top;
                    
                    cropRect.x = Math.max(0, Math.min(x, cropRect.startX));
                    cropRect.y = Math.max(0, Math.min(y, cropRect.startY));
                    cropRect.w = Math.abs(x - cropRect.startX);
                    cropRect.h = Math.abs(y - cropRect.startY);
                    
                    drawCropOverlay();
                });
                
                cropCanvas.addEventListener('mouseup', () => {
                    cropRect.isDragging = false;
                });
                
                drawCropOverlay();
                
                let croppedDataUrl = null;
                let croppedWidth = imgWidth;
                let croppedHeight = imgHeight;
                
                modal.querySelector('#resetCropBtn').addEventListener('click', () => {
                    cropRect = { x: 0, y: 0, w: displayWidth, h: displayHeight / 4, isDragging: false };
                    croppedDataUrl = null;
                    modal.querySelector('#cropPreview').style.display = 'none';
                    drawCropOverlay();
                });
                
                modal.querySelector('#useCropBtn').addEventListener('click', () => {
                    const scaleX = imgWidth / displayWidth;
                    const scaleY = imgHeight / displayHeight;
                    
                    const origX = cropRect.x * scaleX;
                    const origY = cropRect.y * scaleY;
                    const origW = cropRect.w * scaleX;
                    const origH = cropRect.h * scaleY;
                    
                    const tempCanvas = document.createElement('canvas');
                    tempCanvas.width = origW;
                    tempCanvas.height = origH;
                    const tempCtx = tempCanvas.getContext('2d');
                    
                    const tempImg = new Image();
                    tempImg.onload = () => {
                        tempCtx.drawImage(tempImg, -origX, -origY);
                        croppedDataUrl = tempCanvas.toDataURL();
                        croppedWidth = origW;
                        croppedHeight = origH;
                        
                        previewCanvas.width = origW;
                        previewCanvas.height = origH;
                        previewCtx.drawImage(tempImg, -origX, -origY);
                        
                        modal.querySelector('#cropPreview').style.display = 'block';
                        
                        modal.querySelector('#framesPerRow').addEventListener('change', updateFramePreview);
                        modal.querySelector('#totalFrames').addEventListener('change', updateFramePreview);
                        
                        const updateFramePreview = () => {
                            const fpr = parseInt(modal.querySelector('#framesPerRow').value) || 1;
                            const tf = parseInt(modal.querySelector('#totalFrames').value) || 1;
                            const frameW = origW / fpr;
                            const frameH = origH / Math.ceil(tf / fpr);
                            
                            previewCanvas.width = frameW;
                            previewCanvas.height = frameH;
                            previewCtx.drawImage(tempImg, -origX, -origY);
                        };
                    };
                    tempImg.src = dataUrl;
                });
                
                modal.querySelector('#animName').addEventListener('input', (e) => {
                    e.target.value = e.target.value.replace(/[^a-zA-Z0-9\s_]/g, '');
                });
                
                const self = this;
                modal.querySelector('#createAnimBtn').addEventListener('click', () => {
                    try {
                        const inputName = modal.querySelector('#animName').value.trim();
                        const name = inputName || filename.split('.')[0];
                        const framesPerRow = parseInt(modal.querySelector('#framesPerRow').value);
                        const totalFrames = parseInt(modal.querySelector('#totalFrames').value);
                        const frameDuration = parseInt(modal.querySelector('#frameDuration').value);
                        const autoTag = modal.querySelector('#autoTag').checked;
                        
                        if (inputName && !/^[a-zA-Z0-9\s_]+$/.test(name)) {
                            alert('Animation name can only contain letters, numbers, spaces, and underscores');
                            return;
                        }
                        
                        if (framesPerRow < 1 || totalFrames < 1 || frameDuration < 10) {
                            alert('Invalid frame settings. Check values are within allowed ranges.');
                            return;
                        }
                        
                        const finalDataUrl = croppedDataUrl || dataUrl;
                        const finalWidth = croppedDataUrl ? croppedWidth : imgWidth;
                        const finalHeight = croppedDataUrl ? croppedHeight : imgHeight;
                        
                        const frameW = Math.round(finalWidth / framesPerRow);
                        const frameH = Math.round(finalHeight / Math.ceil(totalFrames / framesPerRow));
                        
                        const detectFrameOffsets = (spriteDataUrl, fpr, tf, fw, fh) => {
                            return new Promise((resolve) => {
                                const img = new Image();
                                img.onload = () => {
                                    const canvas = document.createElement('canvas');
                                    const ctx = canvas.getContext('2d');
                                    canvas.width = fw;
                                    canvas.height = fh;
                                    
                                    const offsets = [];
                                    
                                    for (let frameIdx = 0; frameIdx < tf; frameIdx++) {
                                        const col = frameIdx % fpr;
                                        const row = Math.floor(frameIdx / fpr);
                                        const srcX = col * fw;
                                        const srcY = row * fh;
                                        
                                        ctx.clearRect(0, 0, fw, fh);
                                        ctx.drawImage(img, -srcX, -srcY);
                                        
                                        const imageData = ctx.getImageData(0, 0, fw, fh);
                                        const data = imageData.data;
                                        
                                        let minX = fw, maxX = 0, minY = fh, maxY = 0;
                                        let hasPixels = false;
                                        
                                        for (let i = 3; i < data.length; i += 4) {
                                            if (data[i] > 128) {
                                                hasPixels = true;
                                                const pixelIndex = (i - 3) / 4;
                                                const x = pixelIndex % fw;
                                                const y = Math.floor(pixelIndex / fw);
                                                minX = Math.min(minX, x);
                                                maxX = Math.max(maxX, x);
                                                minY = Math.min(minY, y);
                                                maxY = Math.max(maxY, y);
                                            }
                                        }
                                        
                                        if (hasPixels) {
                                            const centerX = (minX + maxX) / 2;
                                            const bottomY = maxY;
                                            offsets.push({ 
                                                centerX: Math.round(centerX), 
                                                bottomY: Math.round(bottomY) 
                                            });
                                        } else {
                                            offsets.push({ centerX: fw / 2, bottomY: fh });
                                        }
                                    }
                                    
                                    resolve(offsets);
                                };
                                img.src = spriteDataUrl;
                            });
                        };
                        
                        detectFrameOffsets(finalDataUrl, framesPerRow, totalFrames, frameW, frameH).then(offsets => {
                            const animation = {
                                id: Date.now() + Math.random(),
                                name: name,
                                filename: filename,
                                spriteSheet: finalDataUrl,
                                width: Math.round(finalWidth),
                                height: Math.round(finalHeight),
                                framesPerRow: framesPerRow,
                                totalFrames: totalFrames,
                                frameDuration: frameDuration,
                                frameWidth: frameW,
                                frameHeight: frameH,
                                frameOffsets: offsets,
                                tags: autoTag ? [name.toLowerCase()] : [],
                                createdAt: new Date().toISOString()
                            };
                            
                            self.assets.animations.push(animation);
                            self.saveAssets();
                            self.currentType = 'animations';
                            self.render();
                            modal.remove();
                            
                            showToast(`üé¨ Animation "${name}" created with anchor points!`);
                            
                            if (window.AnimationManager) {
                                AnimationManager.addAnimation(animation);
                            }
                            
                            if (window.AssetTagSystem) {
                                AssetTagSystem.updateBlocklyDropdowns();
                            }
                            
                            setTimeout(() => self.showFirstFrameTagging(animation, finalDataUrl, frameW, frameH), 500);
                        });
                    } catch (error) {
                        console.error('Error creating animation:', error);
                        alert('Error creating animation: ' + error.message);
                    }
                });
            },

            showFirstFrameTagging(animation, spriteDataUrl, frameW, frameH) {
                const self = this;
                const modal = document.createElement('div');
                modal.className = 'modal show';
                modal.style.zIndex = '10000';
                modal.innerHTML = `
                    <div class="modal-content" style="max-width: 600px;">
                        <h2>üé¨ ${animation.name} - Tag Preview Frame</h2>
                        <p style="color: #bbb; font-size: 12px; margin-bottom: 15px;">Your first frame has been extracted. Tag it to use as a sprite in your game.</p>
                        
                        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin: 20px 0;">
                            <div style="text-align: center;">
                                <h4 style="color: #ccc; margin-bottom: 10px;">Preview</h4>
                                <canvas id="framePreviewCanvas" width="200" height="200" style="background: #0f3460; border: 1px solid #533483; border-radius: 4px; display: block; margin: 0 auto;"></canvas>
                            </div>
                            
                            <div>
                                <h4 style="color: #ccc; margin-bottom: 10px;">Add Tag</h4>
                                <div style="display: flex; flex-direction: column; gap: 10px;">
                                    <input type="text" id="frameTag" placeholder="e.g., walk_idle" style="width: 100%; padding: 8px; border: 1px solid #533483; border-radius: 4px; background: #0f3460; color: white; box-sizing: border-box;" autocomplete="off">
                                    <div id="suggestedTags" style="display: flex; flex-wrap: wrap; gap: 6px;"></div>
                                    <small style="color: #aaa; font-size: 11px;">Letters, numbers, spaces, hyphens, and underscores allowed</small>
                                </div>
                            </div>
                        </div>
                        
                        <div class="modal-buttons">
                            <button onclick="this.closest('.modal').remove()" style="background: #95a5a6;">Skip</button>
                            <button id="createSpriteBtn" style="background: #27ae60; cursor: pointer;">‚úì Create Sprite</button>
                        </div>
                    </div>
                `;
                
                document.body.appendChild(modal);
                
                const previewCanvas = modal.querySelector('#framePreviewCanvas');
                const previewCtx = previewCanvas.getContext('2d');
                
                const img = new Image();
                img.onload = () => {
                    previewCtx.drawImage(img, 0, 0, frameW, frameH, 0, 0, previewCanvas.width, previewCanvas.height);
                };
                img.src = spriteDataUrl;
                
                const suggestedTags = [animation.name, animation.name + '_idle', 'player', 'enemy', 'sprite'];
                modal.querySelector('#suggestedTags').innerHTML = suggestedTags.map(tag => 
                    `<button class="tag-suggestion" data-tag="${tag}" style="background: #533483; padding: 4px 10px; border: 1px solid #7d4fa1; border-radius: 3px; color: white; cursor: pointer; font-size: 11px;">${tag}</button>`
                ).join('');
                
                modal.querySelectorAll('.tag-suggestion').forEach(btn => {
                    btn.addEventListener('click', () => {
                        modal.querySelector('#frameTag').value = btn.dataset.tag;
                    });
                });
                
                modal.querySelector('#frameTag').addEventListener('input', (e) => {
                    e.target.value = e.target.value.replace(/[^a-zA-Z0-9\s\-_]/g, '');
                });
                
                modal.querySelector('#createSpriteBtn').addEventListener('click', () => {
                    const tag = modal.querySelector('#frameTag').value.trim();
                    if (!tag) {
                        alert('Please enter or select a tag');
                        return;
                    }
                    
                    if (!/^[a-zA-Z0-9\s\-_]+$/.test(tag)) {
                        alert('Tag can only contain letters, numbers, spaces, hyphens, and underscores');
                        return;
                    }
                    
                    const tempCanvas = document.createElement('canvas');
                    tempCanvas.width = frameW;
                    tempCanvas.height = frameH;
                    const tempCtx = tempCanvas.getContext('2d');
                    
                    const tempImg = new Image();
                    tempImg.onload = () => {
                        tempCtx.drawImage(tempImg, 0, 0, frameW, frameH, 0, 0, frameW, frameH);
                        const firstFrameDataUrl = tempCanvas.toDataURL();
                        
                        const sprite = {
                            id: Date.now() + Math.random(),
                            name: animation.name + '_sprite',
                            type: 'sprites',
                            data: firstFrameDataUrl,
                            size: firstFrameDataUrl.length,
                            uploadedAt: new Date().toISOString(),
                            isBackground: false,
                            tags: [tag],
                            keyframes: []
                        };
                        
                        self.assets.sprites.push(sprite);
                        self.saveAssets();
                        self.render();
                        modal.remove();
                        
                        showToast(`‚ú® Sprite "${animation.name}_sprite" created with tag "${tag}"`);
                        AssetTagSystem.updateBlocklyDropdowns();
                    };
                    tempImg.src = spriteDataUrl;
                });
            },

            attachEvents() {
                document.getElementById('toggleAssets').addEventListener('click', () => {
                    const panel = document.getElementById('assetPanel');
                    const isCollapsed = panel.classList.toggle('collapsed');
                    document.getElementById('toggleAssets').textContent = isCollapsed ? '‚óÄ' : '‚ñº';
                });

                document.querySelectorAll('.asset-tab').forEach(tab => {
                    tab.addEventListener('click', (e) => {
                        document.querySelectorAll('.asset-tab').forEach(t => t.classList.remove('active'));
                        e.target.classList.add('active');
                        this.currentType = e.target.dataset.type;
                        this.render();
                    });
                });

                document.getElementById('assetUpload').addEventListener('change', (e) => {
                    this.handleUpload(e.target.files);
                });
            },

            handleUpload(files) {
                Array.from(files).forEach(file => {
                    const isImage = file.type.startsWith('image/');
                    const isAudio = file.type.startsWith('audio/');
                    
                    const showTypeSelector = (callback) => {
                        const modal = document.createElement('div');
                        modal.className = 'modal show';
                        modal.style.zIndex = '10001';
                        modal.innerHTML = `
                            <div class="modal-content" style="max-width: 400px;">
                                <h2>üì¶ Asset Type</h2>
                                <p style="color: #bbb; font-size: 12px; margin-bottom: 20px;">Choose where to organize this asset</p>
                                <div style="display: flex; flex-direction: column; gap: 10px;">
                                    ${isImage ? `
                                        <button class="asset-type-btn" data-type="backgrounds" style="padding: 15px; background: #533483; border: 1px solid #7d4fa1; border-radius: 4px; color: white; cursor: pointer; font-weight: bold;">üèûÔ∏è Background/Scene Image</button>
                                    ` : ''}
                                    ${isAudio ? `
                                        <button class="asset-type-btn" data-type="sounds" style="padding: 15px; background: #533483; border: 1px solid #7d4fa1; border-radius: 4px; color: white; cursor: pointer; font-weight: bold;">üîä Sound Effect/Music</button>
                                    ` : ''}
                                </div>
                                <button onclick="this.closest('.modal').remove()" style="width: 100%; margin-top: 15px; padding: 10px; background: #95a5a6; border: none; border-radius: 4px; color: white; cursor: pointer;">Cancel</button>
                            </div>
                        `;
                        document.body.appendChild(modal);
                        
                        modal.querySelectorAll('.asset-type-btn').forEach(btn => {
                            btn.addEventListener('click', () => {
                                const type = btn.dataset.type;
                                modal.remove();
                                callback(type);
                            });
                        });
                    };
                    
                    const reader = new FileReader();
                    reader.onload = (e) => {
                        const determineType = (selectedType) => {
                            const asset = {
                                id: Date.now() + Math.random(),
                                name: file.name,
                                type: selectedType,
                                data: e.target.result,
                                size: file.size,
                                uploadedAt: new Date().toISOString(),
                                isBackground: selectedType === 'backgrounds',
                                tags: [],
                                keyframes: []
                            };

                            if (asset.type === 'sprites' || asset.type === 'sounds') {
                                this.showTaggingModal(asset, () => {
                                    this.assets[asset.type].push(asset);
                                    this.saveAssets();
                                    this.render();
                                    showToast(`‚úÖ ${asset.name} added to ${asset.type}`);
                                    AchievementManager.check('asset_upload');
                                    AssetTagSystem.updateBlocklyDropdowns();
                                });
                            } else {
                                this.assets[asset.type].push(asset);
                                this.saveAssets();
                                this.render();
                                showToast(`‚úÖ ${file.name} added to backgrounds`);
                                AchievementManager.check('asset_upload');
                            }
                        };
                        
                        showTypeSelector(determineType);
                    };
                    reader.readAsDataURL(file);
                });
            },

            showTaggingModal(asset, onConfirm) {
                const PREDEFINED_TAGS = ['enemy', 'player', 'projectile', 'obstacle', 'collectible', 'hazard', 'npc', 'boss'];
                
                const modal = document.createElement('div');
                modal.className = 'modal show';
                modal.style.zIndex = '10000';
                
                const tagButtonsHtml = PREDEFINED_TAGS.map(tag => 
                    `<button class="tag-button" data-tag="${tag}">${tag}</button>`
                ).join('');
                
                modal.innerHTML = `
                    <div class="modal-content" style="max-width: 600px;">
                        <h2>üè∑Ô∏è Tag: ${asset.name}</h2>
                        <p style="color: #bbb; font-size: 12px;">Select predefined tags or create custom ones</p>
                        
                        <div style="margin: 20px 0;">
                            <h4 style="color: #ccc; margin-bottom: 10px;">Suggested Tags</h4>
                            <div style="display: flex; flex-wrap: wrap; gap: 8px; margin-bottom: 20px;">
                                ${tagButtonsHtml}
                            </div>
                            
                            <h4 style="color: #ccc; margin-bottom: 10px;">Custom Tag Input</h4>
                            <div style="display: flex; gap: 8px;">
                                <input type="text" id="customTagInput" placeholder="Enter custom tag..." 
                                    style="flex: 1; padding: 8px; border: 1px solid #533483; border-radius: 4px; background: #0f3460; color: white;">
                                <button id="addCustomTagBtn" style="padding: 8px 15px; background: #533483; color: white; border: none; border-radius: 4px; cursor: pointer;">Add</button>
                            </div>
                        </div>
                        
                        <div style="margin: 20px 0;">
                            <h4 style="color: #ccc; margin-bottom: 10px;">Selected Tags</h4>
                            <div id="selectedTagsContainer" style="display: flex; flex-wrap: wrap; gap: 8px; min-height: 32px; padding: 10px; background: #0f3460; border-radius: 4px;">
                                <span style="color: #888; font-style: italic;">No tags selected</span>
                            </div>
                        </div>
                        
                        <div class="modal-buttons">
                            <button onclick="this.closest('.modal').remove()" style="background: #95a5a6;">Cancel</button>
                            <button id="confirmTagsBtn" style="background: #27ae60; cursor: pointer;">Confirm Tags</button>
                        </div>
                    </div>
                `;
                
                document.body.appendChild(modal);
                
                const selectedTags = [];
                const selectedTagsContainer = modal.querySelector('#selectedTagsContainer');
                const customTagInput = modal.querySelector('#customTagInput');
                
                const updateTagsDisplay = () => {
                    if (selectedTags.length === 0) {
                        selectedTagsContainer.innerHTML = '<span style="color: #888; font-style: italic;">No tags selected</span>';
                    } else {
                        selectedTagsContainer.innerHTML = selectedTags.map(tag => 
                            `<span style="background: #533483; padding: 4px 10px; border-radius: 12px; font-size: 12px; display: flex; align-items: center; gap: 6px;">
                                ${tag}
                                <button data-remove-tag="${tag}" style="background: none; border: none; color: #ff6b6b; cursor: pointer; font-weight: bold; padding: 0;">√ó</button>
                            </span>`
                        ).join('');
                        
                        modal.querySelectorAll('[data-remove-tag]').forEach(btn => {
                            btn.addEventListener('click', (e) => {
                                e.stopPropagation();
                                const tag = btn.dataset.removeTag;
                                selectedTags.splice(selectedTags.indexOf(tag), 1);
                                updateTagsDisplay();
                            });
                        });
                    }
                };
                
                modal.querySelectorAll('.tag-button').forEach(btn => {
                    btn.addEventListener('click', () => {
                        const tag = btn.dataset.tag;
                        if (!selectedTags.includes(tag)) {
                            selectedTags.push(tag);
                            updateTagsDisplay();
                        }
                    });
                });
                
                modal.querySelector('#addCustomTagBtn').addEventListener('click', () => {
                    const tag = customTagInput.value.trim().toLowerCase();
                    if (tag && !selectedTags.includes(tag)) {
                        selectedTags.push(tag);
                        customTagInput.value = '';
                        updateTagsDisplay();
                    }
                });
                
                customTagInput.addEventListener('keypress', (e) => {
                    if (e.key === 'Enter') {
                        modal.querySelector('#addCustomTagBtn').click();
                    }
                });
                
                modal.querySelector('#confirmTagsBtn').addEventListener('click', () => {
                    asset.tags = selectedTags;
                    modal.remove();
                    onConfirm();
                });
            },

            setAsBackground(assetId) {
                let asset = null;
                for (let type in this.assets) {
                    asset = this.assets[type].find(a => a.id === assetId);
                    if (asset) break;
                }

                if (asset && asset.type !== 'sounds') {
                    if (this.backgroundAsset) {
                        this.backgroundAsset.isBackground = false;
                    }
                    
                    asset.isBackground = true;
                    this.backgroundAsset = asset;
                    this.saveAssets();
                    this.render();
                    showToast(`üñºÔ∏è Set ${asset.name} as background`);
                    this.applyBackgroundToPreview();
                }
            },

            applyBackgroundToPreview() {
                if (this.backgroundAsset && this.backgroundAsset.data) {
                    const canvas = document.getElementById('gameCanvas');
                    const ctx = canvas.getContext('2d');
                    const img = new Image();
                    img.onload = () => {
                        window.gameBackgroundImage = img;
                    };
                    img.src = this.backgroundAsset.data;
                }
            },

            deleteAsset(id, type) {
                if (confirm('Delete this asset?')) {
                    const asset = this.assets[type].find(a => a.id === id);
                    if (asset && asset.isBackground) {
                        this.backgroundAsset = null;
                    }
                    this.assets[type] = this.assets[type].filter(a => a.id !== id);
                    this.saveAssets();
                    this.render();
                    showToast('üóëÔ∏è Asset deleted');
                }
            },

            showPreview(asset) {
                const modal = document.createElement('div');
                modal.className = 'modal show';
                modal.innerHTML = `
                    <div class="modal-content">
                        <h2>Preview: ${asset.name}</h2>
                        <div style="text-align: center; padding: 20px;">
                            ${asset.type !== 'sounds' ? 
                                `<img src="${asset.data}" style="max-width: 100%; max-height: 400px; border-radius: 5px;">` :
                                `<audio controls src="${asset.data}" style="width: 100%;"></audio>`
                            }
                        </div>
                        <div class="modal-buttons">
                            <button onclick="this.closest('.modal').remove()" style="background: #95a5a6;">Close</button>
                            ${asset.type !== 'sounds' ? 
                                `<button onclick="AssetManager.setAsBackground(${asset.id}); this.closest('.modal').remove();" style="background: #3498db;">Set as Background</button>` :
                                ''
                            }
                        </div>
                    </div>
                `;
                document.body.appendChild(modal);
            },

            render() {
                const grid = document.getElementById('assetGrid');
                const assets = this.assets[this.currentType];

                if (assets.length === 0) {
                    grid.innerHTML = '<p style="color: #95a5a6; text-align: center; padding: 20px; grid-column: 1/-1;">No assets yet. Upload some!</p>';
                    return;
                }

                grid.innerHTML = assets.map(asset => {
                    const tagsHtml = asset.tags && asset.tags.length > 0 
                        ? `<div style="font-size: 10px; color: #bbb; margin-top: 4px; display: flex; flex-wrap: wrap; gap: 2px;">
                            ${asset.tags.map(tag => `<span style="background: #533483; padding: 2px 6px; border-radius: 3px; font-weight: 500;">üè∑Ô∏è${tag}</span>`).join('')}
                           </div>`
                        : '';
                    
                    if (this.currentType === 'animations') {
                        return `
                            <div class="asset-item" data-id="${asset.id}" style="cursor: pointer; position: relative;">
                                <canvas id="preview-${asset.id}" class="asset-preview" width="64" height="64" style="background: #0f3460; border-radius: 4px;"></canvas>
                                <div class="asset-name">${asset.name}</div>
                                <div style="font-size: 9px; color: #888;">${asset.totalFrames} frames @ ${asset.frameDuration}ms</div>
                                ${tagsHtml}
                                <button class="asset-delete" onclick="AssetManager.deleteAsset(${asset.id}, '${this.currentType}')">√ó</button>
                            </div>
                        `;
                    }
                    
                    return `
                        <div class="asset-item" data-id="${asset.id}" style="${asset.isBackground ? 'border: 2px solid #3498db;' : ''}">
                            ${asset.type !== 'sounds' ? 
                                `<img src="${asset.data}" class="asset-preview" alt="${asset.name}">` :
                                `<div class="asset-preview" style="display: flex; align-items: center; justify-content: center; color: white; font-size: 24px;">üîä</div>`
                            }
                            <div class="asset-name">${asset.name}${asset.isBackground ? ' üñºÔ∏è' : ''}</div>
                            ${tagsHtml}
                            <button class="asset-delete" onclick="AssetManager.deleteAsset(${asset.id}, '${this.currentType}')">√ó</button>
                        </div>
                    `;
                }).join('');

                if (this.currentType === 'animations') {
                    assets.forEach(animation => {
                        const canvas = document.getElementById(`preview-${animation.id}`);
                        if (canvas && window.AnimationPreviewRenderer) {
                            try {
                                AnimationPreviewRenderer.renderFrame(canvas, animation, 0);
                            } catch (e) {
                                console.warn('Could not render animation preview:', e);
                            }
                        }
                    });
                }

                grid.querySelectorAll('.asset-item').forEach(item => {
                    item.addEventListener('click', (e) => {
                        if (!e.target.classList.contains('asset-delete')) {
                            const id = parseFloat(item.dataset.id);
                            const asset = assets.find(a => a.id === id);
                            if (this.currentType === 'animations') {
                                AnimationManager.showAnimationEditor(asset);
                            } else {
                                this.showPreview(asset);
                            }
                        }
                    });
                });
            }
        };

        // === SNIPPET 7: Dynamic Asset Tag System ===
        const AssetTagSystem = {
            getAssetsByTag(tag) {
                const results = [];
                Object.values(AssetManager.assets).forEach(assetList => {
                    assetList.forEach(asset => {
                        if (asset.tags && asset.tags.includes(tag)) {
                            results.push(asset);
                        }
                    });
                });
                return results;
            },

            getAllTags() {
                const tags = new Set();
                Object.values(AssetManager.assets).forEach(assetList => {
                    assetList.forEach(asset => {
                        if (asset.tags && Array.isArray(asset.tags)) {
                            asset.tags.forEach(tag => tags.add(tag));
                        }
                    });
                });
                return Array.from(tags).sort();
            },

            getAssetNames() {
                const names = new Set();
                Object.values(AssetManager.assets).forEach(assetList => {
                    assetList.forEach(asset => {
                        const name = asset.name.split('.')[0];
                        names.add(name);
                    });
                });
                return Array.from(names).sort();
            },

            getAssetDropdownOptions() {
                const allAssets = [];
                const tags = this.getAllTags();
                const names = this.getAssetNames();
                
                const options = [["-- Select Asset --", ""]];
                
                if (tags.length > 0) {
                    options.push(["----- BY TAG -----", "HEADER"]);
                    tags.forEach(tag => {
                        options.push([`üè∑Ô∏è ${tag}`, `tag:${tag}`]);
                    });
                }
                
                if (names.length > 0) {
                    options.push(["----- BY NAME -----", "HEADER"]);
                    names.forEach(name => {
                        options.push([`üì¶ ${name}`, name.toLowerCase()]);
                    });
                }
                
                return options;
            },

            updateBlocklyDropdowns() {
                const options = this.getAssetDropdownOptions();
                const workspace = Blockly.getMainWorkspace();
                
                if (workspace) {
                    const blocks = workspace.getAllBlocks(false);
                    blocks.forEach(block => {
                        if (block.type === 'spawn_sprite' || block.type === 'spawn_tag_entity') {
                            const field = block.getField('SPRITE') || block.getField('TAG');
                            if (field && field.setOptions) {
                                field.setOptions(options);
                            }
                        }
                    });
                }

            },

            init() {
                this.updateBlocklyDropdowns();
            }
        };

        // Game Preview Manager
        const PreviewManager = {
            isRunning: false,
            gameLoop: null,
            runtime: null,
            
            init() {
                this.attachEvents();
                this.initializeRuntime();
            },

            attachEvents() {
                document.getElementById('playGame').addEventListener('click', () => this.play());
                document.getElementById('stopGame').addEventListener('click', () => this.stop());
                document.getElementById('restartGame').addEventListener('click', () => this.restart());
                document.getElementById('closePreview').addEventListener('click', () => this.close());
                document.getElementById('toggleDebug').addEventListener('click', () => this.toggleDebug());
            },

            initializeRuntime() {
                this.runtime = new GameRuntime();
            },

            play() {
                const panel = document.getElementById('previewPanel');
                panel.classList.remove('collapsed');
                
                if (!this.isRunning) {
                    this.isRunning = true;
                    
                    const debugConsole = document.getElementById('debugConsole');
                    if (debugConsole.classList.contains('collapsed')) {
                        debugConsole.classList.remove('collapsed');
                        document.getElementById('toggleConsole').textContent = '‚ñ≤';
                        DebugConsole.isCollapsed = false;
                    }
                    
                    this.startGame();
                    
                    document.getElementById('playGame').disabled = true;
                    document.getElementById('stopGame').disabled = false;
                    document.getElementById('restartGame').disabled = false;
                    
                    document.getElementById('blocklyDiv').style.opacity = '0.5';
                    document.getElementById('assetPanel').style.opacity = '0.5';
                    
                    showToast('‚ñ∂Ô∏è Preview started');
                    DebugConsole.clear();
                    DebugConsole.log('Game started');
                }
            },

            stop() {
                this.isRunning = false;
                if (this.gameLoop) {
                    cancelAnimationFrame(this.gameLoop);
                }
                
                this.runtime.stop();
                
                document.getElementById('playGame').disabled = false;
                document.getElementById('stopGame').disabled = true;
                document.getElementById('restartGame').disabled = true;
                
                document.getElementById('blocklyDiv').style.opacity = '1';
                document.getElementById('assetPanel').style.opacity = '1';
                
                document.getElementById('debugPreviewSection').style.display = 'none';
                document.getElementById('previewSVG').style.display = 'block';
                document.getElementById('debugGameCanvas').style.display = 'none';
                
                showToast('‚èπÔ∏è Preview stopped');
                DebugConsole.log('Game stopped');
            },

            restart() {
                DebugConsole.log('Restarting game...');
                this.stop();
                setTimeout(() => this.play(), 100);
            },

            close() {
                this.stop();
                document.getElementById('previewPanel').classList.add('collapsed');
            },

            toggleDebug() {
                window.debugOverlays = window.debugOverlays || { enabled: false };
                window.debugOverlays.enabled = !window.debugOverlays.enabled;
                
                const btn = document.getElementById('toggleDebug');
                btn.style.background = window.debugOverlays.enabled ? '#27ae60' : '#f39c12';
                btn.textContent = window.debugOverlays.enabled ? 'üêõ Debug ‚úì' : 'üêõ Debug';
                
                showToast(window.debugOverlays.enabled ? 'Debug overlays ON' : 'Debug overlays OFF');
            },

            startGame() {
                const canvas = document.getElementById('gameCanvas');
                const ctx = canvas.getContext('2d');
                const code = Blockly.JavaScript.workspaceToCode(workspace);
                
                this.runtime.initialize(canvas, ctx, code);
                
                if (AssetManager.backgroundAsset) {
                    this.runtime.setBackground(AssetManager.backgroundAsset.data);
                }
                
                document.getElementById('debugPreviewSection').style.display = 'block';
                document.getElementById('previewSVG').style.display = 'none';
                document.getElementById('debugGameCanvas').style.display = 'block';
                
                const debugCanvas = document.getElementById('debugGameCanvas');
                const debugCtx = debugCanvas.getContext('2d');
                
                let lastTime = performance.now();
                const loop = (currentTime) => {
                    if (!this.isRunning) return;
                    
                    const deltaTime = (currentTime - lastTime) / 1000;
                    lastTime = currentTime;
                    
                    try {
                        this.runtime.update(deltaTime);
                        this.runtime.render();
                        
                        debugCtx.drawImage(canvas, 0, 0);
                        
                        document.getElementById('previewScore').textContent = this.runtime.getScore();
                        document.getElementById('previewFPS').textContent = Math.round(1 / deltaTime);
                    } catch (error) {
                        DebugConsole.error('Runtime Error: ' + error.message);
                        console.error(error);
                        this.stop();
                        return;
                    }
                    
                    this.gameLoop = requestAnimationFrame(loop);
                };
                
                this.gameLoop = requestAnimationFrame(loop);
            }
        };

        // Achievement System
        const AchievementManager = {
            achievements: {
                first_game: { title: 'First Blood', desc: 'Create your first game', xp: 50, unlocked: false },
                ten_blocks: { title: 'Block Master', desc: 'Use 10+ blocks in a game', xp: 100, unlocked: false },
                first_save: { title: 'Saver', desc: 'Save your first game', xp: 25, unlocked: false },
                first_publish: { title: 'Publisher', desc: 'Publish your first game', xp: 200, unlocked: false },
                asset_upload: { title: 'Artist', desc: 'Upload your first asset', xp: 75, unlocked: false }
            },

            check(achievementId) {
                const achievement = this.achievements[achievementId];
                if (achievement && !achievement.unlocked) {
                    achievement.unlocked = true;
                    this.show(achievement.title, achievement.desc, achievement.xp);
                    this.save();
                    
                    console.log('Achievement unlocked:', achievementId, achievement);
                }
            },

            show(title, desc, xp) {
                const panel = document.getElementById('achievementPanel');
                document.getElementById('achievementTitle').textContent = title;
                document.getElementById('achievementDesc').textContent = desc;
                document.querySelector('.achievement-points').textContent = `+${xp} XP`;
                
                panel.classList.add('show');
                setTimeout(() => panel.classList.remove('show'), 4000);
            },

            save() {
                localStorage.setItem('lupiforge_achievements', JSON.stringify(this.achievements));
            },

            load() {
                const saved = localStorage.getItem('lupiforge_achievements');
                if (saved) {
                    this.achievements = JSON.parse(saved);
                }
            }
        };

        // Score Submission System
        const ScoreManager = {
            currentScore: 0,

            init() {
                document.getElementById('cancelScore').addEventListener('click', () => {
                    document.getElementById('scoreModal').classList.remove('show');
                });

                document.getElementById('submitScore').addEventListener('click', () => {
                    this.submitScore();
                });
            },

            show(score) {
                this.currentScore = score;
                document.getElementById('finalScore').textContent = score;
                document.getElementById('scoreModal').classList.add('show');
            },

            submitScore() {
                const playerName = document.getElementById('playerName').value.trim();
                if (!playerName) {
                    showToast('‚ùå Please enter your name!', true);
                    return;
                }

                const scoreData = {
                    player_name: playerName,
                    score: this.currentScore,
                    game_id: 'current_game',
                    timestamp: new Date().toISOString()
                };

                console.log('Score submitted:', scoreData);
                console.log('API Endpoint: POST /games/api/submit-score/');
                
                document.getElementById('scoreModal').classList.remove('show');
                showToast(`üèÜ Score ${this.currentScore} submitted!`);

                // Check for achievement
                if (this.currentScore > 1000) {
                    AchievementManager.check('high_scorer');
                }
            }
        };

        // Notification Manager
        const NotificationManager = {
            notifications: [],
            unreadCount: 0,

            init() {
                this.loadNotifications();
                this.render();
                this.attachEvents();
            },

            attachEvents() {
                document.getElementById('notificationBell').addEventListener('click', () => {
                    document.getElementById('notificationDropdown').classList.toggle('show');
                });

                document.getElementById('markAllRead').addEventListener('click', () => {
                    this.markAllRead();
                });

                // Close dropdown when clicking outside
                document.addEventListener('click', (e) => {
                    const dropdown = document.getElementById('notificationDropdown');
                    const bell = document.getElementById('notificationBell');
                    if (!dropdown.contains(e.target) && !bell.contains(e.target)) {
                        dropdown.classList.remove('show');
                    }
                });
            },

            loadNotifications() {
                const saved = localStorage.getItem('lupiforge_notifications');
                if (saved) {
                    this.notifications = JSON.parse(saved);
                } else {
                    // Add welcome notification
                    this.add('Welcome to LupiForge! üéÆ', 'Start creating your first game with blocks!', 'info');
                }
                this.updateCount();
            },

            add(title, message, type = 'info') {
                const notification = {
                    id: Date.now() + Math.random(),
                    title,
                    message,
                    type,
                    read: false,
                    timestamp: new Date().toISOString()
                };

                this.notifications.unshift(notification);
                this.save();
                this.updateCount();
                this.render();

                // Show toast for new notification
                showToast(`üîî ${title}`);
            },

            markAsRead(id) {
                const notification = this.notifications.find(n => n.id === id);
                if (notification) {
                    notification.read = true;
                    this.save();
                    this.updateCount();
                    this.render();
                }
            },

            markAllRead() {
                this.notifications.forEach(n => n.read = true);
                this.save();
                this.updateCount();
                this.render();
            },

            updateCount() {
                this.unreadCount = this.notifications.filter(n => !n.read).length;
                const badge = document.getElementById('notificationCount');
                badge.textContent = this.unreadCount;
                badge.classList.toggle('hidden', this.unreadCount === 0);
            },

            save() {
                localStorage.setItem('lupiforge_notifications', JSON.stringify(this.notifications));
            },

            render() {
                const list = document.getElementById('notificationList');
                
                if (this.notifications.length === 0) {
                    list.innerHTML = '<div style="padding: 30px; text-align: center; color: #95a5a6;">No notifications yet</div>';
                    return;
                }

                list.innerHTML = this.notifications.map(n => {
                    const time = new Date(n.timestamp);
                    const timeAgo = this.getTimeAgo(time);
                    
                    return `
                        <div class="notification-item ${n.read ? '' : 'unread'}" onclick="NotificationManager.markAsRead(${n.id})">
                            <div class="notification-title">${n.title}</div>
                            <div class="notification-message">${n.message}</div>
                            <div class="notification-time">${timeAgo}</div>
                        </div>
                    `;
                }).join('');
            },

            getTimeAgo(date) {
                const seconds = Math.floor((new Date() - date) / 1000);
                if (seconds < 60) return 'Just now';
                const minutes = Math.floor(seconds / 60);
                if (minutes < 60) return `${minutes}m ago`;
                const hours = Math.floor(minutes / 60);
                if (hours < 24) return `${hours}h ago`;
                const days = Math.floor(hours / 24);
                return `${days}d ago`;
            },

            simulateModeratorFeedback(status) {
                const messages = {
                    approved: ['üéâ Your game has been approved!', 'It\'s now live and players can enjoy it!'],
                    rejected: ['‚ùå Your game needs revisions', 'Please check the feedback and resubmit.'],
                    pending: ['‚è≥ Your game is under review', 'Moderators will review it within 24 hours.']
                };
                
                const [title, message] = messages[status];
                this.add(title, message, status);
            }
        };

        const AnimationPreviewRenderer = {
            imageCache: new Map(),

            getImage(spriteSheet) {
                if (!this.imageCache.has(spriteSheet)) {
                    const img = new Image();
                    img.crossOrigin = 'anonymous';
                    img.src = spriteSheet;
                    this.imageCache.set(spriteSheet, img);
                }
                return this.imageCache.get(spriteSheet);
            },

            renderFrame(canvas, animation, frameIndex) {
                const ctx = canvas.getContext('2d');
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                ctx.fillStyle = '#1a1a1a';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                const img = this.getImage(animation.spriteSheet);
                
                if (img.complete && img.naturalWidth > 0) {
                    const row = Math.floor(frameIndex / animation.framesPerRow);
                    const col = frameIndex % animation.framesPerRow;
                    
                    const srcX = col * animation.frameWidth;
                    const srcY = row * animation.frameHeight;
                    
                    const scale = Math.min(
                        canvas.width / animation.frameWidth,
                        canvas.height / animation.frameHeight
                    );
                    
                    const dstWidth = animation.frameWidth * scale;
                    const dstHeight = animation.frameHeight * scale;
                    const dstX = (canvas.width - dstWidth) / 2;
                    const dstY = (canvas.height - dstHeight) / 2;
                    
                    ctx.drawImage(img, srcX, srcY, animation.frameWidth, animation.frameHeight, dstX, dstY, dstWidth, dstHeight);
                    
                    if (animation.frameOffsets && animation.frameOffsets[frameIndex]) {
                        const offset = animation.frameOffsets[frameIndex];
                        const anchorX = dstX + (offset.centerX * scale);
                        const anchorY = dstY + (offset.bottomY * scale);
                        
                        ctx.strokeStyle = '#ff4444';
                        ctx.lineWidth = 2;
                        ctx.beginPath();
                        ctx.moveTo(anchorX - 8, anchorY);
                        ctx.lineTo(anchorX + 8, anchorY);
                        ctx.moveTo(anchorX, anchorY - 8);
                        ctx.lineTo(anchorX, anchorY + 8);
                        ctx.stroke();
                        
                        ctx.fillStyle = '#ff4444';
                        ctx.beginPath();
                        ctx.arc(anchorX, anchorY, 3, 0, Math.PI * 2);
                        ctx.fill();
                    }
                }
            },

            playAnimation(canvas, animation, duration = null) {
                const totalDuration = duration || (animation.totalFrames * animation.frameDuration);
                const startTime = performance.now();
                let lastFrameIndex = -1;
                
                const animate = (currentTime) => {
                    const elapsed = currentTime - startTime;
                    const progress = (elapsed % totalDuration) / totalDuration;
                    const frameIndex = Math.floor(progress * animation.totalFrames) % animation.totalFrames;
                    
                    if (frameIndex !== lastFrameIndex) {
                        this.renderFrame(canvas, animation, frameIndex);
                        lastFrameIndex = frameIndex;
                    }
                    
                    requestAnimationFrame(animate);
                };
                
                requestAnimationFrame(animate);
            }
        };

        const AnimationManager = {
            animations: {},
            activeAnimations: new Map(),

            addAnimation(animation) {
                this.animations[animation.id] = animation;
            },

            playAnimation(entityTag, animationName, options = {}) {
                const animation = Object.values(this.animations).find(a => a.name === animationName);
                
                if (!animation) {
                    console.warn(`Animation "${animationName}" not found`);
                    return;
                }
                
                const duration = options.duration || (animation.totalFrames * animation.frameDuration);
                const loop = options.loop !== false;
                const onFrame = options.onFrame || null;
                const playbackRate = options.playbackRate || 1;
                
                const startTime = performance.now();
                const animId = `${entityTag}-${animationName}-${Date.now()}`;
                let lastFrameIndex = -1;
                
                const animate = (currentTime) => {
                    const elapsed = (currentTime - startTime) * playbackRate;
                    const progress = loop ? (elapsed % duration) / duration : Math.min(elapsed / duration, 1);
                    const frameIndex = Math.floor(progress * animation.totalFrames) % animation.totalFrames;
                    
                    if (frameIndex !== lastFrameIndex && onFrame) {
                        onFrame(frameIndex, animation);
                        lastFrameIndex = frameIndex;
                    }
                    
                    if (!loop && elapsed >= duration) {
                        if (onFrame && lastFrameIndex !== animation.totalFrames - 1) {
                            onFrame(animation.totalFrames - 1, animation);
                        }
                        this.activeAnimations.delete(animId);
                        return;
                    }
                    
                    this.activeAnimations.set(animId, requestAnimationFrame(animate));
                };
                
                animate(startTime);
                return animId;
            },

            stopAnimation(animId) {
                const rafId = this.activeAnimations.get(animId);
                if (rafId) {
                    cancelAnimationFrame(rafId);
                    this.activeAnimations.delete(animId);
                }
            },

            showAnimationEditor(animation) {
                const modal = document.createElement('div');
                modal.className = 'modal show';
                modal.style.zIndex = '10000';
                
                let currentFrame = 0;
                
                const updatePreview = () => {
                    const canvas = modal.querySelector('#animPreviewCanvas');
                    AnimationPreviewRenderer.renderFrame(canvas, animation, currentFrame);
                };
                
                modal.innerHTML = `
                    <div class="modal-content" style="max-width: 800px;">
                        <h2>üé¨ ${animation.name} Animation Editor</h2>
                        
                        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin: 20px 0;">
                            <div>
                                <h4 style="color: #ccc; margin-bottom: 10px;">Preview</h4>
                                <canvas id="animPreviewCanvas" width="200" height="200" style="background: #0f3460; border: 1px solid #533483; border-radius: 4px; margin-bottom: 10px; display: block; margin-left: auto; margin-right: auto;"></canvas>
                                
                                <div style="display: flex; gap: 10px;">
                                    <button id="prevFrameBtn" style="flex: 1; padding: 8px; background: #533483; color: white; border: none; border-radius: 4px; cursor: pointer;">‚óÄ Prev</button>
                                    <button id="playPreviewBtn" style="flex: 1; padding: 8px; background: #27ae60; color: white; border: none; border-radius: 4px; cursor: pointer;">‚ñ∂ Play</button>
                                    <button id="nextFrameBtn" style="flex: 1; padding: 8px; background: #533483; color: white; border: none; border-radius: 4px; cursor: pointer;">Next ‚ñ∂</button>
                                </div>
                                
                                <div id="frameIndicator" style="text-align: center; color: #bbb; margin-top: 10px; font-size: 12px;">Frame 0 / ${animation.totalFrames}</div>
                            </div>
                            
                            <div>
                                <h4 style="color: #ccc; margin-bottom: 10px;">Settings</h4>
                                
                                <label style="display: block; margin-bottom: 15px; color: #ccc;">
                                    <div style="font-size: 12px; margin-bottom: 5px;">Animation Name</div>
                                    <input type="text" id="animNameEdit" value="${animation.name}" style="width: 100%; padding: 8px; border: 1px solid #533483; border-radius: 4px; background: #0f3460; color: white; box-sizing: border-box;" autocomplete="off">
                                    <small style="color: #aaa; font-size: 10px; margin-top: 3px; display: block;">Letters, numbers, spaces, and underscores</small>
                                </label>
                                
                                <label style="display: block; margin-bottom: 15px; color: #ccc;">
                                    <div style="font-size: 12px; margin-bottom: 5px;">Frame Duration (ms)</div>
                                    <input type="number" id="frameDurationEdit" value="${animation.frameDuration}" min="10" step="10" style="width: 100%; padding: 8px; border: 1px solid #533483; border-radius: 4px; background: #0f3460; color: white; box-sizing: border-box;">
                                </label>
                                
                                <label style="display: block; margin-bottom: 15px; color: #ccc;">
                                    <div style="font-size: 12px; margin-bottom: 5px;">Tags</div>
                                    <div style="display: flex; flex-wrap: wrap; gap: 6px;">
                                        ${animation.tags && animation.tags.length > 0 
                                            ? animation.tags.map(tag => `<span style="background: #533483; padding: 4px 8px; border-radius: 3px; font-size: 12px;">üè∑Ô∏è${tag}</span>`).join('')
                                            : '<span style="color: #888;">No tags</span>'
                                        }
                                    </div>
                                </label>
                                
                                <div style="color: #bbb; font-size: 12px; margin-top: 15px; padding-top: 15px; border-top: 1px solid #533483;">
                                    <p><strong>Info:</strong></p>
                                    <p>Sheet Size: ${animation.width}x${animation.height}px</p>
                                    <p>Frame Size: ${Math.round(animation.frameWidth)}x${Math.round(animation.frameHeight)}px</p>
                                    <p>Frames Per Row: ${animation.framesPerRow}</p>
                                    <p>Total Frames: ${animation.totalFrames}</p>
                                </div>
                            </div>
                        </div>
                        
                        <div class="modal-buttons">
                            <button onclick="this.closest('.modal').remove()" style="background: #95a5a6;">Close</button>
                            <button id="updateAnimBtn" style="background: #27ae60; cursor: pointer;">Save Changes</button>
                        </div>
                    </div>
                `;
                
                document.body.appendChild(modal);
                updatePreview();
                
                modal.querySelector('#animNameEdit').addEventListener('input', (e) => {
                    e.target.value = e.target.value.replace(/[^a-zA-Z0-9\s_]/g, '');
                });
                
                modal.querySelector('#prevFrameBtn').addEventListener('click', () => {
                    currentFrame = (currentFrame - 1 + animation.totalFrames) % animation.totalFrames;
                    updatePreview();
                    modal.querySelector('#frameIndicator').textContent = `Frame ${currentFrame} / ${animation.totalFrames}`;
                });
                
                modal.querySelector('#nextFrameBtn').addEventListener('click', () => {
                    currentFrame = (currentFrame + 1) % animation.totalFrames;
                    updatePreview();
                    modal.querySelector('#frameIndicator').textContent = `Frame ${currentFrame} / ${animation.totalFrames}`;
                });
                
                modal.querySelector('#playPreviewBtn').addEventListener('click', () => {
                    let frame = 0;
                    const play = () => {
                        updatePreview();
                        currentFrame = frame;
                        modal.querySelector('#frameIndicator').textContent = `Frame ${currentFrame} / ${animation.totalFrames}`;
                        frame = (frame + 1) % animation.totalFrames;
                        setTimeout(play, animation.frameDuration);
                    };
                    play();
                });
                
                modal.querySelector('#updateAnimBtn').addEventListener('click', () => {
                    const newName = modal.querySelector('#animNameEdit').value.trim();
                    const newDuration = parseInt(modal.querySelector('#frameDurationEdit').value);
                    
                    if (!newName) {
                        alert('Animation name cannot be empty');
                        return;
                    }
                    
                    if (!/^[a-zA-Z0-9\s_]+$/.test(newName)) {
                        alert('Animation name can only contain letters, numbers, spaces, and underscores');
                        return;
                    }
                    
                    if (newDuration < 10) {
                        alert('Frame duration must be at least 10ms');
                        return;
                    }
                    
                    animation.name = newName;
                    animation.frameDuration = newDuration;
                    AssetManager.saveAssets();
                    modal.remove();
                    AssetManager.render();
                    showToast('üé¨ Animation updated!');
                });
            }
        };

        const KeyframeManager = {
            keyframes: {},
            currentKeyframe: null,

            init() {
                this.loadKeyframes();
            },

            loadKeyframes() {
                const saved = localStorage.getItem('lupiforge_keyframes');
                if (saved) {
                    this.keyframes = JSON.parse(saved);
                }
            },

            saveKeyframes() {
                localStorage.setItem('lupiforge_keyframes', JSON.stringify(this.keyframes));
            },

            createKeyframeForTag(tag, timeMs) {
                if (!this.keyframes[tag]) {
                    this.keyframes[tag] = [];
                }
                
                const keyframe = {
                    id: Date.now() + Math.random(),
                    tag: tag,
                    time: timeMs,
                    properties: {},
                    createdAt: new Date().toISOString()
                };
                
                this.keyframes[tag].push(keyframe);
                this.keyframes[tag].sort((a, b) => a.time - b.time);
                this.currentKeyframe = keyframe;
                this.saveKeyframes();
                
                console.log(`‚úÖ Created keyframe for tag "${tag}" at ${timeMs}ms`);
                return keyframe;
            },

            setKeyframeProperty(property, value) {
                if (this.currentKeyframe) {
                    this.currentKeyframe.properties[property] = value;
                    this.saveKeyframes();
                    console.log(`üìù Set ${property} = ${value} for keyframe`);
                }
            },

            getKeyframesForTag(tag) {
                return this.keyframes[tag] || [];
            },

            interpolateValue(startVal, endVal, progress, easing) {
                let t = progress;
                
                switch(easing) {
                    case 'easeIn':
                        t = t * t;
                        break;
                    case 'easeOut':
                        t = t * (2 - t);
                        break;
                    case 'easeInOut':
                        t = t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t;
                        break;
                    default:
                        break;
                }
                
                return startVal + (endVal - startVal) * t;
            },

            animateKeyframes(tag, startTimeMs, endTimeMs, easing = 'linear') {
                const keyframesForTag = this.getKeyframesForTag(tag);
                
                if (keyframesForTag.length === 0) {
                    console.warn(`‚ö†Ô∏è No keyframes found for tag "${tag}"`);
                    return;
                }
                
                const filteredFrames = keyframesForTag.filter(kf => 
                    kf.time >= startTimeMs && kf.time <= endTimeMs
                );
                
                if (filteredFrames.length < 2) {
                    console.warn(`‚ö†Ô∏è Need at least 2 keyframes for animation. Found: ${filteredFrames.length}`);
                    return;
                }
                
                const duration = endTimeMs - startTimeMs;
                const startTime = performance.now();
                
                const animate = (currentTime) => {
                    const elapsed = currentTime - startTime;
                    const progress = Math.min(elapsed / duration, 1);
                    
                    for (let i = 0; i < filteredFrames.length - 1; i++) {
                        const current = filteredFrames[i];
                        const next = filteredFrames[i + 1];
                        
                        const segmentStart = (current.time - startTimeMs) / duration;
                        const segmentEnd = (next.time - startTimeMs) / duration;
                        
                        if (progress >= segmentStart && progress <= segmentEnd) {
                            const segmentProgress = (progress - segmentStart) / (segmentEnd - segmentStart);
                            
                            Object.keys(current.properties).forEach(prop => {
                                const startVal = current.properties[prop];
                                const endVal = next.properties[prop];
                                const interpolated = this.interpolateValue(startVal, endVal, segmentProgress, easing);
                                console.log(`üé¨ Animating ${tag}.${prop} = ${interpolated.toFixed(2)}`);
                            });
                        }
                    }
                    
                    if (progress < 1) {
                        requestAnimationFrame(animate);
                    } else {
                        console.log(`‚úÖ Animation complete for tag "${tag}"`);
                    }
                };
                
                requestAnimationFrame(animate);
            },

            getAllTagKeyframes() {
                return this.keyframes;
            },

            clearKeyframesForTag(tag) {
                delete this.keyframes[tag];
                this.saveKeyframes();
                console.log(`üóëÔ∏è Cleared all keyframes for tag "${tag}"`);
            }
        };

        const gameAnimationRuntime = {
            animationInstances: new Map(),
            spriteSheetCache: new Map(),
            loadingCache: new Map(),

            preloadSpriteSheet(animation) {
                if (this.spriteSheetCache.has(animation.id) || this.loadingCache.has(animation.id)) {
                    return Promise.resolve(this.spriteSheetCache.get(animation.id));
                }

                return new Promise((resolve) => {
                    const img = new Image();
                    img.crossOrigin = 'anonymous';
                    img.onload = () => {
                        this.spriteSheetCache.set(animation.id, img);
                        this.loadingCache.delete(animation.id);
                        resolve(img);
                    };
                    img.onerror = () => {
                        console.error(`Failed to load sprite sheet for "${animation.name}"`);
                        this.loadingCache.delete(animation.id);
                        resolve(null);
                    };
                    this.loadingCache.set(animation.id, img);
                    img.src = animation.spriteSheet;
                });
            },

            playAnimationOnTag(animationName, tag, options = {}) {
                const animation = Object.values(AssetManager.assets.animations || []).find(a => a.name === animationName);
                if (!animation) {
                    console.warn(`Animation "${animationName}" not found`);
                    return null;
                }

                const animId = `${tag}-${animationName}-${Date.now()}`;
                
                this.preloadSpriteSheet(animation);
                
                const playFrame = (frameIndex) => {
                    if (PreviewManager.runtime) {
                        const spriteImg = this.spriteSheetCache.get(animation.id);
                        if (spriteImg) {
                            const entities = PreviewManager.runtime.entities.filter(e => 
                                e.tags && e.tags.includes(tag)
                            );
                            
                            entities.forEach(entity => {
                                entity.currentAnimationFrame = {
                                    animation: animation,
                                    frameIndex: frameIndex,
                                    spriteImage: spriteImg
                                };
                            });
                        }
                    }
                };
                
                const animationId = AnimationManager.playAnimation(tag, animationName, {
                    loop: options.loop !== false,
                    duration: options.duration,
                    playbackRate: options.playbackRate || 1,
                    onFrame: playFrame
                });
                
                this.animationInstances.set(animId, animationId);
                return animId;
            },

            stopAnimationOnTag(animationName, tag) {
                const animId = `${tag}-${animationName}`;
                const animationId = this.animationInstances.get(animId);
                if (animationId) {
                    AnimationManager.stopAnimation(animationId);
                    this.animationInstances.delete(animId);
                }
            },

            playAnimationWithKeyframes(animationName, tag, duration, keyframeSetup) {
                KeyframeManager.currentTag = tag;
                KeyframeManager.currentAnimation = animationName;
                
                keyframeSetup();
                
                this.playAnimationOnTag(animationName, tag, { duration });
                
                setTimeout(() => {
                    KeyframeManager.animateKeyframes(tag, 0, duration, 'linear');
                }, 0);
            }
        };

        window.playAnimationOnTag = (name, tag, opts) => gameAnimationRuntime.playAnimationOnTag(name, tag, opts);
        window.stopAnimationOnTag = (name, tag) => gameAnimationRuntime.stopAnimationOnTag(name, tag);
        window.playAnimationWithKeyframes = (name, tag, dur, setup) => gameAnimationRuntime.playAnimationWithKeyframes(name, tag, dur, setup);
        window.createKeyframeForTag = (tag, time) => KeyframeManager.createKeyframeForTag(tag, time);
        window.setKeyframeProperty = (prop, val) => KeyframeManager.setKeyframeProperty(prop, val);
        window.animateKeyframes = (tag, start, end, easing) => KeyframeManager.animateKeyframes(tag, start, end, easing);

        KeyframeManager.init();
        AssetTagSystem.init();
    </script>
</body>
</html>