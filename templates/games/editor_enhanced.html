{% load static %}
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>LupiForge Block Editor</title>
    <link rel="icon" href="data:,">
    <!-- Blockly will be loaded dynamically with fallback support -->
    
    <script>
    // === LUPIFORGE GLOBAL STATE ===
    window.LUPIFORGE = window.LUPIFORGE || {
        isInitialized: false,
        initQueue: [],
        assets: { sprites: [], sounds: [], backgrounds: [], animations: [] },
        gameState: {}
    };

    // === MEMORY MANAGEMENT SYSTEM ===
    class MemoryManager {
        constructor() {
            this.activeAnimations = new Map();
            this.eventListeners = new WeakMap();
            this.assetCache = new LRUCache({ maxSize: 50 });
            this.memoryStats = { lastCleanup: 0, totalCleanups: 0 };
        }
        
        static getInstance() {
            if (!MemoryManager.instance) {
                MemoryManager.instance = new MemoryManager();
                MemoryManager.instance.startMonitoring();
            }
            return MemoryManager.instance;
        }
        
        registerAnimationFrame(id, frameId) {
            this.activeAnimations.set(id, frameId);
        }
        
        cancelAnimation(id) {
            const frameId = this.activeAnimations.get(id);
            if (frameId) {
                cancelAnimationFrame(frameId);
                this.activeAnimations.delete(id);
            }
        }
        
        addEventListener(element, event, handler, options = {}) {
            element.addEventListener(event, handler, options);
            
            const elementHandlers = this.eventListeners.get(element) || new Map();
            if (!elementHandlers.has(event)) {
                elementHandlers.set(event, []);
            }
            elementHandlers.get(event).push(handler);
            this.eventListeners.set(element, elementHandlers);
        }
        
        removeAllListeners(element) {
            const elementHandlers = this.eventListeners.get(element);
            if (elementHandlers) {
                elementHandlers.forEach((handlers, event) => {
                    handlers.forEach(handler => {
                        element.removeEventListener(event, handler);
                    });
                });
                this.eventListeners.delete(element);
            }
        }
        
        cleanupAssets() {
            const now = Date.now();
            const processedKeys = new Set();
            let cleanedCount = 0;
            
            Object.keys(localStorage).forEach(key => {
                if (!key.startsWith('lupiforge_asset_') || processedKeys.has(key)) return;
                
                try {
                    const asset = JSON.parse(localStorage.getItem(key));
                    if (!asset.uploadedAt) {
                        localStorage.removeItem(key);
                        cleanedCount++;
                        processedKeys.add(key);
                        return;
                    }
                    
                    const assetAge = now - new Date(asset.uploadedAt).getTime();
                    if (assetAge > 30 * 24 * 60 * 60 * 1000) {
                        localStorage.removeItem(key);
                        console.log(`üßπ Cleaned up old asset: ${key}`);
                        cleanedCount++;
                    }
                } catch (e) {
                    console.warn(`‚ö†Ô∏è Error processing asset ${key}:`, e.message);
                    try {
                        localStorage.removeItem(key);
                        cleanedCount++;
                    } catch (removeError) {
                        console.error(`Failed to remove corrupted asset ${key}:`, removeError.message);
                    }
                } finally {
                    processedKeys.add(key);
                }
            });
            
            this.activeAnimations.forEach((frameId, id) => {
                try {
                    cancelAnimationFrame(frameId);
                    this.activeAnimations.delete(id);
                } catch (e) {
                    console.warn(`Failed to cancel animation ${id}:`, e.message);
                }
            });
            
            const activeAssetIds = new Set();
            if (window.AssetManager?.assets) {
                Object.values(window.AssetManager.assets).forEach(typeAssets => {
                    if (Array.isArray(typeAssets)) {
                        typeAssets.forEach(asset => {
                            if (asset && asset.id) activeAssetIds.add(asset.id);
                        });
                    }
                });
            }
            
            this.assetCache.keys().forEach(id => {
                if (!activeAssetIds.has(id)) {
                    this.assetCache.delete(id);
                }
            });
            
            this.memoryStats.lastCleanup = now;
            this.memoryStats.totalCleanups++;
            console.log(`‚úÖ Memory cleanup completed. Cleaned ${cleanedCount} assets. Total cleanups: ${this.memoryStats.totalCleanups}`);
        }
        
        startMonitoring() {
            setInterval(() => {
                if (performance.memory && performance.memory.usedJSHeapSize > 300 * 1024 * 1024) {
                    console.warn('‚ö†Ô∏è MemoryWarning: Memory usage high, triggering cleanup');
                    this.cleanupAssets();
                }
            }, 300000);
            
            document.addEventListener('visibilitychange', () => {
                if (document.hidden) {
                    console.log('üìÑ Page hidden - performing cleanup');
                    this.cleanupAssets();
                }
            });
        }
    }

    class LRUCache {
        constructor(options = {}) {
            this.maxSize = options.maxSize || 10;
            this.cache = new Map();
        }
        
        get(key) {
            const item = this.cache.get(key);
            if (item) {
                this.cache.delete(key);
                this.cache.set(key, item);
                return item.value;
            }
            return undefined;
        }
        
        set(key, value) {
            if (this.cache.has(key)) {
                this.cache.delete(key);
            } else if (this.cache.size >= this.maxSize) {
                this.cache.delete(this.cache.keys().next().value);
            }
            this.cache.set(key, { value, timestamp: Date.now() });
        }
        
        delete(key) {
            return this.cache.delete(key);
        }
        
        keys() {
            return this.cache.keys();
        }
    }

    // === DEPENDENCY MANAGEMENT SYSTEM ===
    class DependencyManager {
        static dependencies = {
            'ai_suggestion_system': ['/static/js/ai_suggestion_system.js', 'https://cdn.lupiforge.com/js/ai_suggestion_system.js'],
            'mobile_exporter': ['/static/js/mobile_exporter.js', 'https://cdn.lupiforge.com/js/mobile_exporter.js'],
            'asset_tagging_system': ['/static/js/asset_tagging_system.js', 'https://cdn.lupiforge.com/js/asset_tagging_system.js'],
            'state_store': ['/static/js/state_store.js', 'https://cdn.lupiforge.com/js/state_store.js'],
            'level_editor': ['/static/js/LevelEditor.js', '/static/built/LevelEditor.js', 'https://cdn.lupiforge.com/js/LevelEditor.js']
        };
        
        static loaded = new Map();
        static successfulPaths = {};
        
        static async load(name, critical = false) {
            if (this.loaded.has(name)) {
                return this.loaded.get(name);
            }
            
            const paths = this.dependencies[name];
            if (!paths) {
                console.warn(`‚ö†Ô∏è Unknown dependency: ${name}`);
                return this.createStub(name);
            }
            
            const pathList = Array.isArray(paths) ? paths : [paths];
            let lastError = null;
            
            for (const path of pathList) {
                try {
                    console.log(`üì¶ Loading ${name} from ${path}...`);
                    await this.loadScript(path);
                    console.log(`‚úÖ Successfully loaded ${name} from ${path}`);
                    this.successfulPaths[name] = path;
                    this.loaded.set(name, true);
                    return true;
                } catch (error) {
                    lastError = error;
                    console.warn(`‚ö†Ô∏è Failed to load ${name} from ${path}: ${error.message}`);
                }
            }
            
            console.error(`‚ùå All paths failed for ${name}. Last error: ${lastError?.message}`);
            
            if (critical) {
                throw new Error(`Critical dependency failed: ${name}. ${lastError?.message}`);
            }
            
            const stub = this.createStub(name);
            this.loaded.set(name, stub);
            return stub;
        }
        
        static loadScript(url, timeout = 10000) {
            return new Promise((resolve, reject) => {
                const script = document.createElement('script');
                script.src = url;
                script.async = true;
                script.type = 'text/javascript';
                
                const timeoutId = setTimeout(() => {
                    script.onerror = null;
                    script.onload = null;
                    if (script.parentNode) {
                        script.parentNode.removeChild(script);
                    }
                    reject(new Error(`Script load timeout after ${timeout}ms`));
                }, timeout);
                
                script.onload = () => {
                    clearTimeout(timeoutId);
                    resolve();
                };
                
                script.onerror = (error) => {
                    clearTimeout(timeoutId);
                    if (script.parentNode) {
                        script.parentNode.removeChild(script);
                    }
                    reject(new Error(`Script load failed: ${error?.message || 'Unknown error'}`));
                };
                
                document.head.appendChild(script);
            });
        }
        
        static createStub(name) {
            console.warn(`üîß Creating stub for missing dependency: ${name}`);
            
            switch(name) {
                case 'ai_suggestion_system':
                    return class AISuggestionSystem {
                        constructor(workspace) {
                            this.workspace = workspace;
                            console.log('‚ö†Ô∏è Using AI Suggestion System stub - limited functionality');
                        }
                        analyze() { 
                            console.log('AI suggestion system stub - no suggestions available');
                            return [];
                        }
                        scheduleAnalysis() {}
                        analyzeWorkspace() {}
                    };
                
                case 'level_editor':
                    return class LevelEditor {
                        constructor() {
                            console.log('‚ö†Ô∏è Using LevelEditor stub - limited functionality');
                        }
                        init() { 
                            console.warn('LevelEditor stub initialized - import LevelEditor.js for full functionality');
                        }
                        save() { 
                            return { warning: 'Using stub implementation', data: null };
                        }
                        export() {
                            return { warning: 'Using stub implementation', data: null };
                        }
                    };
                
                case 'mobile_exporter':
                    return {
                        init: function() { console.log('‚ö†Ô∏è Mobile Exporter stub initialized'); },
                        export: function() { return { warning: 'Mobile export not available' }; },
                        stub: true
                    };
                
                case 'asset_tagging_system':
                    return {
                        init: function() { console.log('‚ö†Ô∏è Asset Tagging System stub initialized'); },
                        tag: function(asset, tag) { console.warn('Asset tagging not available'); },
                        getTags: function() { return []; },
                        stub: true
                    };
                
                case 'state_store':
                    return {
                        init: function() { console.log('‚ö†Ô∏è State Store stub initialized'); },
                        save: function(key, value) { console.warn('State persistence not available'); },
                        load: function(key) { return null; },
                        stub: true
                    };
                
                default:
                    return {
                        init: function() { console.log(`‚ö†Ô∏è Stub ${name} initialized`); },
                        stub: true,
                        warning: `This is a stub implementation of ${name}`
                    };
            }
        }
    }

    // === SECURITY-FOCUSED GAME RUNTIME ===
    class SecureGameRuntime {
        constructor() {
            this.sandbox = null;
            this.initialized = false;
            this.worker = null;
            this.executionTimeout = 5000;
        }
        
        async initialize(canvas, ctx, code) {
            const sanitizedCode = this.sanitizeUserCode(code);
            
            try {
                if (window.Worker && typeof Worker !== 'undefined') {
                    console.log('üîí Executing code in Web Worker for true isolation');
                    await this.executeInWorker(sanitizedCode, { canvas, ctx });
                } else {
                    console.log('üîí Executing code in iframe sandbox (Worker not available)');
                    this.sandbox = this.createIframeSandbox(canvas, ctx);
                    await this.executeInIframe(sanitizedCode);
                }
                
                this.initialized = true;
                console.log('‚úÖ Game runtime initialized in secure sandbox');
            } catch (error) {
                console.error('‚ùå Sandbox execution failed:', error);
                throw new Error('Game initialization failed due to security constraints');
            }
        }
        
        sanitizeUserCode(code) {
            const dangerousPatterns = [
                /new\s+Function\s*\(/g,
                /eval\s*\(/g,
                /setTimeout\s*\([^,]+,\s*['"`]/g,
                /setInterval\s*\([^,]+,\s*['"`]/g,
                /document\.write/g,
                /localStorage\.setItem/g,
                /indexedDB\.open/g,
                /window\.location/g,
                /parent\./g,
                /top\./g,
                /iframe/g,
                /<script>/g,
                /document\.cookie/g,
                /fetch\s*\(/g,
                /XMLHttpRequest/g
            ];
            
            let sanitized = code;
            dangerousPatterns.forEach(pattern => {
                sanitized = sanitized.replace(pattern, '// SECURITY BLOCKED: $&');
            });
            
            if (/eval|Function|Worker/.test(sanitized)) {
                console.warn('‚ö†Ô∏è Potentially unsafe code pattern detected. Code sanitized.');
            }
            
            return sanitized;
        }
        
        async executeInWorker(code, context = {}) {
            return new Promise((resolve, reject) => {
                try {
                    const workerCode = `
                        self.onmessage = function(e) {
                            try {
                                const context = e.data.context;
                                ${code}
                                self.postMessage({ success: true, message: 'Code executed successfully' });
                            } catch (error) {
                                self.postMessage({ success: false, error: error.message, stack: error.stack });
                            }
                        };
                    `;
                    
                    const blob = new Blob([workerCode], { type: 'application/javascript' });
                    this.worker = new Worker(URL.createObjectURL(blob));
                    
                    this.worker.onmessage = (e) => {
                        if (e.data.success) {
                            console.log(`‚úÖ Worker execution: ${e.data.message}`);
                            resolve(e.data);
                        } else {
                            console.error(`‚ùå Worker execution failed: ${e.data.error}`);
                            reject(new Error(e.data.error));
                        }
                        this.cleanupWorker();
                    };
                    
                    this.worker.onerror = (error) => {
                        console.error(`‚ùå Worker error: ${error.message}`);
                        this.cleanupWorker();
                        reject(new Error(`Worker error: ${error.message}`));
                    };
                    
                    const timeoutId = setTimeout(() => {
                        this.cleanupWorker();
                        reject(new Error(`Code execution timed out after ${this.executionTimeout}ms`));
                    }, this.executionTimeout);
                    
                    this.worker.__timeoutId = timeoutId;
                    this.worker.postMessage({ context });
                } catch (error) {
                    console.error('Failed to create worker:', error);
                    this.cleanupWorker();
                    reject(error);
                }
            });
        }
        
        cleanupWorker() {
            if (this.worker) {
                if (this.worker.__timeoutId) {
                    clearTimeout(this.worker.__timeoutId);
                }
                this.worker.terminate();
                this.worker = null;
            }
        }
        
        createIframeSandbox(canvas, ctx) {
            const iframe = document.createElement('iframe');
            iframe.setAttribute('sandbox', 'allow-scripts');
            iframe.style.display = 'none';
            document.body.appendChild(iframe);
            
            const safeAPI = {
                console: {
                    log: console.log.bind(console),
                    warn: console.warn.bind(console),
                    error: console.error.bind(console)
                },
                requestAnimationFrame: window.requestAnimationFrame.bind(window),
                cancelAnimationFrame: window.cancelAnimationFrame.bind(window),
                Date: Date,
                Math: Math,
                performance: { now: performance.now.bind(performance) }
            };
            
            return {
                window: iframe.contentWindow,
                document: iframe.contentDocument,
                api: safeAPI,
                canvas: canvas,
                context: ctx,
                iframe: iframe,
                cleanup: () => {
                    if (iframe.parentNode) {
                        iframe.parentNode.removeChild(iframe);
                    }
                }
            };
        }
        
        async executeInIframe(code) {
            if (!this.sandbox) {
                throw new Error('Sandbox environment not initialized');
            }
            
            return new Promise((resolve, reject) => {
                const timeoutId = setTimeout(() => {
                    reject(new Error(`Code execution timed out after ${this.executionTimeout}ms`));
                }, this.executionTimeout);
                
                try {
                    const wrappedCode = `
                        (async function() {
                            try {
                                ${code}
                                window.parent.postMessage({ success: true, source: 'sandbox' }, '*');
                            } catch (error) {
                                window.parent.postMessage({ success: false, error: error.message, source: 'sandbox' }, '*');
                            }
                        })();
                    `;
                    
                    const messageHandler = (event) => {
                        if (event.data?.source === 'sandbox') {
                            window.removeEventListener('message', messageHandler);
                            clearTimeout(timeoutId);
                            
                            if (event.data.success) {
                                resolve();
                            } else {
                                reject(new Error(event.data.error));
                            }
                        }
                    };
                    
                    window.addEventListener('message', messageHandler);
                    
                    const script = this.sandbox.document.createElement('script');
                    script.textContent = wrappedCode;
                    this.sandbox.document.body.appendChild(script);
                } catch (error) {
                    clearTimeout(timeoutId);
                    reject(error);
                }
            });
        }
        
        destroy() {
            this.cleanupWorker();
            if (this.sandbox?.cleanup) {
                this.sandbox.cleanup();
            }
            this.initialized = false;
        }
    }

    // === UNIFIED INITIALIZATION FLOW ===
    let workspace = null;
    let initializationAttempts = 0;
    const MAX_INIT_ATTEMPTS = 5;

    async function loadDependencies() {
        try {
            await Promise.all([
                DependencyManager.load('ai_suggestion_system'),
                DependencyManager.load('asset_tagging_system'),
                DependencyManager.load('state_store')
            ]);
            console.log('‚úÖ All critical dependencies loaded');
        } catch (error) {
            console.error('‚ö†Ô∏è Some dependencies failed:', error);
        }
    }

    async function initializeCoreComponents() {
        console.log('üîß Initializing core components...');
        
        if (window.EnhancedTerminalManager) {
            window.EnhancedTerminalManager.setupEditor();
            console.log('  ‚úÖ Terminal manager initialized');
        }
        
        if (window.EnhancedAssetManager) {
            window.EnhancedAssetManager.init();
            console.log('  ‚úÖ Asset manager initialized');
        }
    }

    async function initializeLupiForge() {
        if (window.LUPIFORGE.isInitialized) return;
        
        try {
            console.log('üöÄ === LUPIFORGE INITIALIZATION SEQUENCE ===');
            
            // CRITICAL: Load Blockly FIRST before anything else
            console.log('üì¶ Loading Blockly dependencies...');
            const blocklyLoaded = await loadBlocklyDependencies();
            if (!blocklyLoaded) {
                throw new Error('Failed to load Blockly dependencies');
            }
            
            console.log('üì¶ Loading other dependencies...');
            await loadDependencies();
            
            console.log('üéÆ Initializing Blockly editor...');
            initializeEditor();
            
            await initializeCoreComponents();
            
            window.LUPIFORGE.isInitialized = true;
            console.log('‚úÖ LupiForge fully initialized');
            
            window.LUPIFORGE.initQueue.forEach(fn => fn());
            window.LUPIFORGE.initQueue = [];
            
        } catch (error) {
            console.error('‚ùå Initialization error:', error);
            showFatalError(`Initialization failed: ${error.message}`);
        }
    }

    // === CRITICAL FIX: PROPER BLOCKLY INITIALIZATION ===
    function initializeEditor() {
        // Wait for DOM to be fully loaded
        if (document.readyState !== 'complete') {
            setTimeout(initializeEditor, 100);
            return;
        }

        const blocklyDiv = document.getElementById('blocklyDiv');
        const toolbox = document.getElementById('toolbox');
        
        if (!blocklyDiv) {
            console.error('‚ùå blocklyDiv not found!');
            return;
        }
        
        if (!toolbox) {
            console.error('‚ùå toolbox not found!');
            return;
        }

        if (typeof Blockly === 'undefined') {
            console.error('‚ùå Blockly is not defined. Dependencies may have failed to load.');
            setTimeout(initializeEditor, 500);
            return;
        }

        if (typeof Blockly.inject !== 'function') {
            console.error('‚ùå Blockly.inject is not a function. Initialization cannot proceed.');
            return;
        }

        if (typeof Blockly.Blocks === 'undefined' || typeof Blockly.JavaScript === 'undefined') {
            console.error('‚ùå Blockly.Blocks or Blockly.JavaScript is undefined. Required components are missing.');
            setTimeout(initializeEditor, 500);
            return;
        }

        // Ensure blocklyDiv has proper dimensions
        blocklyDiv.style.height = '100%';
        blocklyDiv.style.width = '100%';

        try {
            // FIRST: Define custom blocks before creating workspace
            console.log('üì¶ Defining custom blocks...');
            if (typeof defineCustomBlocks === 'function') {
                defineCustomBlocks();
            } else {
                console.warn('‚ö†Ô∏è defineCustomBlocks function not found');
            }

            // Initialize Blockly workspace
            workspace = Blockly.inject('blocklyDiv', {
                toolbox: toolbox,
                zoom: { controls: true, wheel: true, startScale: 1.0, maxScale: 3, minScale: 0.3 },
                trashcan: true,
                scrollbars: true
            });
            
            // Also set on window for compatibility
            window.workspace = workspace;

            // Force register all blocks NOW (they're defined later in the second script)
            setTimeout(() => {
                console.log('‚è∞ Attempting to load custom block definitions from second script...');
                forceLoadAllBlockDefinitions();
            }, 500);

            // Setup event listeners immediately after workspace is ready
            setupEventListeners();
            
            // Initialize subsystems after workspace is ready
            initializeSubsystems();

            // Load project AFTER workspace is ready
            // First try to load from server if game_id is provided
            loadGameFromServer().then(loaded => {
                if (!loaded) {
                    // If no server game, load from localStorage
                    loadProject();
                }
                
                if (workspace.getAllBlocks(false).length === 0) {
                    addStarterBlock();
                }
                
                // Dispatch workspaceReady event to initialize dependent systems
                document.dispatchEvent(new Event('workspaceReady'));
                console.log('‚úÖ Editor initialized successfully');
            }).catch(error => {
                console.error('Error during game load:', error);
                // Fallback to local load
                loadProject();
                if (workspace.getAllBlocks(false).length === 0) {
                    addStarterBlock();
                }
                document.dispatchEvent(new Event('workspaceReady'));
                console.log('‚úÖ Editor initialized successfully (with fallback)');
            });
            
        } catch (error) {
            console.error('‚ùå Editor initialization failed:', error);
        }
    }

    // === HELPER: Force Load Block Definitions ===
    function forceLoadAllBlockDefinitions() {
        console.log('üîÑ Force loading all block definitions...');
        
        // Check if required block types exist, create fallbacks if missing
        const requiredBlockTypes = [
            'on_game_start', 'on_key_press', 'spawn_sprite', 'move_player', 
            'destroy_sprite', 'add_score', 'get_mouse_x', 'get_mouse_y'
        ];
        
        requiredBlockTypes.forEach(type => {
            if (!Blockly.Blocks[type]) {
                console.warn(`‚ö†Ô∏è Missing block definition: ${type}. Creating fallback.`);
                Blockly.Blocks[type] = {
                    init: function() {
                        this.appendDummyInput().appendField(`[MISSING BLOCK: ${type}]`);
                        this.setColour("#ff0000");
                        this.setTooltip(`This block is missing in the current configuration`);
                    }
                };
                Blockly.JavaScript.forBlock[type] = function(block) {
                    return `// Missing block: ${type}`;
                };
            }
        });
    }

    function showFatalError(message) {
        const errorDiv = document.createElement('div');
        errorDiv.style.cssText = `
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: #e74c3c;
            color: white;
            padding: 30px;
            border-radius: 10px;
            z-index: 99999;
            max-width: 500px;
            text-align: center;
            box-shadow: 0 10px 40px rgba(0,0,0,0.5);
        `;
        errorDiv.innerHTML = `
            <h2 style="margin: 0 0 15px 0;">‚ö†Ô∏è Initialization Failed</h2>
            <p style="margin: 0 0 20px 0;">${message}</p>
            <button onclick="window.location.reload()" style="
                background: white;
                color: #e74c3c;
                border: none;
                padding: 12px 30px;
                border-radius: 5px;
                cursor: pointer;
                font-weight: bold;
                font-size: 16px;
            ">Reload Page</button>
        `;
        document.body.appendChild(errorDiv);
    }

    function registerFallbackBlocks() {
        const requiredBlockTypes = [
            'on_game_start', 'spawn_sprite', 'on_key_press', 'on_collision',
            'move_player', 'set_entity_position', 'ui_button', 'ui_text'
        ];
        
        requiredBlockTypes.forEach(type => {
            if (!Blockly.Blocks[type]) {
                console.warn(`‚ö†Ô∏è Missing block definition: ${type}. Creating fallback.`);
                Blockly.Blocks[type] = {
                    init: function() {
                        this.appendDummyInput()
                            .appendField(`[MISSING BLOCK: ${type}]`);
                        this.setColour("#ff0000");
                        this.setTooltip(`This block is missing in the current configuration`);
                    }
                };
                
                Blockly.JavaScript.forBlock[type] = function(block) {
                    return `// Missing block: ${type}\n`;
                };
            }
        });
    }

    function addStarterBlock() {
        try {
            const xml = Blockly.utils.xml.textToDom(
                '<xml><block type="on_game_start" x="50" y="50"></block></xml>'
            );
            Blockly.Xml.domToWorkspace(xml, workspace);
            console.log('‚úÖ Added starter block');
        } catch (error) {
            console.warn('Could not add starter block:', error);
        }
    }

    // === CRITICAL FIX 2: SAFE SUBSYSTEM INITIALIZATION ===
    function initializeSubsystems() {
        console.log('üì¶ Initializing subsystems...');
        
        const subsystems = [
            {
                name: 'EnhancedAssetManager',
                init: () => {
                    if (typeof EnhancedAssetManager !== 'undefined' && EnhancedAssetManager.init) {
                        EnhancedAssetManager.init();
                        window.AssetManager = EnhancedAssetManager;
                        return true;
                    }
                    return false;
                }
            },
            {
                name: 'AssetTagSystem',
                init: () => {
                    if (typeof AssetTagSystem !== 'undefined' && AssetTagSystem.init) {
                        AssetTagSystem.init();
                        return true;
                    }
                    return false;
                }
            },
            {
                name: 'EnhancedTerminalManager',
                init: () => {
                    if (typeof EnhancedTerminalManager !== 'undefined' && EnhancedTerminalManager.init) {
                        EnhancedTerminalManager.init();
                        window.TerminalManager = EnhancedTerminalManager;
                        return true;
                    }
                    return false;
                }
            },
            {
                name: 'EnhancedPreviewManager',
                init: () => {
                    if (typeof EnhancedPreviewManager !== 'undefined' && EnhancedPreviewManager.init) {
                        EnhancedPreviewManager.init();
                        window.PreviewManager = EnhancedPreviewManager;
                        return true;
                    }
                    return false;
                }
            },
            {
                name: 'AutosaveManager',
                init: () => {
                    if (typeof AutosaveManager !== 'undefined' && AutosaveManager.init) {
                        AutosaveManager.init();
                        return true;
                    }
                    return false;
                }
            },
            {
                name: 'EnhancedDebugConsole',
                init: () => {
                    if (typeof EnhancedDebugConsole !== 'undefined' && EnhancedDebugConsole.init) {
                        EnhancedDebugConsole.init();
                        window.DebugConsole = EnhancedDebugConsole;
                        return true;
                    }
                    return false;
                }
            },
            {
                name: 'AchievementManager',
                init: () => {
                    if (typeof AchievementManager !== 'undefined' && AchievementManager.load) {
                        AchievementManager.load();
                        return true;
                    }
                    return false;
                }
            },
            {
                name: 'ScoreManager',
                init: () => {
                    if (typeof ScoreManager !== 'undefined' && ScoreManager.init) {
                        ScoreManager.init();
                        return true;
                    }
                    return false;
                }
            },
            {
                name: 'LeaderboardManager',
                init: () => {
                    if (typeof LeaderboardManager !== 'undefined' && LeaderboardManager.init) {
                        LeaderboardManager.init();
                        return true;
                    }
                    return false;
                }
            },
            {
                name: 'DashboardManager',
                init: () => {
                    if (typeof DashboardManager !== 'undefined' && DashboardManager.init) {
                        DashboardManager.init();
                        return true;
                    }
                    return false;
                }
            },
            {
                name: 'ModerationManager',
                init: () => {
                    if (typeof ModerationManager !== 'undefined' && ModerationManager.init) {
                        ModerationManager.init();
                        return true;
                    }
                    return false;
                }
            },
            {
                name: 'SettingsManager',
                init: () => {
                    if (typeof SettingsManager !== 'undefined' && SettingsManager.init) {
                        SettingsManager.init();
                        return true;
                    }
                    return false;
                }
            },
            {
                name: 'KeyframeManager',
                init: () => {
                    if (typeof KeyframeManager !== 'undefined' && KeyframeManager.init) {
                        KeyframeManager.init();
                        return true;
                    }
                    return false;
                }
            },
            {
                name: 'AI Suggestion System',
                init: () => {
                    try {
                        if (typeof AISuggestionSystem !== 'undefined' && workspace) {
                            window.aiSuggestionSystem = new AISuggestionSystem(workspace);
                            return true;
                        }
                    } catch (error) {
                        console.warn('AI Suggestion System failed:', error);
                    }
                    return false;
                }
            },
            {
                name: 'LupiScript',
                init: () => {
                    try {
                        if (typeof LupiScript !== 'undefined' && LupiScript.loadSavedBlocks) {
                            LupiScript.loadSavedBlocks();
                            return true;
                        }
                    } catch (error) {
                        console.warn('LupiScript initialization failed:', error);
                    }
                    return false;
                }
            }
        ];
        
        let successCount = 0;
        let failCount = 0;
        
        subsystems.forEach(subsystem => {
            try {
                const success = subsystem.init();
                if (success) {
                    console.log(`  ‚úÖ ${subsystem.name}`);
                    successCount++;
                } else {
                    console.warn(`  ‚ö†Ô∏è ${subsystem.name} (not available)`);
                    failCount++;
                }
            } catch (error) {
                console.error(`  ‚ùå ${subsystem.name} failed:`, error);
                failCount++;
            }
        });
        
        console.log(`\n‚úÖ Initialized ${successCount}/${subsystems.length} subsystems`);
        if (failCount > 0) {
            console.warn(`‚ö†Ô∏è ${failCount} subsystems unavailable or failed`);
        }
        
        // Setup event listeners after all systems are initialized
        setupEventListeners();
    }

    // === CRITICAL FIX 3: SAFE EVENT LISTENER SETUP ===
    function setupEventListeners() {
        console.log('üîó Setting up event listeners...');
        
        // Safe button binding helper
        const bindButton = (id, handler, description) => {
            const button = document.getElementById(id);
            if (button) {
                button.addEventListener('click', handler);
                console.log(`  ‚úÖ Bound ${description}`);
                return true;
            } else {
                console.warn(`  ‚ö†Ô∏è Button not found: ${id}`);
                return false;
            }
        };
        
        // Core editor buttons
        bindButton('saveBtn', saveProject, 'Save button');
        bindButton('clearBtn', clearProject, 'Clear button');
        bindButton('quickPreviewBtn', () => {
            if (window.PreviewManager && PreviewManager.play) {
                PreviewManager.play();
            } else {
                showToast('‚ö†Ô∏è Preview system not ready', true);
            }
        }, 'Quick Preview button');
        bindButton('publishBtn', preparePublish, 'Publish button');
        bindButton('terminalBtn', () => {
            if (window.TerminalManager && TerminalManager.toggle) {
                TerminalManager.toggle();
            }
        }, 'Terminal button');
        bindButton('aiSuggestionsBtn', () => {
            if (window.aiSuggestionSystem) {
                window.aiSuggestionSystem.analyzeWorkspace();
                const btn = document.getElementById('aiSuggestionsBtn');
                btn.classList.toggle('active');
            } else {
                showToast('‚ö†Ô∏è AI Suggestion System not initialized', true);
            }
        }, 'AI Suggestions button');
        
        bindButton('lupiScriptBtn', () => {
            console.log('üß± LupiScript button clicked');
            if (typeof window.toggleLupiScript === 'function') {
                window.toggleLupiScript();
            } else {
                // Fallback inline toggle
                const panel = document.getElementById('lupiScriptPanel');
                const btn = document.getElementById('lupiScriptBtn');
                if (panel) {
                    const isVisible = panel.style.display !== 'none';
                    panel.style.display = isVisible ? 'none' : 'block';
                    if (btn) {
                        btn.classList.toggle('active', !isVisible);
                    }
                    console.log(`üß± LupiScript toggled ${isVisible ? 'off' : 'on'} (fallback)`);
                } else {
                    console.error('‚ùå LupiScript panel not found in DOM');
                }
            }
        }, 'LupiScript button');
        
        // Modal buttons
        bindButton('cancelPublish', () => {
            document.getElementById('publishModal')?.classList.remove('show');
        }, 'Cancel Publish');
        bindButton('confirmPublish', publishGame, 'Confirm Publish');
        
        // Auto-save on workspace changes (with debouncing)
        if (workspace) {
            let saveTimeout;
            workspace.addChangeListener((event) => {
                if (event.type === Blockly.Events.UI) return;
                clearTimeout(saveTimeout);
                saveTimeout = setTimeout(() => {
                    if (workspace.getAllBlocks(false).length > 0) {
                        saveProject();
                    }
                }, 2000);
                
                // Trigger AI suggestions on block changes
                if ((event.type === Blockly.Events.BLOCK_CREATE || 
                     event.type === Blockly.Events.BLOCK_DELETE ||
                     event.type === Blockly.Events.CHANGE) &&
                    window.aiSuggestionSystem) {
                    window.aiSuggestionSystem.scheduleAnalysis();
                }
            });
            console.log('  ‚úÖ Auto-save listener attached');
            console.log('  ‚úÖ AI Suggestion listener attached');
        }
        
        // Auto-save interval (every 30 seconds)
        setInterval(() => {
            if (workspace && workspace.getAllBlocks(false).length > 0) {
                saveProject();
            }
        }, 30000);
        console.log('  ‚úÖ Auto-save interval set');
        
        console.log('‚úÖ Event listeners setup complete');
    }

    // === CRITICAL FIX 4: RESOLVE ASSET MANAGER CONFLICTS ===
    // Ensure only ONE AssetManager exists
    if (typeof EnhancedAssetManager !== 'undefined') {
        window.AssetManager = EnhancedAssetManager;
        console.log('‚úÖ AssetManager set to EnhancedAssetManager');
    } else if (typeof AssetManager === 'undefined') {
        // Create minimal fallback AssetManager
        window.AssetManager = {
            assets: { sprites: [], sounds: [], backgrounds: [], animations: [] },
            currentType: 'sprites',
            backgroundAsset: null,
            init: function() {
                console.warn('‚ö†Ô∏è Using fallback AssetManager');
            },
            render: function() {},
            saveAssets: function() {},
            loadAssets: function() {}
        };
        console.warn('‚ö†Ô∏è Created fallback AssetManager');
    }

    // Ensure these are aliased correctly
    window.DebugConsole = window.EnhancedDebugConsole || window.DebugConsole || {
        log: console.log.bind(console),
        warn: console.warn.bind(console),
        error: console.error.bind(console),
        clear: () => console.clear()
    };

    window.TerminalManager = window.EnhancedTerminalManager || window.TerminalManager;
    window.PreviewManager = window.EnhancedPreviewManager || window.PreviewManager;

    // === CRITICAL FIX 5: ESSENTIAL HELPER FUNCTIONS ===
    function showToast(message, isError = false) {
        const toast = document.getElementById('toast');
        if (!toast) {
            console.log(`Toast: ${message}`);
            return;
        }
        toast.textContent = message;
        toast.className = 'toast show' + (isError ? ' error' : '');
        setTimeout(() => toast.classList.remove('show'), 3000);
    }

    function getProjectData() {
        if (!workspace) {
            console.error('Workspace not initialized');
            return null;
        }
        
        const projectName = document.getElementById('projectName')?.value.trim() || 'Untitled Game';
        const code = Blockly.JavaScript.workspaceToCode(workspace);
        const xml = Blockly.Xml.workspaceToDom(workspace);
        const xmlText = Blockly.Xml.domToText(xml);
        
        return {
            name: projectName,
            gameTitle: projectName,
            version: '1.0.0',
            xml: xmlText,
            code: code,
            blocks: workspace.getAllBlocks(false).map(block => ({
                type: block.type,
                id: block.id
            })),
            settings: {
                gameTitle: projectName,
                version: '1.0.0',
                orientation: 'landscape',
                resolution: { width: 800, height: 600 }
            }
        };
    }

    function saveProject() {
        if (!workspace) {
            console.error('Cannot save: workspace not initialized');
            return;
        }
        
        const projectName = document.getElementById('projectName')?.value.trim() || 'Untitled Game';
        const xml = Blockly.Xml.workspaceToDom(workspace);
        const xmlText = Blockly.Xml.domToText(xml);
        const code = Blockly.JavaScript.workspaceToCode(workspace);
        
        const projectData = {
            name: projectName,
            xml: xmlText,
            code: code,
            timestamp: new Date().toISOString()
        };
        
        const STORAGE_KEY = 'lupiforge_project_' + 
            (window.LUPIFORGE_CURRENT_USER?.id || 'guest');
        
        try {
            localStorage.setItem(STORAGE_KEY, JSON.stringify(projectData));
            updateSaveStatus();
            showToast('‚úÖ Project saved locally');
            console.log('‚úÖ Project saved');
        } catch (error) {
            console.error('Save failed:', error);
            showToast('‚ùå Save failed: ' + error.message, true);
        }
    }

    async function loadGameFromServer() {
        if (!window.LUPIFORGE_GAME_ID) {
            console.log('No game_id provided, skipping server load');
            return false;
        }
        
        try {
            console.log('Loading game from server:', window.LUPIFORGE_GAME_ID);
            const response = await fetch(`/games/api/user/games/?game_id=${window.LUPIFORGE_GAME_ID}`, {
                credentials: 'same-origin',
                headers: { 'Accept': 'application/json' }
            });
            
            if (!response.ok) {
                throw new Error(`Failed to load game: ${response.status}`);
            }
            
            const data = await response.json();
            const game = data.games?.find(g => g.id === window.LUPIFORGE_GAME_ID) || data.game;
            
            if (!game) {
                console.warn('Game not found in response');
                return false;
            }
            
            // Load game title
            const projectNameEl = document.getElementById('projectName');
            if (projectNameEl && game.title) {
                projectNameEl.value = game.title;
            }
            
            // Load workspace XML if available
            if (game.logic_json?.xml && workspace) {
                const xml = Blockly.utils.xml.textToDom(game.logic_json.xml);
                Blockly.Xml.domToWorkspace(xml, workspace);
                console.log('‚úÖ Game loaded from server successfully');
                showToast('üìÇ Game loaded');
                return true;
            }
            
            console.log('Game loaded but no workspace data found');
            return true;
        } catch (error) {
            console.error('Error loading game from server:', error);
            showToast('‚ö†Ô∏è Failed to load game', 'error');
            return false;
        }
    }

    function loadProject() {
        if (!workspace) {
            console.error('Cannot load: workspace not initialized');
            return;
        }
        
        const STORAGE_KEY = 'lupiforge_project_' + 
            (window.LUPIFORGE_CURRENT_USER?.id || 'guest');
        
        const saved = localStorage.getItem(STORAGE_KEY);
        if (saved) {
            try {
                const projectData = JSON.parse(saved);
                const projectNameEl = document.getElementById('projectName');
                if (projectNameEl) {
                    projectNameEl.value = projectData.name;
                }
                
                const xml = Blockly.utils.xml.textToDom(projectData.xml);
                Blockly.Xml.domToWorkspace(xml, workspace);
                
                const savedDate = new Date(projectData.timestamp);
                const statusEl = document.getElementById('saveStatus');
                if (statusEl) {
                    statusEl.textContent = `Loaded from ${savedDate.toLocaleDateString()}`;
                }
                
                console.log('‚úÖ Project loaded');
                showToast('üìÇ Project loaded!');
            } catch (error) {
                console.error('Load failed:', error);
                showToast('‚ùå Failed to load project', true);
            }
        }
    }

    function updateSaveStatus() {
        const status = document.getElementById('saveStatus');
        if (status) {
            const now = new Date();
            status.textContent = `Saved at ${now.toLocaleTimeString()}`;
        }
    }

    function clearProject() {
        if (!workspace) return;
        
        if (confirm('‚ö†Ô∏è Are you sure you want to clear the workspace? This cannot be undone.')) {
            workspace.clear();
            const projectNameEl = document.getElementById('projectName');
            if (projectNameEl) {
                projectNameEl.value = '';
            }
            
            const STORAGE_KEY = 'lupiforge_project_' + 
                (window.LUPIFORGE_CURRENT_USER?.id || 'guest');
            localStorage.removeItem(STORAGE_KEY);
            
            const statusEl = document.getElementById('saveStatus');
            if (statusEl) {
                statusEl.textContent = 'Never saved';
            }
            
            showToast('üóëÔ∏è Workspace cleared');
        }
    }

    function preparePublish() {
        if (!workspace) {
            showToast('‚ùå Editor not ready', true);
            return;
        }
        
        const projectNameEl = document.getElementById('projectName');
        const projectName = projectNameEl?.value.trim();
        
        if (!projectName) {
            showToast('‚ùå Please enter a game title first!', true);
            return;
        }
        
        const blockCount = workspace.getAllBlocks(false).length;
        if (blockCount === 0) {
            showToast('‚ùå Your game needs blocks to publish!', true);
            return;
        }
        
        const modalTitleEl = document.getElementById('modalGameTitle');
        if (modalTitleEl) {
            modalTitleEl.textContent = projectName;
        }
        
        const modal = document.getElementById('publishModal');
        if (modal) {
            modal.classList.add('show');
        }
    }

    function publishGame() {
        const projectData = getProjectData();
        if (!projectData) {
            showToast('‚ùå Cannot publish: no project data', true);
            return;
        }
        
        console.log('üì§ Publishing game:', projectData.name);
        
        // Close modal
        const modal = document.getElementById('publishModal');
        if (modal) {
            modal.classList.remove('show');
        }
        
        showToast('üöÄ Game submitted for review!');
        
        // Check achievement
        if (window.AchievementManager) {
            AchievementManager.check('first_publish');
        }
    }

    // === UNIFIED INITIALIZATION ENTRY POINT ===
    async function startApplication() {
        const memoryManager = MemoryManager.getInstance();
        console.log('‚úÖ Memory manager initialized');

        try {
            // Don't load Blockly here - let initializeLupiForge handle it
            await initializeLupiForge();
            setupCleanupHandlers();
            startPerformanceMonitoring();
        } catch (error) {
            console.error('‚ùå Critical initialization failure:', error);
            showFatalError(`Initialization failed: ${error.message}. Please refresh the page.`);
        }
    }

    function setupCleanupHandlers() {
        window.addEventListener('beforeunload', () => {
            MemoryManager.getInstance().activeAnimations.forEach((_, id) => {
                MemoryManager.getInstance().cancelAnimation(id);
            });
            
            if (window.PreviewManager?.runtime) {
                MemoryManager.getInstance().removeAllListeners(window.PreviewManager.runtime.canvas);
            }
            
            if (typeof saveProject === 'function') {
                saveProject();
            }
            
            console.log('üßπ Cleaned up before page unload');
        });
        
        document.addEventListener('visibilitychange', () => {
            if (document.hidden) {
                console.log('üìÑ Page hidden - performing cleanup');
                MemoryManager.getInstance().cleanupAssets();
            }
        });
    }

    function startPerformanceMonitoring() {
        let lastMemoryCheck = Date.now();
        let frameCount = 0;
        let lastFpsUpdate = Date.now();
        
        function monitorPerformance() {
            frameCount++;
            
            const now = Date.now();
            if (now - lastFpsUpdate >= 1000) {
                const fps = frameCount;
                frameCount = 0;
                lastFpsUpdate = now;
                
                if (fps < 30) {
                    console.warn(`‚ö†Ô∏è Low FPS detected: ${fps}`);
                }
            }
            
            if (now - lastMemoryCheck >= 30000) {
                lastMemoryCheck = now;
                
                if (performance.memory) {
                    const usedMB = Math.round(performance.memory.usedJSHeapSize / 1048576);
                    const totalMB = Math.round(performance.memory.totalJSHeapSize / 1048576);
                    
                    console.log(`üìä Memory usage: ${usedMB}/${totalMB} MB`);
                    
                    if (usedMB > 300) {
                        console.warn('‚ö†Ô∏è MemoryWarning: High memory usage detected, triggering cleanup');
                        MemoryManager.getInstance().cleanupAssets();
                    }
                }
            }
            
            requestAnimationFrame(monitorPerformance);
        }
        
        requestAnimationFrame(monitorPerformance);
    }

    async function loadBlocklyDependencies() {
        // Check if already loaded
        if (typeof Blockly !== 'undefined' && Blockly.inject && Blockly.Blocks && Blockly.JavaScript) {
            console.log('‚úÖ Blockly already loaded');
            return true;
        }

        const dependencies = [
            { url: 'https://unpkg.com/blockly@10.4.3/blockly_compressed.js', name: 'Blockly Core' },
            { url: 'https://unpkg.com/blockly@10.4.3/blocks_compressed.js', name: 'Blockly Blocks' },
            { url: 'https://unpkg.com/blockly@10.4.3/javascript_compressed.js', name: 'Blockly JavaScript Generator' },
            { url: 'https://unpkg.com/blockly@10.4.3/msg/en.js', name: 'Blockly Messages' }
        ];

        // Load scripts sequentially (order matters for Blockly)
        for (const dep of dependencies) {
            try {
                await loadSingleScript(dep.url, dep.name);
            } catch (error) {
                console.error(`‚ùå Failed to load ${dep.name}:`, error);
                throw new Error(`Failed to load ${dep.name} from CDN`);
            }
        }

        // Wait for Blockly to be fully initialized
        await new Promise((resolve, reject) => {
            let attempts = 0;
            const maxAttempts = 50; // 5 seconds
            
            const checkBlockly = () => {
                attempts++;
                if (typeof Blockly !== 'undefined' && 
                    typeof Blockly.inject === 'function' && 
                    typeof Blockly.Blocks !== 'undefined' && 
                    typeof Blockly.JavaScript !== 'undefined') {
                    console.log('‚úÖ All Blockly dependencies loaded and verified');
                    resolve(true);
                } else if (attempts >= maxAttempts) {
                    console.error('‚ùå Blockly verification timeout');
                    reject(new Error('Blockly loaded but components missing'));
                } else {
                    setTimeout(checkBlockly, 100);
                }
            };
            
            checkBlockly();
        });

        return true;
    }

    function loadSingleScript(url, name) {
        return new Promise((resolve, reject) => {
            // Check if script already exists in DOM
            const existingScript = document.querySelector(`script[src="${url}"]`);
            if (existingScript) {
                console.log(`üîÑ Script already in DOM: ${name}`);
                // Wait a bit for it to execute
                setTimeout(resolve, 100);
                return;
            }

            const script = document.createElement('script');
            script.src = url;
            script.async = false;
            script.crossOrigin = 'anonymous';
            
            script.onload = () => {
                console.log(`‚úÖ Loaded ${name}`);
                setTimeout(resolve, 50); // Small delay to let script execute
            };
            
            script.onerror = (error) => {
                console.error(`‚ùå Failed to load ${name} from ${url}`);
                reject(new Error(`Failed to load ${name}`));
            };
            
            document.head.appendChild(script);
        });
    }

    // Start initialization when DOM is ready
    if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', async function() {
            console.log('üöÄ DOM loaded, starting application...');
            
            // Check if mobile and show warning
            checkMobileDevice();
            
            await startApplication();
        });
    } else {
        console.log('üöÄ DOM already loaded, starting application immediately...');
        
        // Check if mobile and show warning
        checkMobileDevice();
        
        startApplication();
    }

    // === MOBILE DEVICE DETECTION ===
    function checkMobileDevice() {
        const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) ||
                        (window.innerWidth <= 768);
        
        if (isMobile) {
            const warning = document.getElementById('mobileWarning');
            if (warning) {
                warning.style.display = 'inline-block';
                warning.style.animation = 'pulse 2s ease-in-out infinite';
            }
            
            // Show a toast notification
            setTimeout(() => {
                if (typeof showToast === 'function') {
                    showToast('üì± Mobile development not recommended - editor may be laggy', true);
                }
            }, 2000);
            
            console.warn('üì± Mobile device detected - performance may be limited');
        }
    }

    // === RESTORE ASSET PANEL FUNCTION ===
    window.restoreAssetPanel = function() {
        const assetPanel = document.getElementById('assetPanel');
        const toggleBtn = document.getElementById('toggleAssets');
        
        if (assetPanel) {
            assetPanel.classList.remove('collapsed');
            console.log('üì¶ Asset panel restored');
            
            if (toggleBtn) {
                toggleBtn.textContent = '‚ñº';
            }
            
            // Trigger Blockly resize
            if (window.workspace) {
                setTimeout(() => {
                    Blockly.svgResize(workspace);
                }, 300);
            }
        }
    };

    // === GLOBAL LUPISCRIPT TOGGLE FUNCTION ===
    window.toggleLupiScript = function() {
        console.log('üß± toggleLupiScript called');
        
        const panel = document.getElementById('lupiScriptPanel');
        const btn = document.getElementById('lupiScriptBtn');
        
        console.log('Panel found:', !!panel, 'Button found:', !!btn);
        
        if (!panel) {
            console.error('‚ùå LupiScript panel not found in DOM');
            // Try to find it with a query selector
            const allDivs = document.querySelectorAll('div[id*="lupi"]');
            console.log('Found divs with "lupi" in id:', Array.from(allDivs).map(d => d.id));
            return;
        }
        
        const currentDisplay = window.getComputedStyle(panel).display;
        const isVisible = currentDisplay !== 'none';
        
        console.log('Current display:', currentDisplay, 'Is visible:', isVisible);
        
        panel.style.display = isVisible ? 'none' : 'block';
        
        if (btn) {
            if (isVisible) {
                btn.classList.remove('active');
            } else {
                btn.classList.add('active');
            }
        }
        
        console.log(`üß± LupiScript panel ${isVisible ? 'closed' : 'opened'}`);
        
        // If opening, focus the editor
        if (!isVisible) {
            setTimeout(() => {
                const editor = document.getElementById('lupiEditor');
                if (editor) {
                    editor.focus();
                }
            }, 100);
        }
    };

    // === BLOCKLY TOOLBOX AUTO-CLOSE ON DRAG ===
    window.setupBlocklyToolboxAutoClose = function() {
        if (!window.workspace) {
            console.warn('‚ö†Ô∏è Workspace not ready for toolbox auto-close');
            setTimeout(() => {
                if (window.workspace) {
                    window.setupBlocklyToolboxAutoClose();
                }
            }, 500);
            return;
        }
        
        console.log('üîß Setting up Blockly toolbox auto-close...');
        
        let isDragging = false;
        
        // Listen for block drag events
        workspace.addChangeListener(function(event) {
            // When drag starts
            if (event.type === Blockly.Events.BLOCK_DRAG && event.isStart) {
                isDragging = true;
                
                // Close the flyout immediately when drag starts
                try {
                    const flyout = workspace.getFlyout && workspace.getFlyout();
                    if (flyout && flyout.isVisible && flyout.isVisible()) {
                        flyout.hide();
                        console.log('üéØ Flyout closed on drag start');
                    }
                    
                    // Clear toolbox selection
                    if (workspace.toolbox_ && workspace.toolbox_.clearSelection) {
                        workspace.toolbox_.clearSelection();
                    }
                } catch (e) {
                    console.warn('‚ö†Ô∏è Error closing flyout:', e);
                }
            }
            
            // When drag ends
            if (event.type === Blockly.Events.BLOCK_DRAG && !event.isStart) {
                isDragging = false;
            }
        });
        
        // Also listen for mouse events to ensure flyout closes
        const blocklyDiv = document.getElementById('blocklyDiv');
        if (blocklyDiv) {
            blocklyDiv.addEventListener('mousedown', function(e) {
                // If clicking on workspace (not toolbox), close flyout
                const isToolboxClick = e.target.closest('.blocklyToolboxDiv') || 
                                      e.target.closest('.blocklyFlyout');
                
                if (!isToolboxClick) {
                    setTimeout(() => {
                        try {
                            const flyout = workspace.getFlyout && workspace.getFlyout();
                            if (flyout && flyout.isVisible && flyout.isVisible()) {
                                flyout.hide();
                                if (workspace.toolbox_ && workspace.toolbox_.clearSelection) {
                                    workspace.toolbox_.clearSelection();
                                }
                            }
                        } catch (e) {
                            // Silent fail
                        }
                    }, 50);
                }
            });
        }
        
        console.log('‚úÖ Toolbox auto-close enabled');
    };

    // === CLICK OUTSIDE TO CLOSE BEHAVIOR ===
    window.setupClickOutsideHandlers = function() {
        console.log('üîß Setting up click-outside handlers...');
        
        // Store references to closeable panels
        const closeablePanels = [
            { 
                panel: () => document.getElementById('lupiScriptPanel'),
                button: () => document.getElementById('lupiScriptBtn'),
                name: 'LupiScript'
            },
            {
                panel: () => document.getElementById('terminalPanel'),
                button: () => document.getElementById('terminalBtn'),
                name: 'Terminal',
                checkVisible: (panel) => panel.classList.contains('show')
            }
        ];
        
        document.addEventListener('click', function(event) {
            closeablePanels.forEach(({ panel: getPanelFn, button: getButtonFn, name, checkVisible }) => {
                const panel = getPanelFn();
                const button = getButtonFn();
                
                if (!panel) return;
                
                // Check if panel is visible
                const isVisible = checkVisible ? 
                    checkVisible(panel) : 
                    (panel.style.display === 'block' || panel.style.display === 'flex');
                
                if (isVisible) {
                    // Check if click is outside panel and button
                    const isOutsidePanel = !panel.contains(event.target);
                    const isOutsideButton = !button || (!button.contains(event.target) && event.target !== button);
                    
                    // Don't close if clicking on Blockly elements
                    const isBlocklyClick = event.target.closest('.blocklyWorkspace') || 
                                          event.target.closest('.blocklyFlyout') ||
                                          event.target.closest('.blocklyToolboxDiv');
                    
                    if (isOutsidePanel && isOutsideButton && !isBlocklyClick) {
                        // Close the panel
                        if (checkVisible) {
                            panel.classList.remove('show');
                        } else {
                            panel.style.display = 'none';
                        }
                        
                        // Remove active state from button
                        if (button) {
                            button.classList.remove('active');
                        }
                        
                        console.log(`üîí ${name} panel closed (click outside)`);
                    }
                }
            });
        });
        
        // ESC key to close panels
        document.addEventListener('keydown', function(event) {
            if (event.key === 'Escape') {
                closeablePanels.forEach(({ panel: getPanelFn, button: getButtonFn, name, checkVisible }) => {
                    const panel = getPanelFn();
                    const button = getButtonFn();
                    
                    if (!panel) return;
                    
                    const isVisible = checkVisible ? 
                        checkVisible(panel) : 
                        (panel.style.display === 'block' || panel.style.display === 'flex');
                    
                    if (isVisible) {
                        if (checkVisible) {
                            panel.classList.remove('show');
                        } else {
                            panel.style.display = 'none';
                        }
                        
                        if (button) {
                            button.classList.remove('active');
                        }
                        
                        console.log(`üîí ${name} panel closed (ESC key)`);
                    }
                });
            }
        });
        
        console.log('‚úÖ Click-outside handlers enabled');
    };
    </script>
    <script>
    // Initialize UX behaviors immediately when DOM is ready
    if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', function() {
            console.log('üéØ DOM ready, initializing click handlers...');
            
            if (typeof setupClickOutsideHandlers === 'function') {
                setupClickOutsideHandlers();
            }
        });
    } else {
        console.log('üéØ DOM already loaded, initializing click handlers immediately...');
        
        if (typeof setupClickOutsideHandlers === 'function') {
            setupClickOutsideHandlers();
        }
    }
    
    // Initialize toolbox behaviors after workspace is ready
    document.addEventListener('workspaceReady', function() {
        console.log('üéØ Workspace ready, initializing toolbox behaviors...');
        
        if (typeof setupBlocklyToolboxAutoClose === 'function') {
            setupBlocklyToolboxAutoClose();
        }
    });
    
    // Fallback: Try to initialize after a delay if workspaceReady doesn't fire
    setTimeout(function() {
        if (window.workspace && typeof setupBlocklyToolboxAutoClose === 'function') {
            setupBlocklyToolboxAutoClose();
        }
    }, 3000);
    </script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            font-family: Arial, sans-serif;
            height: 100vh;
            display: flex;
            flex-direction: column;
            background: #1a1a2e;
        }
        #header {
            background: #16213e;
            color: white;
            padding: 15px 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            box-shadow: 0 2px 10px rgba(0,0,0,0.3);
        }
        #header h1 {
            font-size: 24px;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        #projectName {
            background: #0f3460;
            border: 2px solid #533483;
            color: white;
            padding: 8px 15px;
            border-radius: 5px;
            font-size: 14px;
            width: 250px;
            margin-left: 20px;
        }
        #projectName::placeholder {
            color: #8b92a8;
        }
        .button-group {
            display: flex;
            gap: 10px;
            align-items: center;
        }
        button {
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            transition: all 0.3s ease;
        }
        #saveBtn {
            background: #27ae60;
            color: white;
        }
        #saveBtn:hover {
            background: #229954;
            transform: translateY(-2px);
        }
        #publishBtn {
            background: #e74c3c;
            color: white;
        }
        #publishBtn:hover {
            background: #c0392b;
            transform: translateY(-2px);
        }
        #clearBtn {
            background: #95a5a6;
            color: white;
            padding: 8px 15px;
            font-size: 13px;
        }
        #clearBtn:hover {
            background: #7f8c8d;
        }
        #quickPreviewBtn {
            background: #9b59b6;
            color: white;
        }
        #quickPreviewBtn:hover {
            background: #8e44ad;
            transform: translateY(-2px);
        }
        #terminalBtn {
            background: #1abc9c;
            color: white;
        }
        #terminalBtn:hover {
            background: #16a085;
            transform: translateY(-2px);
        }
        #terminalBtn.active {
            background: #0d5c52;
        }
        #aiSuggestionsBtn {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }
        #aiSuggestionsBtn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
        }
        #aiSuggestionsBtn.active {
            background: linear-gradient(135deg, #764ba2 0%, #667eea 100%);
        }
        #saveStatus {
            font-size: 12px;
            color: #95a5a6;
            font-style: italic;
        }
        #blocklyDiv {
            flex: 1;
            width: 100%;
            height: calc(100vh - 60px);
            background: #f8f9fa;
            position: relative;
            z-index: 1;
            display: block;
            min-height: 300px;
        }
        #blocklyDiv svg {
            display: block !important;
            visibility: visible !important;
            opacity: 1 !important;
        }
        #blocklyDiv svg g {
            display: block !important;
            visibility: visible !important;
            opacity: 1 !important;
        }
        .blocklyToolboxDiv {
            max-height: calc(100vh - 80px) !important;
            overflow-y: auto !important;
            overflow-x: hidden !important;
            height: auto !important;
            display: block !important;
        }
        .blocklyTreeRoot {
            display: flex !important;
            flex-direction: column !important;
        }
        .blocklyToolboxDiv::-webkit-scrollbar {
            width: 8px;
        }
        .blocklyToolboxDiv::-webkit-scrollbar-track {
            background: #f0f0f0;
        }
        .blocklyToolboxDiv::-webkit-scrollbar-thumb {
            background: #533483;
            border-radius: 4px;
        }
        .blocklyToolboxDiv::-webkit-scrollbar-thumb:hover {
            background: #6c4f9c;
        }
        .blocklyToolbox {
            max-height: calc(100vh - 80px) !important;
            overflow-y: auto !important;
        }
        #terminalPanel {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 300px;  /* Account for asset panel width */
            background: #1e1e1e;
            color: #d4d4d4;
            border-top: 2px solid #533483;
            display: none;
            flex-direction: column;
            z-index: 500;
            max-height: 40vh;
            height: 250px;
            transition: all 0.3s ease;
        }
        #terminalPanel.show {
            display: flex;
        }
        #terminalPanel.collapsed {
            height: 35px;
        }
        .terminal-header {
            background: #0d3b3b;
            padding: 10px 15px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid #533483;
            cursor: pointer;
            user-select: none;
        }
        .terminal-header h3 {
            margin: 0;
            font-size: 14px;
            color: white;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .terminal-tabs {
            display: flex;
            background: #0f3460;
            border-bottom: 1px solid #533483;
        }
        .terminal-tab {
            padding: 8px 15px;
            background: #0f3460;
            color: #95a5a6;
            border: none;
            cursor: pointer;
            font-size: 12px;
            border-bottom: 2px solid transparent;
            transition: all 0.3s ease;
        }
        .terminal-tab:hover {
            background: #16213e;
            color: white;
        }
        .terminal-tab.active {
            color: white;
            border-bottom-color: #1abc9c;
            background: #16213e;
        }
        #terminalOutput {
            flex: 1;
            overflow-y: auto;
            padding: 10px 15px;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            white-space: pre-wrap;
            word-break: break-word;
        }
        #terminalInput {
            padding: 10px 15px;
            background: #16213e;
            border-top: 1px solid #533483;
            display: none;
        }
        #terminalInput.show {
            display: block;
        }
        .terminal-input-group {
            display: flex;
            gap: 8px;
        }
        #terminalInputField {
            flex: 1;
            background: #0f3460;
            color: white;
            border: 1px solid #533483;
            padding: 8px 12px;
            border-radius: 3px;
            font-family: 'Courier New', monospace;
            font-size: 12px;
        }
        #terminalInputField:focus {
            outline: none;
            border-color: #1abc9c;
            box-shadow: 0 0 5px rgba(26, 188, 156, 0.3);
        }
        .terminal-button {
            background: #533483;
            color: white;
            border: none;
            padding: 6px 12px;
            border-radius: 3px;
            cursor: pointer;
            font-size: 11px;
            transition: background 0.3s ease;
        }
        .terminal-button:hover {
            background: #1abc9c;
        }
        .terminal-resize-handle {
            height: 3px;
            background: #533483;
            cursor: row-resize;
            transition: background 0.3s ease;
        }
        .terminal-resize-handle:hover {
            background: #1abc9c;
        }
        .terminal-error {
            color: #e74c3c;
        }
        .terminal-warn {
            color: #f39c12;
        }
        .terminal-success {
            color: #27ae60;
        }
        .terminal-info {
            color: #3498db;
        }
        #output {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            background: #1e1e1e;
            color: #d4d4d4;
            padding: 15px;
            max-height: 300px;
            overflow-y: auto;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            border-top: 3px solid #533483;
            display: none;
        }
        #output.show {
            display: block;
        }
        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.7);
            justify-content: center;
            align-items: center;
        }
        .modal.show {
            display: flex;
        }
        .modal-content {
            background: #16213e;
            color: white;
            padding: 30px;
            border-radius: 10px;
            max-width: 500px;
            width: 90%;
            box-shadow: 0 5px 30px rgba(0,0,0,0.5);
        }
        .modal-content h2 {
            margin-bottom: 15px;
            color: #e74c3c;
        }
        .modal-content p {
            margin-bottom: 20px;
            line-height: 1.6;
        }
        .modal-buttons {
            display: flex;
            gap: 10px;
            justify-content: flex-end;
        }
        .toast {
            position: fixed;
            top: 80px;
            right: 20px;
            background: #27ae60;
            color: white;
            padding: 15px 25px;
            border-radius: 5px;
            box-shadow: 0 3px 15px rgba(0,0,0,0.3);
            display: none;
            z-index: 2000;
            animation: slideIn 0.3s ease;
        }
        .toast.show {
            display: block;
        }
        .toast.error {
            background: #e74c3c;
        }
        @keyframes slideIn {
            from {
                transform: translateX(400px);
                opacity: 0;
            }
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }
        
        @keyframes pulse {
            0%, 100% {
                opacity: 1;
            }
            50% {
                opacity: 0.5;
            }
        }
        
        /* Asset Panel Styles */
        .asset-panel {
            position: fixed;
            right: 0;
            top: 60px;
            width: 300px;
            height: calc(100vh - 60px);
            background: #16213e;
            border-left: 2px solid #533483;
            box-shadow: -2px 0 10px rgba(0,0,0,0.3);
            z-index: 100;
            display: flex;
            flex-direction: column;
            transition: transform 0.3s ease;
            overflow: hidden;
        }
        .asset-panel.collapsed {
            transform: translateX(300px);
        }
        
        /* Restore Asset Panel Button (shows when collapsed) */
        .restore-assets-btn {
            position: fixed;
            right: 10px;
            top: 70px;
            background: #533483;
            color: white;
            border: 2px solid #FF6B6B;
            padding: 10px 15px;
            border-radius: 8px 0 0 8px;
            cursor: pointer;
            z-index: 150;
            font-size: 20px;
            box-shadow: -2px 2px 10px rgba(0,0,0,0.5);
            transition: all 0.3s ease;
            opacity: 0;
            pointer-events: none;
            transform: translateX(50px);
        }
        .asset-panel.collapsed ~ .restore-assets-btn {
            opacity: 1;
            pointer-events: all;
            transform: translateX(0);
        }
        .restore-assets-btn:hover {
            background: #FF6B6B;
            transform: translateX(-5px);
        }
        
        .asset-header {
            background: #0f3460;
            padding: 15px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 2px solid #533483;
        }
        .asset-header h3 {
            color: white;
            font-size: 16px;
            margin: 0;
        }
        .toggle-btn {
            background: none;
            border: none;
            color: white;
            font-size: 20px;
            cursor: pointer;
            padding: 5px 10px;
            transition: transform 0.3s ease;
        }
        .asset-panel.collapsed .toggle-btn {
            transform: rotate(180deg);
        }
        .asset-content {
            flex: 1;
            overflow-y: auto !important;
            overflow-x: hidden;
            padding: 15px;
            min-height: 0;
            max-height: 100%;
        }
        .asset-content::-webkit-scrollbar {
            width: 8px;
        }
        .asset-content::-webkit-scrollbar-track {
            background: #0f3460;
        }
        .asset-content::-webkit-scrollbar-thumb {
            background: #533483;
            border-radius: 4px;
        }
        .asset-content::-webkit-scrollbar-thumb:hover {
            background: #6c4f9c;
        }
        .upload-section {
            margin-bottom: 15px;
        }
        .upload-label {
            display: block;
            background: #27ae60;
            color: white;
            padding: 12px;
            border-radius: 5px;
            text-align: center;
            cursor: pointer;
            transition: background 0.3s ease;
        }
        .upload-label:hover {
            background: #229954;
        }
        .asset-tabs {
            display: flex;
            gap: 5px;
            margin-bottom: 15px;
        }
        .asset-tab {
            flex: 1;
            background: #0f3460;
            color: white;
            border: none;
            padding: 8px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 12px;
            transition: background 0.3s ease;
        }
        .asset-tab:hover {
            background: #533483;
        }
        .asset-tab.active {
            background: #533483;
        }
        .asset-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 10px;
        }
        .asset-item {
            background: #0f3460;
            border-radius: 5px;
            padding: 10px;
            position: relative;
            cursor: pointer;
            transition: transform 0.2s ease;
        }
        .asset-item:hover {
            transform: scale(1.05);
        }
        .asset-preview {
            width: 100%;
            height: 80px;
            object-fit: cover;
            border-radius: 5px;
            background: #1a1a2e;
        }
        .asset-name {
            color: white;
            font-size: 11px;
            margin-top: 5px;
            text-align: center;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        .asset-delete {
            position: absolute;
            top: 5px;
            right: 5px;
            background: #e74c3c;
            color: white;
            border: none;
            border-radius: 50%;
            width: 20px;
            height: 20px;
            font-size: 12px;
            cursor: pointer;
            display: none;
        }
        .asset-item:hover .asset-delete {
            display: block;
        }
        #blocklyDiv {
            width: calc(100% - 300px);
            margin-bottom: 0;
            display: block !important;
            visibility: visible !important;
            opacity: 1 !important;
        }
        .asset-panel.collapsed ~ #blocklyDiv {
            width: 100%;
        }
        
        /* Terminal/Debug Console expands when asset panel collapsed */
        .asset-panel.collapsed ~ #terminalPanel,
        .asset-panel.collapsed ~ .debug-overlay,
        .asset-panel.collapsed ~ #lupiScriptPanel,
        .asset-panel.collapsed ~ .debug-console {
            right: 0 !important;
            left: 0;
            width: 100%;
        }
        
        /* Preview Panel Styles */
        .preview-panel {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 300px;
            height: 400px;
            background: #1a1a2e;
            border-top: 3px solid #533483;
            transition: all 0.3s ease;
            z-index: 90;
            display: flex;
            flex-direction: column;
        }
        
        /* Preview panel also expands when asset panel collapsed */
        .asset-panel.collapsed ~ .preview-panel {
            right: 0 !important;
            width: 100%;
        }
        
        .preview-panel.collapsed {
            transform: translateY(400px);
        }
        .preview-header {
            background: #16213e;
            padding: 10px 15px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 2px solid #533483;
        }
        .preview-header h3 {
            color: white;
            font-size: 16px;
            margin: 0;
        }
        .preview-controls {
            display: flex;
            gap: 5px;
        }
        .preview-btn {
            background: #533483;
            color: white;
            border: none;
            padding: 6px 12px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 12px;
            transition: background 0.3s ease;
        }
        .preview-btn:hover:not(:disabled) {
            background: #6c4f9c;
        }
        .preview-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        .preview-content {
            flex: 1;
            display: flex;
            justify-content: center;
            align-items: center;
            position: relative;
            overflow: hidden;
        }
        #gameCanvas {
            border: 2px solid #533483;
            background: #000;
            max-width: 100%;
            max-height: 100%;
        }
        .game-stats {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 10px;
            border-radius: 5px;
            font-size: 12px;
            font-family: monospace;
        }
        .game-stats div {
            margin: 5px 0;
        }
        #blocklyDiv {
            height: calc(100vh - 460px) !important;
            display: block !important;
        }
        .preview-panel.collapsed ~ #blocklyDiv {
            height: calc(100vh - 60px) !important;
        }
        /* Achievement Styles */
        .achievement-overlay {
            position: fixed;
            top: 80px;
            left: 50%;
            transform: translateX(-50%) translateY(-100px);
            z-index: 3000;
            opacity: 0;
            pointer-events: none;
            transition: all 0.5s ease;
        }
        .achievement-overlay.show {
            transform: translateX(-50%) translateY(0);
            opacity: 1;
        }
        .achievement-popup {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 20px 30px;
            border-radius: 10px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.5);
            text-align: center;
            min-width: 300px;
        }
        .achievement-icon {
            font-size: 48px;
            margin-bottom: 10px;
            animation: bounce 0.5s ease;
        }
        @keyframes bounce {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.2); }
        }
        .achievement-popup h2 {
            margin: 10px 0;
            font-size: 20px;
        }
        .achievement-popup p {
            margin: 10px 0;
            font-size: 14px;
        }
        .achievement-points {
            background: rgba(255,255,255,0.2);
            display: inline-block;
            padding: 5px 15px;
            border-radius: 20px;
            margin-top: 10px;
            font-weight: bold;
        }
        .score-display {
            text-align: center;
            margin: 20px 0;
        }
        .score-large {
            font-size: 48px;
            font-weight: bold;
            color: #27ae60;
        }
        /* Notification Styles */


        /* Header Icon Buttons */
        .header-icon-btn {
            background: none;
            border: none;
            font-size: 24px;
            cursor: pointer;
            padding: 5px 10px;
            transition: transform 0.3s ease;
        }
        .header-icon-btn:hover {
            transform: scale(1.2);
        }
        .header-icon-btn.active,
        button.active {
            background: #533483 !important;
            transform: scale(1.1);
        }

        /* Autosave Indicator */
        .autosave-indicator {
            position: fixed;
            top: 70px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(22, 33, 62, 0.95);
            color: white;
            padding: 8px 20px;
            border-radius: 20px;
            font-size: 12px;
            z-index: 2000;
            transition: all 0.3s ease;
            opacity: 0;
            pointer-events: none;
        }
        .autosave-indicator.show {
            opacity: 1;
        }
        .autosave-indicator.saving {
            background: #f39c12;
        }
        .autosave-indicator.saved {
            background: #27ae60;
        }

        /* Debug Console */
        .debug-console {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 300px;
            height: 250px;
            background: #1e1e1e;
            border-top: 2px solid #533483;
            z-index: 95;
            transition: transform 0.3s ease;
            font-family: 'Courier New', monospace;
        }
        .debug-console.collapsed {
            transform: translateY(calc(100% - 40px));
        }
        .debug-header {
            background: #16213e;
            padding: 10px 15px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            color: white;
            font-size: 14px;
            cursor: pointer;
            border-bottom: 1px solid #533483;
        }
        .debug-controls {
            display: flex;
            gap: 5px;
        }
        .debug-btn {
            background: #533483;
            color: white;
            border: none;
            padding: 4px 10px;
            border-radius: 3px;
            cursor: pointer;
            font-size: 12px;
        }
        .debug-btn:hover {
            background: #6c4f9c;
        }
        .debug-output {
            padding: 10px;
            height: calc(100% - 40px);
            overflow-y: auto;
            color: #d4d4d4;
            font-size: 12px;
            line-height: 1.6;
        }
        .debug-log {
            color: #4ec9b0;
        }
        .debug-warn {
            color: #dcdcaa;
        }
        .debug-error {
            color: #f48771;
            font-weight: bold;
        }
        .debug-timestamp {
            color: #858585;
            margin-right: 8px;
        }
        .debug-preview-section {
            padding: 10px;
            border-top: 1px solid #533483;
            background: #0f0f0f;
            max-height: 500px;
            overflow-y: auto;
        }
        #previewSVG {
            cursor: pointer;
        }
        #previewSVG:hover text {
            fill: #00bfff;
        }

        /* Large Modal */
        .large-modal {
            max-width: 800px;
            width: 95%;
        }

        /* Modal Header */
        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 2px solid #533483;
        }
        .modal-header h2 {
            margin: 0;
            color: #e74c3c;
        }
        .close-btn {
            background: none;
            border: none;
            color: white;
            font-size: 24px;
            cursor: pointer;
            padding: 0;
            width: 30px;
            height: 30px;
            line-height: 30px;
            transition: transform 0.3s ease;
        }
        .close-btn:hover {
            transform: rotate(90deg);
        }

        /* Leaderboard Styles */
        .leaderboard-filters {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }
        .filter-btn {
            flex: 1;
            min-width: 120px;
            background: #0f3460;
            color: white;
            border: 2px solid #533483;
            padding: 10px 15px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.3s ease;
        }
        .filter-btn:hover {
            background: #533483;
            transform: translateY(-2px);
        }
        .filter-btn.active {
            background: #533483;
            border-color: #e74c3c;
        }
        .leaderboard-content {
            max-height: 400px;
            overflow-y: auto;
            margin-bottom: 20px;
        }
        .leaderboard-table {
            width: 100%;
            border-collapse: collapse;
        }
        .leaderboard-table thead {
            background: #0f3460;
            position: sticky;
            top: 0;
            z-index: 10;
        }
        .leaderboard-table th {
            padding: 12px;
            text-align: left;
            color: white;
            font-weight: 600;
        }
        .leaderboard-table td {
            padding: 12px;
            border-bottom: 1px solid #0f3460;
            color: white;
        }
        .leaderboard-table tr:hover {
            background: #0f3460;
        }
        .rank-medal {
            font-size: 20px;
        }
        .leaderboard-footer {
            display: flex;
            justify-content: space-around;
            padding: 15px;
            background: #0f3460;
            border-radius: 5px;
            color: white;
        }
        .highlight {
            color: #e74c3c;
            font-weight: bold;
            font-size: 18px;
        }

        .remix-btn {
            background: #9b59b6;
            color: white;
            border: none;
            padding: 6px 15px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 12px;
            margin-left: 10px;
            transition: all 0.3s ease;
        }
        .remix-btn:hover {
            background: #8e44ad;
        }

        /* Dashboard Styles */
        .dashboard-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-bottom: 30px;
        }
        .stat-card {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            padding: 20px;
            border-radius: 10px;
            text-align: center;
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
        }
        .stat-icon {
            font-size: 36px;
            margin-bottom: 10px;
        }
        .stat-label {
            color: rgba(255,255,255,0.8);
            font-size: 12px;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 10px;
        }
        .stat-value {
            color: white;
            font-size: 32px;
            font-weight: bold;
        }
        .dashboard-section {
            background: #0f3460;
            padding: 20px;
            border-radius: 10px;
            margin-bottom: 20px;
        }
        .dashboard-section h3 {
            color: white;
            margin-bottom: 15px;
            font-size: 18px;
        }
        .games-list {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
            gap: 15px;
        }
        .game-card {
            background: #16213e;
            padding: 15px;
            border-radius: 8px;
            border: 2px solid #533483;
            transition: all 0.3s ease;
        }
        .game-card:hover {
            border-color: #e74c3c;
            transform: translateY(-5px);
        }
        .game-title {
            color: white;
            font-weight: bold;
            margin-bottom: 10px;
        }
        .game-stats {
            display: flex;
            justify-content: space-between;
            font-size: 12px;
            color: #95a5a6;
            margin-bottom: 10px;
        }
        .game-status {
            display: inline-block;
            padding: 4px 12px;
            border-radius: 20px;
            font-size: 11px;
            font-weight: bold;
        }
        .status-public {
            background: #27ae60;
            color: white;
        }
        .status-pending {
            background: #f39c12;
            color: white;
        }
        .status-draft {
            background: #95a5a6;
            color: white;
        }
        .revenue-list {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        .revenue-item {
            background: #16213e;
            padding: 15px;
            border-radius: 5px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .revenue-game {
            color: white;
            font-weight: bold;
        }
        .revenue-amount {
            color: #27ae60;
            font-size: 18px;
            font-weight: bold;
        }

        /* Moderation Styles */
        .moderator-only {
            border: 2px solid #e74c3c;
        }
        .moderation-stats {
            display: flex;
            gap: 20px;
            margin-bottom: 20px;
            padding: 15px;
            background: #0f3460;
            border-radius: 5px;
        }
        .mod-stat {
            flex: 1;
            text-align: center;
            color: white;
        }
        .mod-stat-label {
            display: block;
            font-size: 12px;
            color: #95a5a6;
            margin-bottom: 5px;
        }
        .mod-stat-value {
            font-size: 24px;
            font-weight: bold;
            color: #e74c3c;
        }
        .moderation-queue {
            max-height: 500px;
            overflow-y: auto;
        }
        .mod-item {
            background: #0f3460;
            padding: 15px;
            border-radius: 5px;
            margin-bottom: 15px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-left: 4px solid #f39c12;
        }
        .mod-item-info {
            flex: 1;
        }
        .mod-item-title {
            color: white;
            font-weight: bold;
            font-size: 16px;
            margin-bottom: 5px;
        }
        .mod-item-meta {
            color: #95a5a6;
            font-size: 13px;
        }
        .mod-item-actions {
            display: flex;
            gap: 10px;
        }
        .mod-btn {
            padding: 8px 20px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s ease;
        }
        .mod-btn.approve {
            background: #27ae60;
            color: white;
        }
        .mod-btn.approve:hover {
            background: #229954;
        }
        .mod-btn.reject {
            background: #e74c3c;
            color: white;
        }
        .mod-btn.reject:hover {
            background: #c0392b;
        }
        .mod-btn.review {
            background: #3498db;
            color: white;
        }
        .mod-btn.review:hover {
            background: #2980b9;
        }
        .mod-preview-content {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }
        .mod-game-info {
            background: #0f3460;
            padding: 15px;
            border-radius: 5px;
        }
        .mod-game-info h3 {
            color: white;
            margin-bottom: 10px;
        }
        .mod-game-meta {
            color: #95a5a6;
            font-size: 14px;
            display: flex;
            gap: 20px;
        }
        .mod-preview-canvas {
            display: flex;
            justify-content: center;
            background: #000;
            padding: 20px;
            border-radius: 5px;
        }
        #modGameCanvas {
            border: 2px solid #533483;
        }
        .mod-actions {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }
        #modFeedback {
            width: 100%;
            padding: 12px;
            background: #0f3460;
            border: 2px solid #533483;
            border-radius: 5px;
            color: white;
            font-family: Arial, sans-serif;
            resize: vertical;
        }
        .mod-buttons {
            display: flex;
            gap: 10px;
            justify-content: flex-end;
        }




        /* Settings Styles */
        .settings-tabs {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            border-bottom: 2px solid #533483;
            flex-wrap: wrap;
        }
        .settings-tab {
            background: none;
            color: white;
            border: none;
            padding: 12px 20px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.3s ease;
            border-bottom: 3px solid transparent;
        }
        .settings-tab:hover {
            background: #0f3460;
        }
        .settings-tab.active {
            border-bottom-color: #9b59b6;
            color: #9b59b6;
        }
        .settings-tab-content {
            display: none;
            max-height: 500px;
            overflow-y: auto;
        }
        .settings-tab-content.active {
            display: block;
        }
        .settings-section {
            background: #0f3460;
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 20px;
        }
        .settings-section h3 {
            color: white;
            margin-bottom: 15px;
            font-size: 16px;
            border-bottom: 2px solid #533483;
            padding-bottom: 10px;
        }
        .profile-avatar-section {
            display: flex;
            align-items: center;
            gap: 20px;
            margin-bottom: 20px;
        }
        .profile-avatar-large {
            width: 80px;
            height: 80px;
            border-radius: 50%;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 40px;
        }
        .change-avatar-btn {
            background: #9b59b6;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        .change-avatar-btn:hover {
            background: #8e44ad;
        }
        .save-settings-btn {
            width: 100%;
            padding: 12px;
            background: #27ae60;
            color: white;
            border: none;
            border-radius: 5px;
            font-size: 14px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        .save-settings-btn:hover {
            background: #229954;
        }
        .danger-zone {
            border: 2px solid #e74c3c;
        }
        .danger-btn {
            background: #e74c3c;
            color: white;
            border: none;
            padding: 12px 20px;
            border-radius: 5px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s ease;
        }
        .danger-btn:hover {
            background: #c0392b;
        }
        
        /* Level Editor Styles */
        .level-editor-toolbar {
            background: #16213e;
            border-bottom: 2px solid #533483;
            padding: 10px 15px;
            display: flex;
            gap: 15px;
            align-items: center;
            flex-wrap: wrap;
            box-shadow: 0 2px 8px rgba(0,0,0,0.3);
        }
        .tool-selector {
            display: flex;
            gap: 8px;
            border-right: 2px solid #533483;
            padding-right: 15px;
        }
        .tool-selector button {
            background: #0f3460;
            color: white;
            border: 2px solid #533483;
            padding: 8px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 13px;
            transition: all 0.3s ease;
        }
        .tool-selector button:hover {
            background: #533483;
            border-color: #9b59b6;
        }
        .tool-selector button.active {
            background: #9b59b6;
            border-color: #e74c3c;
            color: #fff;
        }
        .tool-options {
            display: flex;
            gap: 10px;
        }
        .tile-palette-selector select,
        .entity-selector select {
            background: #0f3460;
            color: white;
            border: 2px solid #533483;
            padding: 8px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
        }
        .tile-palette-selector select:focus,
        .entity-selector select:focus {
            outline: none;
            border-color: #9b59b6;
            box-shadow: 0 0 5px rgba(155, 89, 182, 0.5);
        }
        .level-controls {
            display: flex;
            gap: 8px;
            border-right: 2px solid #533483;
            padding-right: 15px;
        }
        .level-controls button {
            background: #0f3460;
            color: white;
            border: 2px solid #533483;
            padding: 8px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            transition: all 0.3s ease;
            font-weight: bold;
        }
        .level-controls button:hover {
            background: #533483;
            transform: translateY(-2px);
            box-shadow: 0 2px 8px rgba(0,0,0,0.3);
        }
        .view-controls {
            display: flex;
            gap: 10px;
            align-items: center;
        }
        .view-controls input[type="range"] {
            width: 150px;
        }
        .view-controls span {
            color: white;
            font-size: 12px;
            min-width: 50px;
            text-align: right;
        }
        .tile-palette {
            background: #0f3460;
            border: 2px solid #533483;
            border-radius: 5px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.5);
            z-index: 100;
        }
        .tile-palette h3 {
            color: white;
            margin: 0 0 10px 0;
            font-size: 14px;
            text-align: center;
        }
        .palette-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 5px;
        }
        .palette-tile {
            cursor: pointer;
            transition: transform 0.2s ease;
            border-radius: 3px;
        }
        .palette-tile:hover {
            transform: scale(1.1);
        }
        .level-editor-toast {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background: rgba(39, 174, 96, 0.95);
            color: white;
            padding: 12px 24px;
            border-radius: 5px;
            font-size: 14px;
            font-weight: bold;
            box-shadow: 0 4px 15px rgba(0,0,0,0.3);
            z-index: 1000;
        }
        .level-selector-modal {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.7);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 2000;
        }
        .level-selector-modal .modal-content {
            background: #16213e;
            color: white;
            padding: 30px;
            border-radius: 10px;
            max-width: 500px;
            width: 90%;
            box-shadow: 0 5px 30px rgba(0,0,0,0.5);
        }
        .level-selector-modal h2 {
            margin-bottom: 20px;
            color: #e74c3c;
            font-size: 20px;
        }
        .level-list {
            max-height: 400px;
            overflow-y: auto;
            margin-bottom: 20px;
        }
        .level-item {
            background: #0f3460;
            padding: 15px;
            border-radius: 5px;
            margin-bottom: 10px;
            cursor: pointer;
            transition: all 0.3s ease;
            border: 2px solid #533483;
        }
        .level-item:hover {
            border-color: #9b59b6;
            background: #1a4d7f;
            transform: translateX(5px);
        }
        .level-item h3 {
            margin: 0 0 5px 0;
            color: #e74c3c;
            font-size: 14px;
        }
        .level-item p {
            margin: 0;
            color: #95a5a6;
            font-size: 12px;
        }
        .level-selector-modal button {
            background: #95a5a6;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            font-weight: bold;
            transition: background 0.3s ease;
        }
        .level-selector-modal button:hover {
            background: #7f8c8d;
        }
        #levelEditorCanvas {
            background: #1a1a2e;
            border: 2px solid #533483;
            display: block;
        }
    </style>
        {% if current_user %}
        {{ current_user|json_script:"currentUser" }}
        {% endif %}
        {% if game_id %}
        {{ game_id|json_script:"gameIdData" }}
        {% endif %}
</head>
<body>
<script>
    // Expose current user to frontend safely
    window.LUPIFORGE_CURRENT_USER = {};
    try{
        const el = document.getElementById('currentUser');
        if(el) window.LUPIFORGE_CURRENT_USER = JSON.parse(el.textContent || '{}');
    }catch(e){ window.LUPIFORGE_CURRENT_USER = {}; }
    
    // Expose game_id if editing existing game
    window.LUPIFORGE_GAME_ID = null;
    try{
        const gameIdEl = document.getElementById('gameIdData');
        if(gameIdEl) window.LUPIFORGE_GAME_ID = JSON.parse(gameIdEl.textContent || 'null');
    }catch(e){ window.LUPIFORGE_GAME_ID = null; }
</script>
    <div id="header">
        <div style="display: flex; align-items: center;">
            <h1><svg xmlns="http://www.w3.org/2000/svg" width="28" height="28" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-gamepad2-icon lucide-gamepad-2" style="display: inline-block; vertical-align: middle; margin-right: 8px; color: var(--primary);"><line x1="6" x2="10" y1="11" y2="11"/><line x1="8" x2="8" y1="9" y2="13"/><line x1="15" x2="15.01" y1="12" y2="12"/><line x1="18" x2="18.01" y1="10" y2="10"/><path d="M17.32 5H6.68a4 4 0 0 0-3.978 3.59c-.006.052-.01.101-.017.152C2.604 9.416 2 14.456 2 16a3 3 0 0 0 3 3c1 0 1.5-.5 2-1l1.414-1.414A2 2 0 0 1 9.828 16h4.344a2 2 0 0 1 1.414.586L17 18c.5.5 1 1 2 1a3 3 0 0 0 3-3c0-1.545-.604-6.584-.685-7.258-.007-.05-.011-.1-.017-.151A4 4 0 0 0 17.32 5z"/></svg>LupiForge Block Editor</h1>
            <input type="text" id="projectName" placeholder="My Awesome Game" maxlength="50">
        </div>
        <div class="button-group">
            <button id="moderationBtn" class="header-icon-btn moderator-only" title="Moderation" style="display: none;">üõ°Ô∏è</button>
            <span id="saveStatus">Never saved</span>
            <button id="clearBtn">üóëÔ∏è Clear</button>
            <button id="saveBtn">üíæ Save</button>
            <button id="quickPreviewBtn">üëÅÔ∏è Quick Preview</button>
            <button id="publishBtn">üöÄ Publish</button>
            <button id="terminalBtn">‚å®Ô∏è Terminal</button>
            <button id="aiSuggestionsBtn" title="AI Suggestions">ü§ñ AI Suggestions</button>
            <button id="lupiScriptBtn" title="LupiScript v1 - Create Custom Blocks" onclick="window.toggleLupiScript()">üß± LupiScript</button>
            <span id="mobileWarning" style="display:none; color:#e74c3c; font-size:12px; margin-left:10px;">üì± Mobile development not supported - too laggy</span>
        </div>
    </div>
    <div id="blocklyDiv"></div>
    
    <!-- LupiScript v1 Panel -->
    <div id="lupiScriptPanel" style="display:none; position:fixed; bottom:0; left:0; right:300px; max-height:50vh; overflow:auto; padding:15px; border-top:2px solid #533483; background:#1a1a2e; z-index:1000; box-shadow:0 -4px 20px rgba(0,0,0,0.5); transition:right 0.3s ease;">
        <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:15px;">
            <h3 style="color:#fff; margin:0;">üß± LupiScript v1 - Create Custom Blocks</h3>
            <button onclick="document.getElementById('lupiScriptPanel').style.display='none'" style="background:#e74c3c; color:white; border:none; padding:5px 12px; border-radius:4px; cursor:pointer;">‚úñ Close</button>
        </div>
        
        <div style="display:grid; grid-template-columns:1fr 1fr; gap:15px;">
            <div>
                <label style="display:block; color:#dcdcaa; font-size:12px; margin-bottom:5px; font-weight:bold;">‚úçÔ∏è Write Your Block</label>
                <textarea id="lupiEditor" placeholder='block play_sound "üîä Play [sound] at [volume]%"
  category Audio
  field sound asset:audio
  field volume number 100 min 0 max 100
  code playSound("[sound]", [volume]/100)' style="width:100%; min-height:200px; font-family:'Courier New',monospace; padding:12px; background:#0f3460; color:#fff; border:1px solid #533483; border-radius:4px; font-size:13px; resize:vertical;"></textarea>
                
                <div style="margin-top:10px; display:flex; gap:10px;">
                    <button onclick="LupiScript.submit()" style="flex:1; padding:10px; background:#2ecc71; color:#fff; border:none; border-radius:4px; cursor:pointer; font-weight:bold; font-size:14px;">‚úÖ Create Block</button>
                    <button onclick="document.getElementById('lupiExamples').style.display=document.getElementById('lupiExamples').style.display==='none'?'block':'none'" style="padding:10px 20px; background:#3498db; color:#fff; border:none; border-radius:4px; cursor:pointer;">üìö Examples</button>
                </div>
                
                <div id="lupiExamples" style="display:none; margin-top:10px; padding:10px; background:#0f3460; border-radius:4px; font-size:11px; color:#95a5a6; max-height:150px; overflow:auto;">
                    <strong style="color:#4ec9b0;">Quick Copy Examples:</strong><br><br>
                    <div style="cursor:pointer; padding:5px; margin:5px 0; background:#1a1a2e; border-radius:3px;" onclick="document.getElementById('lupiEditor').value=this.dataset.code" data-code='block jump_entity "‚¨ÜÔ∏è Jump [entity]"
  category Player
  input entity Entity
  code jump([entity])'>
                        <strong style="color:#e74c3c;">Simple:</strong> Jump entity
                    </div>
                    <div style="cursor:pointer; padding:5px; margin:5px 0; background:#1a1a2e; border-radius:3px;" onclick="document.getElementById('lupiEditor').value=this.dataset.code" data-code='block play_sound "üîä Play [sound] at [volume]%"
  category Audio
  field sound asset:audio
  field volume number 100 min 0 max 100
  code playSound("[sound]", [volume]/100)'>
                        <strong style="color:#f39c12;">With Fields:</strong> Play sound with volume
                    </div>
                    <div style="cursor:pointer; padding:5px; margin:5px 0; background:#1a1a2e; border-radius:3px;" onclick="document.getElementById('lupiEditor').value=this.dataset.code" data-code='block move_entity "‚û°Ô∏è Move [entity] right by [pixels]px"
  category Movement
  input entity Entity "Entity to move"
  field pixels number 10 min 1 max 1000
  code setEntityX([entity], getEntityX([entity]) + [pixels])'>
                        <strong style="color:#9b59b6;">With Input:</strong> Move entity
                    </div>
                    <div style="cursor:pointer; padding:5px; margin:5px 0; background:#1a1a2e; border-radius:3px;" onclick="document.getElementById('lupiEditor').value=this.dataset.code" data-code='block is_grounded "üë£ Is [entity] on ground?"
  category Physics
  input entity Entity
  output Boolean
  code isGrounded([entity])'>
                        <strong style="color:#3498db;">Output Block:</strong> Check if grounded
                    </div>
                </div>
            </div>
            
            <div>
                <label style="display:block; color:#dcdcaa; font-size:12px; margin-bottom:5px; font-weight:bold;">üëÅÔ∏è Preview & Status</label>
                <div id="lupiPreview" style="padding:12px; background:#0f3460; border-radius:4px; color:#95a5a6; min-height:120px; margin-bottom:10px; border:1px solid #533483;">
                    <div style="color:#95a5a6; text-align:center; padding:20px;">
                        Your block preview will appear here
                    </div>
                </div>
                
                <div id="lupiStatus" style="padding:10px; background:#0f3460; border-radius:4px; color:#95a5a6; font-size:13px; border:1px solid #533483;">
                    Ready to create blocks...
                </div>
                
                <div style="margin-top:10px; padding:12px; background:#0f3460; border-radius:4px; font-size:11px; color:#95a5a6; border:1px solid #533483;">
                    <strong style="color:#4ec9b0; display:block; margin-bottom:8px;">üìù Syntax Cheatsheet:</strong>
                    <code style="display:block; background:#1a1a2e; padding:8px; border-radius:3px; margin:5px 0;">
                        block <span style="color:#e74c3c;">name</span> "<span style="color:#2ecc71;">Display [field]</span>"<br>
                        &nbsp;&nbsp;category <span style="color:#3498db;">CategoryName</span><br>
                        &nbsp;&nbsp;field <span style="color:#e74c3c;">id</span> <span style="color:#f39c12;">type</span> <span style="color:#9b59b6;">default</span><br>
                        &nbsp;&nbsp;input <span style="color:#e74c3c;">id</span> <span style="color:#f39c12;">Type</span> "<span style="color:#2ecc71;">Label</span>"<br>
                        &nbsp;&nbsp;output <span style="color:#f39c12;">Type</span><br>
                        &nbsp;&nbsp;code <span style="color:#dcdcaa;">yourFunction([field])</span>
                    </code>
                    <div style="margin-top:8px; color:#7f8c8d;">
                        <strong>Field types:</strong> text, number, checkbox, color, choice, asset:audio, asset:sprite, tags:entities
                    </div>
                </div>
            </div>
        </div>
    </div>
    <div id="editor-container"></div>
    <canvas id="levelEditorCanvas" style="display: none;"></canvas>
    <div id="output"></div>
    
    <!-- Terminal Panel -->
    <div id="terminalPanel">
        <div class="terminal-header">
            <h3><span>‚å®Ô∏è</span>Terminal</h3>
            <div style="display: flex; gap: 5px;">
                <button class="terminal-button" id="terminalClear" style="padding: 4px 8px; font-size: 11px;">Clear</button>
                <button class="terminal-button" id="terminalToggle" style="padding: 4px 8px; font-size: 11px;">‚ñº</button>
            </div>
        </div>
        <div class="terminal-tabs">
            <button class="terminal-tab active" data-tab="output">üì§ Output</button>
            <button class="terminal-tab" data-tab="input">‚å®Ô∏è Input</button>
        </div>
        <div id="terminalOutput"></div>
        <div id="terminalInput" onclick="event.stopPropagation()">
            <div style="padding: 12px;">
                <h4 style="color: #4ec9b0; margin-bottom: 10px; font-size: 12px;">üìã Block Structure Builder</h4>
                
                <div style="margin-bottom: 12px;" onclick="event.stopPropagation()">
                    <label style="display: block; color: #dcdcaa; font-size: 11px; margin-bottom: 5px;">JavaScript Code</label>
                    <textarea id="terminalInputField" placeholder="Enter JavaScript code..." style="width: 100%; height: 80px; padding: 8px; background: #0f3460; color: white; border: 1px solid #533483; border-radius: 4px; font-family: monospace; font-size: 11px; resize: vertical;"></textarea>
                </div>
                
                <div style="margin-bottom: 12px;" onclick="event.stopPropagation()">
                    <label style="display: block; color: #dcdcaa; font-size: 11px; margin-bottom: 5px;">CSS Styling (Optional)</label>
                    <textarea id="terminalCSSField" placeholder="Enter CSS styles..." style="width: 100%; height: 60px; padding: 8px; background: #0f3460; color: white; border: 1px solid #533483; border-radius: 4px; font-family: monospace; font-size: 11px; resize: vertical;"></textarea>
                </div>
                
                <div style="margin-bottom: 12px;" onclick="event.stopPropagation()">
                    <label style="display: block; color: #dcdcaa; font-size: 11px; margin-bottom: 5px;">HTML Structure (Optional)</label>
                    <textarea id="terminalHTMLField" placeholder="Enter HTML elements..." style="width: 100%; height: 60px; padding: 8px; background: #0f3460; color: white; border: 1px solid #533483; border-radius: 4px; font-family: monospace; font-size: 11px; resize: vertical;"></textarea>
                </div>
                
                <div style="display: flex; gap: 8px; margin-top: 12px;" onclick="event.stopPropagation()">
                    <button class="terminal-button" id="terminalSubmit" style="flex: 1;">‚úÖ Submit</button>
                    <button class="terminal-button" id="terminalPreview" style="flex: 1;">üëÅÔ∏è Preview</button>
                    <button class="terminal-button" id="terminalClearForms" style="flex: 1; background: #95a5a6;">Clear</button>
                </div>
            </div>
            <div id="terminalInputError" style="padding: 8px 12px; color: #e74c3c; font-size: 11px; display: none; margin-top: 5px;"></div>
        </div>
        
        <!-- Structure Preview Modal -->
        <div id="structurePreviewModal" style="display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: #16213e; border: 2px solid #533483; border-radius: 8px; padding: 20px; max-width: 600px; width: 90%; max-height: 80vh; overflow-y: auto; z-index: 10000;">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
                <h3 style="color: #4ec9b0; margin: 0; font-size: 16px;">üèóÔ∏è Block Structure Preview</h3>
                <button onclick="document.getElementById('structurePreviewModal').style.display='none'" style="background: #e74c3c; color: white; border: none; border-radius: 4px; padding: 5px 10px; cursor: pointer; font-weight: bold;">√ó</button>
            </div>
            <div id="previewContent" style="background: #0f3460; padding: 15px; border-radius: 4px; font-family: monospace; font-size: 12px; color: #4ec9b0; max-height: 400px; overflow-y: auto; white-space: pre-wrap; word-break: break-all;"></div>
            <div style="display: flex; gap: 10px; margin-top: 15px;">
                <button onclick="document.getElementById('structurePreviewModal').style.display='none'" class="terminal-button" style="flex: 1;">Close</button>
                <button id="previewConvertBtn" class="terminal-button" style="flex: 1; background: #27ae60;">Convert to Blocks</button>
            </div>
        </div>
        <div class="terminal-resize-handle"></div>
    </div>

    <!-- Publish Modal -->
    <div id="publishModal" class="modal">
        <div class="modal-content">
            <h2>üöÄ Publish Game</h2>
            <p><strong>Game Title:</strong> <span id="modalGameTitle"></span></p>
            <p>Your game will be submitted to moderators for approval. Once approved, it will be visible to all players!</p>
            <p><strong>Ready to publish?</strong></p>
            <div class="modal-buttons">
                <button id="cancelPublish" style="background: #95a5a6;">Cancel</button>
                <button id="confirmPublish" style="background: #e74c3c;">Publish Now</button>
            </div>
        </div>
    </div>

    <!-- Mobile Export Modal -->
    <div id="mobileExportModal" class="modal">
        <div class="modal-content" style="max-width: 600px;">
            <h2>üì± Export to Mobile</h2>
            <div style="margin: 20px 0;">
                <div style="margin-bottom: 20px;">
                    <label style="display: block; margin-bottom: 8px; font-weight: bold;">Select Platform</label>
                    <div style="display: flex; gap: 10px;">
                        <button id="platformAndroid" style="flex: 1; padding: 12px; background: #3498db; color: white; border: 2px solid #3498db; border-radius: 5px; cursor: pointer; font-weight: bold; transition: all 0.3s;">ü§ñ Android (.apk)</button>
                        <button id="platformIOS" style="flex: 1; padding: 12px; background: #95a5a6; color: white; border: 2px solid #95a5a6; border-radius: 5px; cursor: pointer; font-weight: bold; transition: all 0.3s;">üçé iOS (.ipa)</button>
                    </div>
                </div>
                <div style="margin-bottom: 20px;">
                    <label style="display: block; margin-bottom: 8px; font-weight: bold;">Export Options</label>
                    <div style="background: #0f3460; padding: 15px; border-radius: 5px;">
                        <label style="display: flex; align-items: center; margin-bottom: 10px; cursor: pointer;">
                            <input type="checkbox" id="optimizeCode" checked style="margin-right: 10px; width: 16px; height: 16px;">
                            <span>Optimize Code</span>
                        </label>
                        <label style="display: flex; align-items: center; margin-bottom: 10px; cursor: pointer;">
                            <input type="checkbox" id="includeDebug" style="margin-right: 10px; width: 16px; height: 16px;">
                            <span>Include Debug Symbols</span>
                        </label>
                        <label style="display: flex; align-items: center; cursor: pointer;">
                            <input type="checkbox" id="enableMultiTouch" checked style="margin-right: 10px; width: 16px; height: 16px;">
                            <span>Enable Multi-Touch</span>
                        </label>
                    </div>
                </div>
                <div style="margin-bottom: 20px;">
                    <label style="display: block; margin-bottom: 8px; font-weight: bold;">Orientation</label>
                    <select id="exportOrientation" style="width: 100%; padding: 8px; background: #0f3460; color: white; border: 1px solid #533483; border-radius: 5px;">
                        <option value="landscape">üîÑ Landscape</option>
                        <option value="portrait">üì± Portrait</option>
                    </select>
                </div>
            </div>
            <div class="modal-buttons">
                <button id="cancelMobileExport" style="background: #95a5a6;">Cancel</button>
                <button id="startMobileExport" style="background: #27ae60;">üì• Export Package</button>
            </div>
        </div>
    </div>

    <!-- Toast Notification -->
    <div id="toast" class="toast"></div>
    <div id="autosaveIndicator" class="autosave-indicator">üíæ Saving...</div>

    <!-- Asset Manager Panel -->
    <div id="assetPanel" class="asset-panel">
        <div class="asset-header">
            <h3>üì¶ Asset Library</h3>
            <button id="toggleAssets" class="toggle-btn">‚ñº</button>
        </div>
        <div class="asset-content">
            <div class="upload-section">
                <label class="upload-label">
                    <input type="file" id="assetUpload" accept="image/*,audio/*" multiple style="display: none;">
                    <span>‚ûï Upload Assets</span>
                </label>
            </div>
            <div class="upload-section">
                <label class="upload-label">
                    <input type="file" id="animationUpload" accept="image/png,image/jpeg" style="display: none;">
                    <span>üé¨ Upload Sprite Sheet</span>
                </label>
            </div>
            <div class="asset-tabs">
                <button class="asset-tab active" data-type="sprites">üé® Sprites</button>
                <button class="asset-tab" data-type="sounds">üîä Sounds</button>
                <button class="asset-tab" data-type="backgrounds">üñºÔ∏è Backgrounds</button>
                <button class="asset-tab" data-type="animations">üé¨ Animations</button>
            </div>
            <div id="assetGrid" class="asset-grid">
                <!-- Assets will be populated here -->
            </div>
        </div>
    </div>
    
    <!-- Restore Asset Panel Button (appears when asset panel is collapsed) -->
    <button class="restore-assets-btn" id="restoreAssetsBtn" onclick="window.restoreAssetPanel()" title="Restore Asset Library">
        üì¶ ‚óÄ
    </button>

    <!-- Game Preview Panel -->
    <div id="previewPanel" class="preview-panel collapsed">
        <div class="preview-header">
            <h3><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-gamepad2-icon lucide-gamepad-2" style="display: inline-block; vertical-align: middle; margin-right: 6px; color: var(--primary);"><line x1="6" x2="10" y1="11" y2="11"/><line x1="8" x2="8" y1="9" y2="13"/><line x1="15" x2="15.01" y1="12" y2="12"/><line x1="18" x2="18.01" y1="10" y2="10"/><path d="M17.32 5H6.68a4 4 0 0 0-3.978 3.59c-.006.052-.01.101-.017.152C2.604 9.416 2 14.456 2 16a3 3 0 0 0 3 3c1 0 1.5-.5 2-1l1.414-1.414A2 2 0 0 1 9.828 16h4.344a2 2 0 0 1 1.414.586L17 18c.5.5 1 1 2 1a3 3 0 0 0 3-3c0-1.545-.604-6.584-.685-7.258-.007-.05-.011-.1-.017-.151A4 4 0 0 0 17.32 5z"/></svg>Game Preview</h3>
            <div class="preview-controls">
                <button id="playGame" class="preview-btn">‚ñ∂Ô∏è Play</button>
                <button id="stopGame" class="preview-btn" disabled>‚èπÔ∏è Stop</button>
                <button id="restartGame" class="preview-btn" disabled>üîÑ Restart</button>
                <button id="toggleDebug" class="preview-btn" style="background: #f39c12;">üêõ Debug</button>
                <button id="closePreview" class="preview-btn">‚úï</button>
            </div>
        </div>
        <div class="preview-content">
            <canvas id="gameCanvas" width="800" height="600"></canvas>
            <div id="gameStats" class="game-stats">
                <div>Score: <span id="previewScore">0</span></div>
                <div>FPS: <span id="previewFPS">60</span></div>
            </div>
        </div>
    </div>

    <!-- Debug Console -->
    <div id="debugConsole" class="debug-console collapsed">
        <div class="debug-header">
            <span>üñ•Ô∏è Debug Console</span>
            <div class="debug-controls">
                <button id="clearConsole" class="debug-btn">üóëÔ∏è Clear</button>
                <button id="toggleConsole" class="debug-btn">‚ñº</button>
            </div>
        </div>
        <div id="debugOutput" class="debug-output"></div>
        <div id="debugPreviewSection" class="debug-preview-section" style="display: none;">
            <svg id="previewSVG" viewBox="0 0 800 600" xmlns="http://www.w3.org/2000/svg" style="width: 100%; border: 2px solid #3498db; margin-top: 10px; background: #1a1a1a; border-radius: 5px;">
                <text x="400" y="300" text-anchor="middle" dy="0.3em" font-size="24" fill="#3498db" font-weight="bold">üì∫ PREVIEW</text>
                <text x="400" y="330" text-anchor="middle" dy="0.3em" font-size="14" fill="#95a5a6">Live Game Preview</text>
            </svg>
            <canvas id="debugGameCanvas" width="800" height="600" style="width: 100%; border: 2px solid #3498db; margin-top: 10px; background: #000; border-radius: 5px; display: none;"></canvas>
        </div>
    </div>

    <!-- Achievement Panel -->
    <div id="achievementPanel" class="achievement-overlay">
        <div class="achievement-popup">
            <div class="achievement-icon">üèÜ</div>
            <h2 id="achievementTitle">Achievement Unlocked!</h2>
            <p id="achievementDesc">First Blood - Create your first game</p>
            <div class="achievement-points">+50 XP</div>
        </div>
    </div>

    <!-- Score Submission Modal -->
    <div id="scoreModal" class="modal">
        <div class="modal-content">
            <h2>üéØ Submit Score</h2>
            <div class="score-display">
                <div class="score-large" id="finalScore">0</div>
                <p>points</p>
            </div>
            <input type="text" id="playerName" placeholder="Enter your name" maxlength="20" 
                   style="width: 100%; padding: 10px; margin: 15px 0; border-radius: 5px; border: 2px solid #533483; background: #0f3460; color: white;">
            <div class="modal-buttons">
                <button id="cancelScore" style="background: #95a5a6;">Cancel</button>
                <button id="submitScore" style="background: #27ae60;">Submit Score</button>
            </div>
        </div>
    </div>



    <!-- Leaderboard Modal -->
    <div id="leaderboardModal" class="modal">
        <div class="modal-content large-modal">
            <div class="modal-header">
                <h2>üèÜ Global Leaderboard</h2>
                <button id="closeLeaderboard" class="close-btn">‚úï</button>
            </div>
            <div class="leaderboard-filters">
                <button class="filter-btn active" data-period="daily">üìÖ Daily</button>
                <button class="filter-btn" data-period="weekly">üìä Weekly</button>
                <button class="filter-btn" data-period="monthly">üìà Monthly</button>
                <button class="filter-btn" data-period="alltime">üåü All Time</button>
            </div>
            <div class="leaderboard-content">
                <table class="leaderboard-table">
                    <thead>
                        <tr>
                            <th>Rank</th>
                            <th>Player</th>
                            <th>Game</th>
                            <th>Score</th>
                            <th>Date</th>
                        </tr>
                    </thead>
                    <tbody id="leaderboardTableBody">
                        <!-- Populated by JavaScript -->
                    </tbody>
                </table>
            </div>
            <div class="leaderboard-footer">
                <div class="user-rank">Your Rank: <span id="userRank" class="highlight">#--</span></div>
                <div class="user-best">Your Best: <span id="userBest" class="highlight">0</span></div>
            </div>
        </div>
    </div>



    <!-- Remix Modal -->
    <div id="remixModal" class="modal">
        <div class="modal-content">
            <h2>üé® Remix Game</h2>
            <p>Create your own version of <strong id="remixGameTitle"></strong>?</p>
            <p style="font-size: 14px; color: #95a5a6;">You'll get a copy of the game to edit and publish as your own.</p>
            <div class="modal-buttons">
                <button id="cancelRemix" style="background: #95a5a6;">Cancel</button>
                <button id="confirmRemix" style="background: #3498db;">Remix Now</button>
            </div>
        </div>
    </div>

    <!-- Creator Dashboard Modal -->
    <div id="dashboardModal" class="modal">
        <div class="modal-content large-modal">
            <div class="modal-header">
                <h2>üìä Creator Dashboard</h2>
                <button id="closeDashboard" class="close-btn">‚úï</button>
            </div>
            <div class="dashboard-grid">
                <div class="stat-card">
                    <div class="stat-icon">üéÆ</div>
                    <div class="stat-label">Total Games</div>
                    <div class="stat-value" id="totalGames">0</div>
                </div>
                <div class="stat-card">
                    <div class="stat-icon">‚ñ∂Ô∏è</div>
                    <div class="stat-label">Total Plays</div>
                    <div class="stat-value" id="totalPlays">0</div>
                </div>
                <div class="stat-card">
                    <div class="stat-icon">üë•</div>
                    <div class="stat-label">Followers</div>
                    <div class="stat-value" id="totalFollowers">0</div>
                </div>
                <div class="stat-card">
                    <div class="stat-icon">üí∞</div>
                    <div class="stat-label">Revenue</div>
                    <div class="stat-value" id="totalRevenue">$0</div>
                </div>
            </div>
            <div class="dashboard-section">
                <h3>üìà Performance This Week</h3>
                <canvas id="playsChart" width="400" height="200"></canvas>
            </div>
            <div class="dashboard-section">
                <h3><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-gamepad2-icon lucide-gamepad-2" style="display: inline-block; vertical-align: middle; margin-right: 6px; color: var(--primary);"><line x1="6" x2="10" y1="11" y2="11"/><line x1="8" x2="8" y1="9" y2="13"/><line x1="15" x2="15.01" y1="12" y2="12"/><line x1="18" x2="18.01" y1="10" y2="10"/><path d="M17.32 5H6.68a4 4 0 0 0-3.978 3.59c-.006.052-.01.101-.017.152C2.604 9.416 2 14.456 2 16a3 3 0 0 0 3 3c1 0 1.5-.5 2-1l1.414-1.414A2 2 0 0 1 9.828 16h4.344a2 2 0 0 1 1.414.586L17 18c.5.5 1 1 2 1a3 3 0 0 0 3-3c0-1.545-.604-6.584-.685-7.258-.007-.05-.011-.1-.017-.151A4 4 0 0 0 17.32 5z"/></svg>Your Games</h3>
                <div id="gamesList" class="games-list"></div>
            </div>
            <div class="dashboard-section">
                <h3>üí∞ Revenue Breakdown</h3>
                <div class="revenue-list" id="revenueList"></div>
            </div>
        </div>
    </div>

    <!-- Moderation Queue Modal -->
    <div id="moderationModal" class="modal">
        <div class="modal-content large-modal">
            <div class="modal-header">
                <h2>üõ°Ô∏è Moderation Queue</h2>
                <button id="closeModeration" class="close-btn">‚úï</button>
            </div>
            <div class="moderation-stats">
                <div class="mod-stat">
                    <span class="mod-stat-label">Pending:</span>
                    <span id="pendingCount" class="mod-stat-value">0</span>
                </div>
                <div class="mod-stat">
                    <span class="mod-stat-label">Approved Today:</span>
                    <span id="approvedCount" class="mod-stat-value">0</span>
                </div>
                <div class="mod-stat">
                    <span class="mod-stat-label">Rejected Today:</span>
                    <span id="rejectedCount" class="mod-stat-value">0</span>
                </div>
            </div>
            <div id="moderationQueue" class="moderation-queue"></div>
        </div>
    </div>

    <!-- Moderation Preview Modal -->
    <div id="moderationPreviewModal" class="modal">
        <div class="modal-content large-modal">
            <div class="modal-header">
                <h2>üéÆ Review Game</h2>
                <button id="closeModPreview" class="close-btn">‚úï</button>
            </div>
            <div class="mod-preview-content">
                <div class="mod-game-info">
                    <h3 id="modGameTitle">Game Title</h3>
                    <div class="mod-game-meta">
                        <span>By: <strong id="modGameAuthor">Author</strong></span>
                        <span>Submitted: <strong id="modGameDate">Date</strong></span>
                    </div>
                </div>
                <div class="mod-preview-canvas">
                    <canvas id="modGameCanvas" width="800" height="600"></canvas>
                </div>
                <div class="mod-actions">
                    <textarea id="modFeedback" placeholder="Add feedback (optional)" rows="3"></textarea>
                    <div class="mod-buttons">
                        <button id="rejectGame" class="mod-btn reject">‚ùå Reject</button>
                        <button id="approveGame" class="mod-btn approve">‚úÖ Approve</button>
                    </div>
                </div>
            </div>
        </div>
    </div>



    <!-- User Profile Settings Modal -->
    <div id="settingsModal" class="modal">
        <div class="modal-content large-modal">
            <div class="modal-header">
                <h2>‚öôÔ∏è Profile & Settings</h2>
                <button id="closeSettings" class="close-btn">‚úï</button>
            </div>
            <div class="settings-tabs">
                <button class="settings-tab active" data-tab="profile">üë§ Profile</button>
                <button class="settings-tab" data-tab="preferences">üé® Preferences</button>
                <button class="settings-tab" data-tab="privacy">üîí Privacy</button>
                <button class="settings-tab" data-tab="account">üîë Account</button>
            </div>
            <div id="profileTab" class="settings-tab-content active">
                <div class="settings-section">
                    <h3>Profile Information</h3>
                    <div class="profile-avatar-section">
                        <div class="profile-avatar-large">üë§</div>
                        <button class="change-avatar-btn">Change Avatar</button>
                    </div>
                    <div class="form-group">
                        <label>Username</label>
                        <input type="text" id="username" value="GameDev123" maxlength="20">
                    </div>
                    <div class="form-group">
                        <label>Bio</label>
                        <textarea id="bio" rows="4" maxlength="200" placeholder="Tell us about yourself..."></textarea>
                    </div>
                    <div class="form-group">
                        <label>Role</label>
                        <select id="userRole">
                            <option value="player">Player</option>
                            <option value="developer">Developer</option>
                            <option value="moderator">Moderator</option>
                            <option value="admin">Admin</option>
                        </select>
                    </div>
                    <button class="save-settings-btn">üíæ Save Profile</button>
                </div>
            </div>
            <div id="preferencesTab" class="settings-tab-content">
                <div class="settings-section">
                    <h3>Appearance</h3>
                    <div class="form-group">
                        <label>Theme</label>
                        <select id="theme">
                            <option value="dark">üåô Dark Mode</option>
                            <option value="light">‚òÄÔ∏è Light Mode</option>
                            <option value="auto">üîÑ Auto</option>
                        </select>
                    </div>
                    <div class="form-group">
                        <label><input type="checkbox" id="animations" checked> Enable Animations</label>
                    </div>
                </div>
                <div class="settings-section">
                    <h3>Notifications</h3>
                    <div class="form-group">
                        <label><input type="checkbox" id="notifyGames" checked> Game Approvals</label>
                    </div>
                    <div class="form-group">
                        <label><input type="checkbox" id="notifyFollowers" checked> New Followers</label>
                    </div>
                    <div class="form-group">
                        <label><input type="checkbox" id="notifyComments" checked> Comments on Games</label>
                    </div>
                </div>
                <div class="settings-section">
                    <h3>Editor</h3>
                    <div class="form-group">
                        <label>Auto-Save Interval</label>
                        <select id="autoSaveInterval">
                            <option value="10">10 seconds</option>
                            <option value="30" selected>30 seconds</option>
                            <option value="60">1 minute</option>
                            <option value="0">Disabled</option>
                        </select>
                    </div>
                    <div class="form-group">
                        <label><input type="checkbox" id="snapToGrid" checked> Snap Blocks to Grid</label>
                    </div>
                </div>
                <button class="save-settings-btn">üíæ Save Preferences</button>
            </div>
            <div id="privacyTab" class="settings-tab-content">
                <div class="settings-section">
                    <h3>Privacy Settings</h3>
                    <div class="form-group">
                        <label>Profile Visibility</label>
                        <select id="profileVisibility">
                            <option value="public">Public</option>
                            <option value="friends">Friends Only</option>
                            <option value="private">Private</option>
                        </select>
                    </div>
                    <div class="form-group">
                        <label><input type="checkbox" id="showStats" checked> Show Statistics on Profile</label>
                    </div>
                    <div class="form-group">
                        <label><input type="checkbox" id="allowMessages" checked> Allow Direct Messages</label>
                    </div>
                    <div class="form-group">
                        <label><input type="checkbox" id="showOnline"> Show Online Status</label>
                    </div>
                </div>
                <button class="save-settings-btn">üíæ Save Privacy Settings</button>
            </div>
            <div id="accountTab" class="settings-tab-content">
                <div class="settings-section">
                    <h3>Account Security</h3>
                    <div class="form-group">
                        <label>Email</label>
                        <input type="email" id="email" value="user@example.com">
                    </div>
                    <div class="form-group">
                        <label>Current Password</label>
                        <input type="password" id="currentPassword" placeholder="‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢">
                    </div>
                    <div class="form-group">
                        <label>New Password</label>
                        <input type="password" id="newPassword" placeholder="‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢">
                    </div>
                    <div class="form-group">
                        <label>Confirm Password</label>
                        <input type="password" id="confirmPassword" placeholder="‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢">
                    </div>
                    <button class="save-settings-btn">üîí Change Password</button>
                </div>
                <div class="settings-section danger-zone">
                    <h3>‚ö†Ô∏è Danger Zone</h3>
                    <button class="danger-btn">üóëÔ∏è Delete Account</button>
                    <p style="font-size: 12px; color: #95a5a6; margin-top: 10px;">This action cannot be undone.</p>
                </div>
            </div>
        </div>
    </div>

    <xml id="toolbox">
        <category name="Events" colour="#4a90e2">
            <block type="on_game_start"></block>
            <block type="on_scene_load"></block>
            <block type="on_key_press"></block>
            <block type="on_mouse_click"></block>
            <block type="on_collision_tagged"></block>
            <block type="on_object_destroyed"></block>
            <block type="on_score_change"></block>
            <block type="on_area_enter"></block>
            <block type="on_level_complete"></block>
            <block type="on_timer"></block>
            <block type="on_tag_collision"></block>
            <block type="tag_collision_exit"></block>
        </category>

        <category name="üéÆ Input & Controls" colour="#4a90e2">
            <block type="when_key_pressed"></block>
            <block type="when_key_released"></block>
            <block type="while_key_held"></block>
            <block type="is_key_pressed"></block>
            <block type="when_mouse_button_pressed"></block>
            <block type="when_mouse_button_released"></block>
            <block type="get_mouse_x"></block>
            <block type="get_mouse_y"></block>
            <block type="lock_cursor"></block>
            <block type="unlock_cursor"></block>
            <block type="enable_input"></block>
            <block type="disable_input"></block>
            <block type="is_input_enabled"></block>
            <block type="set_input_context"></block>
        </category>

        <category name="üè∑Ô∏è Entity & Tags" colour="#e67e22">
            <block type="for_each_with_tag"></block>
            <block type="count_with_tag"></block>
            <block type="destroy_all_with_tag"></block>
            <block type="clone_with_tag"></block>
            <block type="add_tag"></block>
            <block type="remove_tag"></block>
            <block type="has_tag"></block>
            <block type="get_nearest_with_tag"></block>
            <block type="get_random_with_tag"></block>
            <block type="get_all_with_tag"></block>
            <block type="distance_to_nearest"></block>
            <block type="get_entity_position"></block>
            <block type="set_entity_position"></block>
        </category>
        
        <category name="Logic & Flow" colour="#5b67a5">
            <block type="controls_if"></block>
            <block type="switch_case"></block>
            <block type="for_loop"></block>
            <block type="while_loop"></block>
            <block type="repeat_n_times"></block>
            <block type="repeat_until"></block>
            <block type="loop_break"></block>
            <block type="loop_continue"></block>
            <block type="delay"></block>
            <block type="random_percent"></block>
            <block type="random_choice"></block>
            <block type="weighted_random"></block>
            <block type="weighted_choice"></block>
            <block type="cooldown_check"></block>
            <block type="set_cooldown"></block>
            <block type="state_machine_init"></block>
            <block type="state_machine_set"></block>
            <block type="state_machine_get"></block>
            <block type="state_machine_is"></block>
            <block type="log_to_console"></block>
            <block type="debug_assert"></block>
            <block type="logic_compare"></block>
            <block type="logic_operation"></block>
            <block type="logic_boolean"></block>
        </category>
        
        <category name="Functions" colour="#9b59b6">
            <block type="define_function"></block>
            <block type="call_function"></block>
        </category>
        
        <category name="Movement" colour="#9b59b6">
            <block type="move_player"></block>
            <block type="set_velocity"></block>
            <block type="apply_gravity"></block>
            <block type="apply_friction"></block>
            <block type="jump_buffered"></block>
            <block type="dash"></block>
            <block type="knockback"></block>
            <block type="move_along_path"></block>
            <block type="find_path_to"></block>
        </category>
        
        <category name="AI Behavior" colour="#e67e22">
            <block type="ai_patrol"></block>
            <block type="ai_chase"></block>
            <block type="ai_flee"></block>
            <block type="ai_init_state"></block>
            <block type="ai_set_state"></block>
            <block type="ai_is_in_state"></block>
            <block type="set_ai_type"></block>
        </category>
        
        <category name="Objects" colour="#e67e22">
            <block type="spawn_sprite"></block>
            <block type="destroy_sprite"></block>
            <block type="collision_response"></block>
        </category>
        
        <category name="Keyframes & Animation" colour="#9b59b6">
            <block type="create_keyframe"></block>
            <block type="set_keyframe_property"></block>
            <block type="animate_keyframes"></block>
        </category>
        
        <category name="Sprite Sheet Animations" colour="#f39c12">
            <block type="play_animation"></block>
            <block type="stop_animation"></block>
            <block type="animation_with_keyframes"></block>
        </category>
        
        <category name="Inventory" colour="#f39c12">
            <block type="inventory_add"></block>
            <block type="inventory_remove"></block>
            <block type="inventory_has"></block>
            <block type="inventory_get_count"></block>
            <block type="inventory_swap_slots"></block>
            <block type="pickup_create"></block>
        </category>
        
        <category name="Tilemaps" colour="#9b59b6">
            <block type="tilemap_create"></block>
            <block type="tilemap_set_tile"></block>
        </category>
        
        <category name="Game Control" colour="#7b68ee">
            <block type="load_scene"></block>
            <block type="pause_game"></block>
            <block type="resume_game"></block>
            <block type="set_time_scale"></block>
            <block type="set_camera_target"></block>
            <block type="for_each_with_tag"></block>
            <block type="count_with_tag"></block>
            <block type="destroy_all_with_tag"></block>
        </category>
        
        <category name="Powerups & Buffs" colour="#27ae60">
            <block type="apply_powerup"></block>
            <block type="apply_debuff"></block>
            <block type="has_buff"></block>
        </category>
        
        <category name="Camera" colour="#3498db">
            <block type="camera_follow"></block>
            <block type="camera_clamp"></block>
        </category>
        
        <category name="State & Data" colour="#f39c12">
            <block type="set_variable"></block>
            <block type="get_variable"></block>
            <block type="create_array"></block>
            <block type="array_push"></block>
        </category>
        
        <category name="Health & Lives" colour="#e74c3c">
            <block type="set_health"></block>
            <block type="add_health"></block>
            <block type="set_lives"></block>
            <block type="add_score"></block>
        </category>
        
        <category name="Save/Load" colour="#16a085">
            <block type="save_game"></block>
            <block type="load_game"></block>
        </category>
        
        <category name="Math" colour="#5b995b">
            <block type="math_number"></block>
            <block type="math_arithmetic"></block>
        </category>

        <category name="üîä Audio" colour="#1abc9c">
            <block type="play_sound"></block>
            <block type="stop_sound"></block>
            <block type="play_music"></block>
        </category>

        <category name="‚öôÔ∏è Physics" colour="#9b59b6">
            <block type="apply_force"></block>
            <block type="is_grounded"></block>
            <block type="raycast"></block>
        </category>

        <category name="üé® Visual Effects" colour="#f39c12">
            <block type="set_opacity"></block>
            <block type="flip_sprite"></block>
            <block type="camera_shake"></block>
            <block type="set_z_layer"></block>
        </category>

        <category name="üéÆ Game State" colour="#16a085">
            <block type="pause_game"></block>
            <block type="resume_game"></block>
            <block type="load_scene"></block>
            <block type="game_over"></block>
            <block type="restart_level"></block>
        </category>

        <category name="üí• Combat" colour="#e74c3c">
            <block type="deal_damage"></block>
            <block type="create_hitbox"></block>
        </category>

        <category name="üé® UI" colour="#3498db">
            <block type="ui_button"></block>
            <block type="ui_text"></block>
            <block type="ui_dialog"></block>
            <block type="ui_hud_element"></block>
            <block type="ui_menu"></block>
            <block type="ui_get_input_value"></block>
            <block type="ui_show_notification"></block>
            <block type="ui_inventory_display"></block>
        </category>

        <category name="üëÜ Touch & Gestures" colour="#e74c3c">
            <block type="on_touch_start"></block>
            <block type="on_swipe"></block>
            <block type="on_pinch"></block>
            <block type="on_double_tap"></block>
            <block type="get_touch_count"></block>
            <block type="get_touch_position"></block>
        </category>

        <category name="üß± Custom Blocks" colour="#FF6B6B" id="custom_blocks">
            <!-- New blocks will appear here -->
        </category>

    </xml>

    <!-- AI Suggestion System is now in an external file -->
    <script src="{% static 'js/ai_suggestion_system.js' %}"></script>
    <script>
        // Initialize AI Suggestion System when workspace is ready
        document.addEventListener('workspaceReady', function() {
            if (typeof AISuggestionSystem !== 'undefined' && typeof workspace !== 'undefined') {
                window.aiSuggestionSystem = new AISuggestionSystem(workspace);
            }
        });

        // Initialize AI Suggestion System if workspace is available
        if (typeof workspace !== 'undefined') {
            window.aiSuggestionSystem = new AISuggestionSystem(workspace);
        }

        class RenderSystem {
            constructor(canvas) {
                this.canvas = canvas;
                this.ctx = canvas.getContext('2d');
                this.entities = [];
                this.layers = [];
                this.camera = {
                    x: 0, y: 0, targetX: 0, targetY: 0,
                    width: canvas.width, height: canvas.height,
                    zoom: 1.0, minZoom: 0.5, maxZoom: 3.0,
                    smooth: 0.1,
                    bounds: { minX: -Infinity, maxX: Infinity, minY: -Infinity, maxY: Infinity },
                    shake: { intensity: 0, duration: 0, startTime: 0 },
                    transitions: [], followTarget: null,
                    followOffset: { x: 0, y: 0 }, isShaking: false
                };
                this.background = null;
                this.initEventListeners();
            }

            initEventListeners() {
                window.addEventListener('resize', () => this.resize());
                this.canvas.addEventListener('wheel', (e) => {
                    e.preventDefault();
                    const delta = e.deltaY > 0 ? -0.1 : 0.1;
                    this.setZoom(this.camera.zoom + delta);
                });
            }

            resize() {
                this.camera.width = this.canvas.width;
                this.camera.height = this.canvas.height;
            }

            setCameraPosition(x, y) {
                this.camera.targetX = x;
                this.camera.targetY = y;
                this.applyCameraBounds();
            }

            setZoom(zoom) {
                this.camera.zoom = Math.max(this.camera.minZoom, Math.min(this.camera.maxZoom, zoom));
            }

            setCameraBounds(minX, maxX, minY, maxY) {
                this.camera.bounds = { minX, maxX, minY, maxY };
                this.applyCameraBounds();
            }

            setCameraFollow(target, offsetX = 0, offsetY = 0, smooth = 0.1) {
                this.camera.followTarget = target;
                this.camera.followOffset = { x: offsetX, y: offsetY };
                this.camera.smooth = smooth;
            }

            stopCameraFollow() {
                this.camera.followTarget = null;
            }

            applyCameraBounds() {
                if (isFinite(this.camera.bounds.minX)) this.camera.targetX = Math.max(this.camera.bounds.minX, this.camera.targetX);
                if (isFinite(this.camera.bounds.maxX)) this.camera.targetX = Math.min(this.camera.bounds.maxX, this.camera.targetX);
                if (isFinite(this.camera.bounds.minY)) this.camera.targetY = Math.max(this.camera.bounds.minY, this.camera.targetY);
                if (isFinite(this.camera.bounds.maxY)) this.camera.targetY = Math.min(this.camera.bounds.maxY, this.camera.targetY);
            }

            cameraShake(intensity, duration) {
                this.camera.shake = { intensity, duration: duration * 1000, startTime: Date.now() };
                this.camera.isShaking = true;
            }

            startCameraTransition(toX, toY, duration, easing = 'linear') {
                this.camera.transitions.push({
                    fromX: this.camera.x, fromY: this.camera.y, toX, toY, duration, elapsed: 0, easing, startTime: Date.now()
                });
            }

            update(deltaTime) {
                if (this.camera.followTarget?.x !== undefined) {
                    this.camera.targetX = this.camera.followTarget.x + this.camera.followOffset.x - (this.camera.width / (2 * this.camera.zoom));
                    this.camera.targetY = this.camera.followTarget.y + this.camera.followOffset.y - (this.camera.height / (2 * this.camera.zoom));
                    this.applyCameraBounds();
                }

                this.camera.x += (this.camera.targetX - this.camera.x) * this.camera.smooth;
                this.camera.y += (this.camera.targetY - this.camera.y) * this.camera.smooth;

                if (this.camera.isShaking) {
                    const elapsed = Date.now() - this.camera.shake.startTime;
                    if (elapsed < this.camera.shake.duration) {
                        const intensity = this.camera.shake.intensity * (1 - elapsed / this.camera.shake.duration);
                        this.camera.x += (Math.random() - 0.5) * intensity;
                        this.camera.y += (Math.random() - 0.5) * intensity;
                    } else {
                        this.camera.isShaking = false;
                    }
                }

                for (let i = this.camera.transitions.length - 1; i >= 0; i--) {
                    const t = this.camera.transitions[i];
                    t.elapsed = Date.now() - t.startTime;
                    if (t.elapsed >= t.duration) {
                        this.camera.x = t.toX;
                        this.camera.y = t.toY;
                        this.camera.transitions.splice(i, 1);
                    } else {
                        const p = t.elapsed / t.duration;
                        this.camera.x = t.fromX + (t.toX - t.fromX) * p;
                        this.camera.y = t.fromY + (t.toY - t.fromY) * p;
                    }
                }
            }

            render() {
                this.ctx.save();
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                this.ctx.translate(this.canvas.width / 2, this.canvas.height / 2);
                this.ctx.scale(this.camera.zoom, this.camera.zoom);
                this.ctx.translate(-this.canvas.width / 2, -this.canvas.height / 2);
                this.ctx.translate(-this.camera.x, -this.camera.y);
                if (this.background) this.renderBackground();
                this.renderLayers();
                this.renderEntities();
                this.ctx.restore();
            }

            renderBackground() {
                if (typeof this.background === 'string') {
                    const img = new Image();
                    img.src = this.background;
                    this.ctx.drawImage(img, this.camera.x, this.camera.y, this.camera.width, this.camera.height);
                } else if (this.background?.color) {
                    this.ctx.fillStyle = this.background.color;
                    this.ctx.fillRect(this.camera.x, this.camera.y, this.camera.width, this.camera.height);
                }
            }

            renderLayers() {
                this.layers.forEach(layer => {
                    if (layer.visible !== false) {
                        if (layer.type === 'tilemap') this.renderTilemap(layer);
                        else if (layer.type === 'particles') this.renderParticles(layer);
                    }
                });
            }

            renderEntities() {
                [...this.entities].sort((a, b) => (a.zIndex || 0) - (b.zIndex || 0)).forEach(entity => {
                    if (entity.visible !== false) this.renderEntity(entity);
                });
            }

            renderEntity(entity) {
                if (!this.isEntityInView(entity)) return;
                this.ctx.save();
                this.ctx.translate(entity.x, entity.y);
                if (entity.rotation) this.ctx.rotate(entity.rotation);
                if (entity.scaleX || entity.scaleY) this.ctx.scale(entity.scaleX || 1, entity.scaleY || 1);
                if (entity.flipX) { this.ctx.scale(-1, 1); this.ctx.translate(-entity.width, 0); }
                if (entity.flipY) { this.ctx.scale(1, -1); this.ctx.translate(0, -entity.height); }
                if (entity.opacity !== undefined && entity.opacity < 1) this.ctx.globalAlpha = entity.opacity;
                if (entity.sprite) this.renderSprite(entity);
                else if (entity.text) this.renderText(entity);
                else if (entity.shape) this.renderShape(entity);
                else this.renderDefault(entity);
                this.ctx.restore();
            }

            isEntityInView(entity) {
                const cameraRight = this.camera.x + this.camera.width / this.camera.zoom;
                const cameraBottom = this.camera.y + this.camera.height / this.camera.zoom;
                return !(entity.x + (entity.width || 0) < this.camera.x || entity.x > cameraRight || entity.y + (entity.height || 0) < this.camera.y || entity.y > cameraBottom);
            }

            renderSprite(entity) {
                if (entity.sprite?.complete) {
                    const w = entity.width || entity.sprite.width;
                    const h = entity.height || entity.sprite.height;
                    const ox = entity.offsetX || 0;
                    const oy = entity.offsetY || 0;
                    this.ctx.drawImage(entity.sprite, 0, 0, entity.sprite.width, entity.sprite.height, -w/2-ox, -h/2-oy, w, h);
                }
            }

            renderText(entity) {
                this.ctx.font = entity.fontSize ? `${entity.fontSize}px ${entity.fontFamily || 'Arial'}` : '16px Arial';
                this.ctx.fillStyle = entity.color || '#ffffff';
                this.ctx.textAlign = entity.textAlign || 'center';
                this.ctx.textBaseline = entity.textBaseline || 'middle';
                const lines = entity.text.split('\n');
                const lh = entity.lineHeight || 1.5;
                lines.forEach((line, i) => {
                    const y = (i - (lines.length - 1) / 2) * (entity.fontSize || 16) * lh;
                    this.ctx.fillText(line, 0, y);
                });
            }

            renderShape(entity) {
                switch (entity.shape) {
                    case 'circle':
                        this.ctx.beginPath();
                        this.ctx.arc(0, 0, entity.radius || 20, 0, Math.PI * 2);
                        if (entity.fillColor) { this.ctx.fillStyle = entity.fillColor; this.ctx.fill(); }
                        if (entity.strokeColor) { this.ctx.strokeStyle = entity.strokeColor; this.ctx.lineWidth = entity.strokeWidth || 2; this.ctx.stroke(); }
                        break;
                    case 'rectangle':
                        const w = entity.width || 50, h = entity.height || 50;
                        this.ctx.beginPath();
                        this.ctx.rect(-w/2, -h/2, w, h);
                        if (entity.fillColor) { this.ctx.fillStyle = entity.fillColor; this.ctx.fill(); }
                        if (entity.strokeColor) { this.ctx.strokeStyle = entity.strokeColor; this.ctx.lineWidth = entity.strokeWidth || 2; this.ctx.stroke(); }
                        break;
                }
            }

            renderDefault(entity) {
                this.ctx.fillStyle = entity.color || '#2196F3';
                this.ctx.fillRect(-25, -25, 50, 50);
                if (entity.debug) { this.ctx.strokeStyle = '#FF5252'; this.ctx.lineWidth = 2; this.ctx.strokeRect(-25, -25, 50, 50); }
            }

            renderTilemap(layer) {
                if (!layer.data || !layer.tileWidth || !layer.tileHeight) return;
                const sx = Math.floor(this.camera.x / layer.tileWidth), sy = Math.floor(this.camera.y / layer.tileHeight);
                const ex = Math.ceil((this.camera.x + this.camera.width / this.camera.zoom) / layer.tileWidth);
                const ey = Math.ceil((this.camera.y + this.camera.height / this.camera.zoom) / layer.tileHeight);
                for (let y = sy; y <= ey; y++) {
                    for (let x = sx; x <= ex; x++) {
                        const tileId = layer.data[y * layer.width + x];
                        if (tileId > 0 && layer.tileset?.[tileId]) {
                            const tile = layer.tileset[tileId];
                            const srcX = (tileId % layer.tilesPerRow) * layer.tileWidth;
                            const srcY = Math.floor(tileId / layer.tilesPerRow) * layer.tileHeight;
                            this.ctx.drawImage(tile.image, srcX, srcY, layer.tileWidth, layer.tileHeight, x * layer.tileWidth, y * layer.tileHeight, layer.tileWidth, layer.tileHeight);
                        }
                    }
                }
            }

            getCameraPosition() { return { x: this.camera.x, y: this.camera.y }; }
            getCameraZoom() { return this.camera.zoom; }
            isPointInView(x, y) { return x >= this.camera.x && x <= this.camera.x + this.camera.width / this.camera.zoom && y >= this.camera.y && y <= this.camera.y + this.camera.height / this.camera.zoom; }
            screenToWorld(screenX, screenY) {
                const rect = this.canvas.getBoundingClientRect();
                const aX = screenX - rect.left, aY = screenY - rect.top;
                return { x: (aX / this.camera.zoom) + this.camera.x - (this.canvas.width / (2 * this.camera.zoom)), y: (aY / this.camera.zoom) + this.camera.y - (this.canvas.height / (2 * this.camera.zoom)) };
            }
            worldToScreen(worldX, worldY) {
                return { x: (worldX - this.camera.x) * this.camera.zoom + (this.canvas.width / 2), y: (worldY - this.camera.y) * this.camera.zoom + (this.canvas.height / 2) };
            }
        }

        class MobileExporter {
            constructor(projectData) {
                this.projectData = projectData;
            }

            async export(platform, exportOptions = {}) {
                try {
                    this.validateProject();
                    
                    const gameTitle = this.projectData.gameTitle || 'MyGame';
                    const safeGameTitle = gameTitle.replace(/[^\w\s-]/g, '').trim().replace(/\s+/g, '_');
                    const version = this.projectData.version || '1.0.0';
                    
                    const files = {};
                    
                    const gameContent = this.generateGameFile(exportOptions);
                    const configContent = this.generateConfigFile(platform, exportOptions);
                    
                    files['game.js'] = gameContent;
                    files['config.json'] = configContent;
                    
                    if (platform === 'android') {
                        files['AndroidManifest.xml'] = this.generateAndroidManifest(gameTitle);
                        files['build.gradle'] = this.generateGradleFile();
                    } else if (platform === 'ios') {
                        files['Info.plist'] = this.generateIOSPlist(gameTitle, version);
                        files['AppDelegate.m'] = this.generateAppDelegate();
                    }
                    
                    const blob = await this.createZipBlob(files);
                    
                    const filename = `${safeGameTitle}_v${version}.${platform === 'ios' ? 'ipa' : 'apk'}`;
                    blob.name = filename;
                    
                    return blob;
                } catch (error) {
                    throw new Error(`Mobile export failed: ${error.message}`);
                }
            }

            validateProject() {
                if (!this.projectData.blocks || this.projectData.blocks.length === 0) {
                    throw new Error('Project has no blocks. Add game logic before exporting.');
                }
                if (!this.projectData.gameTitle || this.projectData.gameTitle.trim() === '') {
                    throw new Error('Game title is required for export.');
                }
            }

            generateGameFile(options) {
                const gameTitle = this.projectData.gameTitle || 'MyGame';
                const code = this.projectData.code || '';
                const optimizedCode = options.optimize ? this.optimizeCode(code) : code;
                
                return `// Lupiforge Mobile Game - Auto-generated
// Game: ${gameTitle}
// Version: ${this.projectData.version || '1.0.0'}
// Exported: ${new Date().toISOString()}

const gameConfig = {
    title: '${gameTitle}',
    version: '${this.projectData.version || '1.0.0'}',
    orientation: '${options.orientation || 'landscape'}',
    touchEnabled: true,
    enableMultiTouch: ${options.touchConfig?.enableMultiTouch !== false}
};

// Game initialization
console.log('üéÆ Initializing game:', gameConfig);

// Game logic from blocks
${optimizedCode}

console.log('‚úÖ Game loaded successfully');
`;
            }

            generateConfigFile(platform, options) {
                return JSON.stringify({
                    gameTitle: this.projectData.gameTitle,
                    version: this.projectData.version || '1.0.0',
                    platform: platform,
                    orientation: options.orientation || 'landscape',
                    touchConfig: options.touchConfig || {
                        enableMultiTouch: true,
                        swipeSensitivity: 0.5,
                        pinchEnabled: true
                    },
                    exportDate: new Date().toISOString()
                }, null, 2);
            }

            generateAndroidManifest(appName) {
                return `<?xml version="1.0" encoding="utf-8"?>
<manifest xmlns:android="http://schemas.android.com/apk/res/android"
    package="com.lupiforge.game">
    <uses-permission android:name="android.permission.INTERNET" />
    <uses-permission android:name="android.permission.VIBRATE" />
    <application android:label="${appName}" android:icon="@drawable/ic_launcher">
        <activity android:name=".MainActivity" android:label="${appName}" android:screenOrientation="landscape">
            <intent-filter>
                <action android:name="android.intent.action.MAIN" />
                <category android:name="android.intent.category.LAUNCHER" />
            </intent-filter>
        </activity>
    </application>
</manifest>`;
            }

            generateGradleFile() {
                return `apply plugin: 'com.android.application'

android {
    compileSdkVersion 33
    defaultConfig {
        applicationId "com.lupiforge.game"
        minSdkVersion 21
        targetSdkVersion 33
        versionCode 1
        versionName "1.0.0"
    }
}

dependencies {
    implementation 'androidx.appcompat:appcompat:1.6.1'
}`;
            }

            generateIOSPlist(appName, version) {
                return `<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
    <key>CFBundleDisplayName</key>
    <string>${appName}</string>
    <key>CFBundleIdentifier</key>
    <string>com.lupiforge.game</string>
    <key>CFBundleShortVersionString</key>
    <string>${version}</string>
    <key>CFBundleVersion</key>
    <string>1</string>
    <key>UIRequiresFullScreen</key>
    <true/>
    <key>UISupportedInterfaceOrientations</key>
    <array>
        <string>UIInterfaceOrientationLandscapeLeft</string>
        <string>UIInterfaceOrientationLandscapeRight</string>
    </array>
</dict>
</plist>`;
            }

            generateAppDelegate() {
                return `#import <UIKit/UIKit.h>

@interface AppDelegate : UIResponder <UIApplicationDelegate>
@property (strong, nonatomic) UIWindow *window;
@end

@implementation AppDelegate

- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions {
    self.window = [[UIWindow alloc] initWithFrame:[UIScreen mainScreen].bounds];
    self.window.rootViewController = [[UIViewController alloc] init];
    [self.window makeKeyAndVisible];
    return YES;
}

@end`;
            }

            optimizeCode(code) {
                return code
                    .replace(/\s+/g, ' ')
                    .replace(/\/\/.*$/gm, '')
                    .replace(/\/\*[\s\S]*?\*\//g, '');
            }

            async createZipBlob(files) {
                const content = JSON.stringify(files);
                return new Blob([content], { type: 'application/zip' });
            }
        }

        // Define custom blocks - MUST BE CALLED AFTER BLOCKLY IS LOADED
        function defineCustomBlocks() {
            if (typeof Blockly === 'undefined') {
                console.error('‚ùå Cannot define blocks - Blockly is not loaded');
                return false;
            }
            
            console.log('üì¶ Defining custom Blockly blocks...');

        Blockly.Blocks['on_game_start'] = {
            init: function() {
                this.appendDummyInput()
                    .appendField("üé¨ On Game Start");
                this.appendStatementInput("DO")
                    .setCheck(null)
                    .appendField("do");
                this.setColour("#4a90e2");
                this.setTooltip("Runs when the game starts");
                this.setHelpUrl("");
            }
        };

        Blockly.Blocks['on_key_press'] = {
            init: function() {
                this.appendDummyInput()
                    .appendField("‚å®Ô∏è On Key Press")
                    .appendField(new Blockly.FieldDropdown([
                        ["‚Üë Up", "UP"],
                        ["‚Üì Down", "DOWN"],
                        ["‚Üê Left", "LEFT"],
                        ["‚Üí Right", "RIGHT"],
                        ["Space", "SPACE"]
                    ]), "KEY");
                this.appendStatementInput("DO")
                    .setCheck(null)
                    .appendField("do");
                this.setColour("#4a90e2");
                this.setTooltip("Runs when a key is pressed");
                this.setHelpUrl("");
            }
        };

        Blockly.Blocks['on_collision'] = {
            init: function() {
                this.appendDummyInput()
                    .appendField("üí• On Collision")
                    .appendField(new Blockly.FieldDropdown([
                        ["Player", "PLAYER"],
                        ["Enemy", "ENEMY"],
                        ["Coin", "COIN"],
                        ["Wall", "WALL"]
                    ]), "OBJECT1")
                    .appendField("with")
                    .appendField(new Blockly.FieldDropdown([
                        ["Enemy", "ENEMY"],
                        ["Coin", "COIN"],
                        ["Wall", "WALL"],
                        ["Player", "PLAYER"]
                    ]), "OBJECT2");
                this.appendStatementInput("DO")
                    .setCheck(null)
                    .appendField("do");
                this.setColour("#4a90e2");
                this.setTooltip("Runs when objects collide");
                this.setHelpUrl("");
            }
        };

        Blockly.Blocks['on_timer'] = {
            init: function() {
                this.appendDummyInput()
                    .appendField("‚è±Ô∏è Every")
                    .appendField(new Blockly.FieldNumber(1, 0.1, 10, 0.1), "SECONDS")
                    .appendField("seconds");
                this.appendStatementInput("DO")
                    .setCheck(null)
                    .appendField("do");
                this.setColour("#4a90e2");
                this.setTooltip("Runs repeatedly at interval");
                this.setHelpUrl("");
            }
        };

        Blockly.Blocks['move_player'] = {
            init: function() {
                this.appendDummyInput()
                    .appendField("üèÉ Move Player")
                    .appendField(new Blockly.FieldDropdown([
                        ["‚Üë Up", "UP"],
                        ["‚Üì Down", "DOWN"],
                        ["‚Üê Left", "LEFT"],
                        ["‚Üí Right", "RIGHT"]
                    ]), "DIRECTION")
                    .appendField("by")
                    .appendField(new Blockly.FieldNumber(10, 1, 100), "AMOUNT")
                    .appendField("pixels");
                this.setPreviousStatement(true, null);
                this.setNextStatement(true, null);
                this.setColour("#e67e22");
                this.setTooltip("Move the player in a direction");
                this.setHelpUrl("");
            }
        };

        Blockly.Blocks['spawn_sprite'] = {
            init: function() {
                const getOptions = () => AssetTagSystem.getAssetDropdownOptions();
                
                this.appendDummyInput()
                    .appendField("‚ú® Spawn")
                    .appendField(new Blockly.FieldDropdown(getOptions), "SPRITE")
                    .appendField("at x:")
                    .appendField(new Blockly.FieldNumber(0, -500, 500), "X")
                    .appendField("y:")
                    .appendField(new Blockly.FieldNumber(0, -500, 500), "Y");
                this.setPreviousStatement(true, null);
                this.setNextStatement(true, null);
                this.setColour("#e67e22");
                this.setTooltip("Spawn a sprite at position. Tags appear with üè∑Ô∏è, asset names with üì¶");
                this.setHelpUrl("");
            }
        };

        Blockly.Blocks['destroy_sprite'] = {
            init: function() {
                this.appendDummyInput()
                    .appendField("üí£ Destroy")
                    .appendField(new Blockly.FieldDropdown([
                        ["This sprite", "THIS"],
                        ["All enemies", "ALL_ENEMIES"],
                        ["All coins", "ALL_COINS"]
                    ]), "TARGET");
                this.setPreviousStatement(true, null);
                this.setNextStatement(true, null);
                this.setColour("#e67e22");
                this.setTooltip("Destroy sprites");
                this.setHelpUrl("");
            }
        };

        Blockly.Blocks['add_score'] = {
            init: function() {
                this.appendDummyInput()
                    .appendField("üèÜ Add Score")
                    .appendField(new Blockly.FieldNumber(10, -1000, 1000), "POINTS")
                    .appendField("points");
                this.setPreviousStatement(true, null);
                this.setNextStatement(true, null);
                this.setColour("#e67e22");
                this.setTooltip("Add points to score");
                this.setHelpUrl("");
            }
        };

        Blockly.Blocks['create_keyframe'] = {
            init: function() {
                const getTagOptions = () => {
                    const tags = AssetTagSystem.getAllTags();
                    const options = [["-- Select Tag --", ""]];
                    tags.forEach(tag => {
                        options.push([`üè∑Ô∏è ${tag}`, tag]);
                    });
                    return options;
                };
                
                this.appendDummyInput()
                    .appendField("‚è±Ô∏è Create Keyframe for")
                    .appendField(new Blockly.FieldDropdown(getTagOptions), "TAG")
                    .appendField("at")
                    .appendField(new Blockly.FieldNumber(0, 0, 10000, 100), "TIME")
                    .appendField("ms");
                this.setPreviousStatement(true, null);
                this.setNextStatement(true, null);
                this.setColour("#9b59b6");
                this.setTooltip("Create a keyframe at a specific time for all entities with a tag");
                this.setHelpUrl("");
            }
        };

        Blockly.Blocks['set_keyframe_property'] = {
            init: function() {
                this.appendDummyInput()
                    .appendField("üéØ Set Keyframe")
                    .appendField(new Blockly.FieldDropdown([
                        ["Position X", "posX"],
                        ["Position Y", "posY"],
                        ["Scale X", "scaleX"],
                        ["Scale Y", "scaleY"],
                        ["Rotation", "rotation"],
                        ["Opacity", "opacity"],
                        ["Velocity X", "velX"],
                        ["Velocity Y", "velY"]
                    ]), "PROPERTY")
                    .appendField("to")
                    .appendField(new Blockly.FieldNumber(0, -1000, 1000, 1), "VALUE");
                this.setPreviousStatement(true, null);
                this.setNextStatement(true, null);
                this.setColour("#9b59b6");
                this.setTooltip("Set a property value for the current keyframe");
                this.setHelpUrl("");
            }
        };

        Blockly.Blocks['animate_keyframes'] = {
            init: function() {
                const getTagOptions = () => {
                    const tags = AssetTagSystem.getAllTags();
                    const options = [["-- Select Tag --", ""]];
                    tags.forEach(tag => {
                        options.push([`üè∑Ô∏è ${tag}`, tag]);
                    });
                    return options;
                };
                
                this.appendDummyInput()
                    .appendField("üé¨ Animate")
                    .appendField(new Blockly.FieldDropdown(getTagOptions), "TAG")
                    .appendField("from")
                    .appendField(new Blockly.FieldNumber(0, 0, 10000, 100), "START_TIME")
                    .appendField("ms to")
                    .appendField(new Blockly.FieldNumber(1000, 0, 10000, 100), "END_TIME")
                    .appendField("ms");
                
                this.appendDummyInput()
                    .appendField("Easing:")
                    .appendField(new Blockly.FieldDropdown([
                        ["Linear", "linear"],
                        ["Ease In", "easeIn"],
                        ["Ease Out", "easeOut"],
                        ["Ease In-Out", "easeInOut"]
                    ]), "EASING");
                    
                this.setPreviousStatement(true, null);
                this.setNextStatement(true, null);
                this.setColour("#9b59b6");
                this.setTooltip("Animate all entities with tag using keyframes");
                this.setHelpUrl("");
            }
        };

        Blockly.Blocks['play_animation'] = {
            init: function() {
                const getAnimationOptions = () => {
                    const options = [["-- Select Animation --", ""]];
                    Object.values(AssetManager.assets.animations || []).forEach(anim => {
                        options.push([`üé¨ ${anim.name}`, anim.name]);
                    });
                    return options;
                };
                
                this.appendDummyInput()
                    .appendField("üé¨ Play Animation")
                    .appendField(new Blockly.FieldDropdown(getAnimationOptions), "ANIMATION")
                    .appendField("on tag")
                    .appendField(new Blockly.FieldDropdown(() => {
                        const tags = AssetTagSystem.getAllTags();
                        const options = [["-- Select Tag --", ""]];
                        tags.forEach(tag => options.push([`üè∑Ô∏è${tag}`, tag]));
                        return options;
                    }), "TAG");
                
                this.appendDummyInput()
                    .appendField("Loop:")
                    .appendField(new Blockly.FieldCheckbox(true), "LOOP");
                    
                this.setPreviousStatement(true, null);
                this.setNextStatement(true, null);
                this.setColour("#f39c12");
                this.setTooltip("Play a sprite sheet animation on entities with a specific tag");
                this.setHelpUrl("");
            }
        };

        Blockly.Blocks['stop_animation'] = {
            init: function() {
                const getAnimationOptions = () => {
                    const options = [["-- Select Animation --", ""]];
                    Object.values(AssetManager.assets.animations || []).forEach(anim => {
                        options.push([`üé¨ ${anim.name}`, anim.name]);
                    });
                    return options;
                };
                
                this.appendDummyInput()
                    .appendField("‚èπÔ∏è Stop Animation")
                    .appendField(new Blockly.FieldDropdown(getAnimationOptions), "ANIMATION")
                    .appendField("on tag")
                    .appendField(new Blockly.FieldDropdown(() => {
                        const tags = AssetTagSystem.getAllTags();
                        const options = [["-- Select Tag --", ""]];
                        tags.forEach(tag => options.push([`üè∑Ô∏è${tag}`, tag]));
                        return options;
                    }), "TAG");
                
                this.setPreviousStatement(true, null);
                this.setNextStatement(true, null);
                this.setColour("#f39c12");
                this.setTooltip("Stop a playing animation on entities with a specific tag");
                this.setHelpUrl("");
            }
        };

        Blockly.Blocks['animation_with_keyframes'] = {
            init: function() {
                const getAnimationOptions = () => {
                    const options = [["-- Select Animation --", ""]];
                    Object.values(AssetManager.assets.animations || []).forEach(anim => {
                        options.push([`üé¨ ${anim.name}`, anim.name]);
                    });
                    return options;
                };
                
                this.appendDummyInput()
                    .appendField("üéûÔ∏è Animate with Keyframes")
                    .appendField(new Blockly.FieldDropdown(getAnimationOptions), "ANIMATION")
                    .appendField("on tag")
                    .appendField(new Blockly.FieldDropdown(() => {
                        const tags = AssetTagSystem.getAllTags();
                        const options = [["-- Select Tag --", ""]];
                        tags.forEach(tag => options.push([`üè∑Ô∏è${tag}`, tag]));
                        return options;
                    }), "TAG");
                
                this.appendDummyInput()
                    .appendField("Duration:")
                    .appendField(new Blockly.FieldNumber(1000, 0, 10000, 100), "DURATION")
                    .appendField("ms");
                
                this.appendStatementInput("KEYFRAMES")
                    .setCheck(null)
                    .appendField("with keyframes:");
                
                this.setPreviousStatement(true, null);
                this.setNextStatement(true, null);
                this.setColour("#f39c12");
                this.setTooltip("Play animation and apply keyframe transformations simultaneously");
                this.setHelpUrl("");
            }
        };

        // === MOVEMENT BLOCKS ===
        Blockly.Blocks['set_velocity'] = {
            init: function() {
                this.appendDummyInput()
                    .appendField("üöÄ Set Velocity")
                    .appendField(new Blockly.FieldDropdown([
                        ["X", "X"], ["Y", "Y"]
                    ]), "AXIS")
                    .appendField("to")
                    .appendField(new Blockly.FieldNumber(0, -500, 500), "VALUE");
                this.setPreviousStatement(true, null);
                this.setNextStatement(true, null);
                this.setColour("#9b59b6");
            }
        };

        Blockly.Blocks['apply_gravity'] = {
            init: function() {
                this.appendDummyInput()
                    .appendField("üåç Apply Gravity")
                    .appendField(new Blockly.FieldNumber(9.8, 0, 100, 0.1), "FORCE");
                this.setPreviousStatement(true, null);
                this.setNextStatement(true, null);
                this.setColour("#9b59b6");
            }
        };

        Blockly.Blocks['apply_friction'] = {
            init: function() {
                this.appendDummyInput()
                    .appendField("üî• Apply Friction")
                    .appendField(new Blockly.FieldNumber(0.9, 0, 1, 0.01), "AMOUNT");
                this.setPreviousStatement(true, null);
                this.setNextStatement(true, null);
                this.setColour("#9b59b6");
            }
        };

        // === COLLISION RESPONSE BLOCKS ===
        Blockly.Blocks['collision_response'] = {
            init: function() {
                this.appendDummyInput()
                    .appendField("üí• On Collision with")
                    .appendField(new Blockly.FieldDropdown([
                        ["Enemy", "ENEMY"],
                        ["Wall", "WALL"],
                        ["Coin", "COIN"],
                        ["Player", "PLAYER"]
                    ]), "TARGET")
                    .appendField("Response:")
                    .appendField(new Blockly.FieldDropdown([
                        ["Solid", "SOLID"],
                        ["Trigger", "TRIGGER"],
                        ["Bounce", "BOUNCE"],
                        ["Damage", "DAMAGE"]
                    ]), "RESPONSE");
                this.appendStatementInput("DO")
                    .setCheck(null)
                    .appendField("do");
                this.setColour("#e74c3c");
            }
        };

        // === CAMERA BLOCKS ===
        Blockly.Blocks['camera_follow'] = {
            init: function() {
                this.appendDummyInput()
                    .appendField("üì∑ Camera Follow")
                    .appendField(new Blockly.FieldDropdown([
                        ["Player", "PLAYER"],
                        ["Target", "TARGET"]
                    ]), "TARGET")
                    .appendField("Smoothing:")
                    .appendField(new Blockly.FieldNumber(0.1, 0, 1, 0.01), "SMOOTH");
                this.setPreviousStatement(true, null);
                this.setNextStatement(true, null);
                this.setColour("#3498db");
            }
        };

        Blockly.Blocks['camera_clamp'] = {
            init: function() {
                this.appendDummyInput()
                    .appendField("üìê Clamp Camera to Bounds")
                    .appendField("min X:")
                    .appendField(new Blockly.FieldNumber(0, -1000, 1000), "MINX")
                    .appendField("max X:")
                    .appendField(new Blockly.FieldNumber(800, -1000, 5000), "MAXX");
                this.setPreviousStatement(true, null);
                this.setNextStatement(true, null);
                this.setColour("#3498db");
            }
        };

        // === STATE & DATA BLOCKS ===
        Blockly.Blocks['set_variable'] = {
            init: function() {
                this.appendDummyInput()
                    .appendField("üìù Set Variable")
                    .appendField(new Blockly.FieldTextInput("myVar"), "VARNAME")
                    .appendField("to")
                    .appendField(new Blockly.FieldNumber(0), "VALUE");
                this.setPreviousStatement(true, null);
                this.setNextStatement(true, null);
                this.setColour("#f39c12");
            }
        };

        Blockly.Blocks['get_variable'] = {
            init: function() {
                this.appendDummyInput()
                    .appendField("üìñ Get Variable")
                    .appendField(new Blockly.FieldTextInput("myVar"), "VARNAME");
                this.setOutput(true, "Number");
                this.setColour("#f39c12");
            }
        };

        Blockly.Blocks['create_array'] = {
            init: function() {
                this.appendDummyInput()
                    .appendField("üìö Create Array")
                    .appendField(new Blockly.FieldTextInput("enemies"), "ARRAYNAME");
                this.setPreviousStatement(true, null);
                this.setNextStatement(true, null);
                this.setColour("#f39c12");
            }
        };

        Blockly.Blocks['array_push'] = {
            init: function() {
                this.appendDummyInput()
                    .appendField("‚ûï Add to Array")
                    .appendField(new Blockly.FieldTextInput("enemies"), "ARRAYNAME");
                this.appendValueInput("ITEM")
                    .setCheck(null)
                    .appendField("Item:");
                this.setPreviousStatement(true, null);
                this.setNextStatement(true, null);
                this.setColour("#f39c12");
            }
        };

        // === HEALTH & CORE SYSTEMS ===
        Blockly.Blocks['set_health'] = {
            init: function() {
                this.appendDummyInput()
                    .appendField("‚ù§Ô∏è Set Health")
                    .appendField(new Blockly.FieldNumber(100, 0, 1000), "VALUE");
                this.setPreviousStatement(true, null);
                this.setNextStatement(true, null);
                this.setColour("#e74c3c");
            }
        };

        Blockly.Blocks['add_health'] = {
            init: function() {
                this.appendDummyInput()
                    .appendField("üíä Add Health")
                    .appendField(new Blockly.FieldNumber(10, -100, 100), "AMOUNT");
                this.setPreviousStatement(true, null);
                this.setNextStatement(true, null);
                this.setColour("#27ae60");
            }
        };

        Blockly.Blocks['set_lives'] = {
            init: function() {
                this.appendDummyInput()
                    .appendField("üí´ Set Lives")
                    .appendField(new Blockly.FieldNumber(3, 0, 99), "VALUE");
                this.setPreviousStatement(true, null);
                this.setNextStatement(true, null);
                this.setColour("#e74c3c");
            }
        };

        // === SAVE/LOAD BLOCKS ===
        Blockly.Blocks['save_game'] = {
            init: function() {
                this.appendDummyInput()
                    .appendField("üíæ Save Game State");
                this.setPreviousStatement(true, null);
                this.setNextStatement(true, null);
                this.setColour("#16a085");
            }
        };

        Blockly.Blocks['load_game'] = {
            init: function() {
                this.appendDummyInput()
                    .appendField("üìÇ Load Game State");
                this.setPreviousStatement(true, null);
                this.setNextStatement(true, null);
                this.setColour("#16a085");
            }
        };

        // === ADVANCED LOGIC BLOCKS ===
        Blockly.Blocks['switch_case'] = {
            init: function() {
                this.appendValueInput("VALUE")
                    .appendField("üîÄ Switch");
                this.appendStatementInput("CASE0")
                    .appendField("Case")
                    .appendField(new Blockly.FieldTextInput("1"), "MATCH0");
                this.appendStatementInput("DEFAULT")
                    .appendField("Default");
                this.setColour("#5b67a5");
                this.setPreviousStatement(true, null);
                this.setNextStatement(true, null);
            }
        };

        Blockly.Blocks['while_loop'] = {
            init: function() {
                this.appendValueInput("CONDITION")
                    .setCheck("Boolean")
                    .appendField("üîÅ While");
                this.appendStatementInput("DO")
                    .appendField("do");
                this.setColour("#5b67a5");
                this.setPreviousStatement(true, null);
                this.setNextStatement(true, null);
            }
        };

        Blockly.Blocks['repeat_until'] = {
            init: function() {
                this.appendValueInput("CONDITION")
                    .setCheck("Boolean")
                    .appendField("üîÑ Repeat Until");
                this.appendStatementInput("DO")
                    .appendField("do");
                this.setColour("#5b67a5");
                this.setPreviousStatement(true, null);
                this.setNextStatement(true, null);
            }
        };

        Blockly.Blocks['loop_break'] = {
            init: function() {
                this.appendDummyInput()
                    .appendField("üõë Break Loop");
                this.setColour("#5b67a5");
                this.setPreviousStatement(true, null);
            }
        };

        Blockly.Blocks['loop_continue'] = {
            init: function() {
                this.appendDummyInput()
                    .appendField("‚è≠Ô∏è Continue Loop");
                this.setColour("#5b67a5");
                this.setPreviousStatement(true, null);
            }
        };

        Blockly.Blocks['delay'] = {
            init: function() {
                this.appendDummyInput()
                    .appendField("‚è±Ô∏è Delay")
                    .appendField(new Blockly.FieldNumber(1, 0.1, 10, 0.1), "SECONDS")
                    .appendField("seconds");
                this.appendStatementInput("THEN")
                    .appendField("then");
                this.setColour("#5b67a5");
                this.setPreviousStatement(true, null);
                this.setNextStatement(true, null);
            }
        };

        Blockly.Blocks['cooldown'] = {
            init: function() {
                this.appendDummyInput()
                    .appendField("‚ùÑÔ∏è Cooldown")
                    .appendField(new Blockly.FieldTextInput("shoot"), "NAME")
                    .appendField(new Blockly.FieldNumber(1, 0.1, 60), "DURATION")
                    .appendField("sec");
                this.appendStatementInput("DO")
                    .appendField("do");
                this.setColour("#5b67a5");
                this.setPreviousStatement(true, null);
                this.setNextStatement(true, null);
            }
        };

        Blockly.Blocks['random_choice'] = {
            init: function() {
                this.appendDummyInput()
                    .appendField("üé≤ Random")
                    .appendField(new Blockly.FieldNumber(1, 1, 100), "MIN")
                    .appendField("to")
                    .appendField(new Blockly.FieldNumber(10, 1, 100), "MAX");
                this.setOutput(true, "Number");
                this.setColour("#5b67a5");
            }
        };

        Blockly.Blocks['weighted_random'] = {
            init: function() {
                this.appendDummyInput()
                    .appendField("üéØ Weighted Random");
                this.appendValueInput("WEIGHT1")
                    .appendField("Option 1:");
                this.appendValueInput("WEIGHT2")
                    .appendField("Option 2:");
                this.setOutput(true, "Number");
                this.setColour("#5b67a5");
            }
        };

        Blockly.Blocks['define_function'] = {
            init: function() {
                this.appendDummyInput()
                    .appendField("‚ö° Function")
                    .appendField(new Blockly.FieldTextInput("myFunction"), "NAME");
                this.appendStatementInput("DO")
                    .appendField("do");
                this.setColour("#9b59b6");
                this.setPreviousStatement(true, null);
                this.setNextStatement(true, null);
            }
        };

        Blockly.Blocks['call_function'] = {
            init: function() {
                this.appendDummyInput()
                    .appendField("üìû Call")
                    .appendField(new Blockly.FieldTextInput("myFunction"), "NAME");
                this.setColour("#9b59b6");
                this.setPreviousStatement(true, null);
                this.setNextStatement(true, null);
            }
        };

        // === INVENTORY & POWERUP BLOCKS ===
        Blockly.Blocks['inventory_add'] = {
            init: function() {
                this.appendDummyInput()
                    .appendField("üéí Add to Inventory")
                    .appendField(new Blockly.FieldTextInput("item"), "ITEM")
                    .appendField("quantity:")
                    .appendField(new Blockly.FieldNumber(1, 1, 99), "QUANTITY");
                this.setPreviousStatement(true, null);
                this.setNextStatement(true, null);
                this.setColour("#f39c12");
            }
        };

        Blockly.Blocks['inventory_remove'] = {
            init: function() {
                this.appendDummyInput()
                    .appendField("üóëÔ∏è Remove from Inventory")
                    .appendField(new Blockly.FieldTextInput("item"), "ITEM")
                    .appendField("quantity:")
                    .appendField(new Blockly.FieldNumber(1, 1, 99), "QUANTITY");
                this.setPreviousStatement(true, null);
                this.setNextStatement(true, null);
                this.setColour("#f39c12");
            }
        };

        Blockly.Blocks['inventory_has'] = {
            init: function() {
                this.appendDummyInput()
                    .appendField("üì¶ Has Item")
                    .appendField(new Blockly.FieldTextInput("item"), "ITEM");
                this.setOutput(true, "Boolean");
                this.setColour("#f39c12");
            }
        };

        Blockly.Blocks['apply_powerup'] = {
            init: function() {
                this.appendDummyInput()
                    .appendField("‚ö° Apply Powerup")
                    .appendField(new Blockly.FieldDropdown([
                        ["Speed Boost", "speed"],
                        ["Invincibility", "invincible"],
                        ["Double Jump", "doublejump"],
                        ["Shield", "shield"]
                    ]), "TYPE")
                    .appendField("duration:")
                    .appendField(new Blockly.FieldNumber(5, 1, 60), "DURATION");
                this.setPreviousStatement(true, null);
                this.setNextStatement(true, null);
                this.setColour("#27ae60");
            }
        };

        Blockly.Blocks['apply_debuff'] = {
            init: function() {
                this.appendDummyInput()
                    .appendField("üêå Apply Debuff")
                    .appendField(new Blockly.FieldDropdown([
                        ["Slow", "slow"],
                        ["Poison", "poison"],
                        ["Stun", "stun"],
                        ["Weak", "weak"]
                    ]), "TYPE")
                    .appendField("duration:")
                    .appendField(new Blockly.FieldNumber(3, 1, 30), "DURATION");
                this.setPreviousStatement(true, null);
                this.setNextStatement(true, null);
                this.setColour("#e74c3c");
            }
        };

        Blockly.Blocks['has_buff'] = {
            init: function() {
                this.appendDummyInput()
                    .appendField("‚ú® Has Buff")
                    .appendField(new Blockly.FieldTextInput("speed"), "BUFF");
                this.setOutput(true, "Boolean");
                this.setColour("#27ae60");
            }
        };

        Blockly.Blocks['pickup_create'] = {
            init: function() {
                this.appendDummyInput()
                    .appendField("üíé Create Pickup")
                    .appendField(new Blockly.FieldDropdown([
                        ["Coin", "coin"],
                        ["Health", "health"],
                        ["Key", "key"],
                        ["Powerup", "powerup"]
                    ]), "TYPE")
                    .appendField("at x:")
                    .appendField(new Blockly.FieldNumber(0, -1000, 1000), "X")
                    .appendField("y:")
                    .appendField(new Blockly.FieldNumber(0, -1000, 1000), "Y");
                this.setPreviousStatement(true, null);
                this.setNextStatement(true, null);
                this.setColour("#f39c12");
            }
        };

        // === ADVANCED MOVEMENT & AI BLOCKS ===
        Blockly.Blocks['move_along_path'] = {
            init: function() {
                this.appendDummyInput()
                    .appendField("üõ§Ô∏è Move")
                    .appendField(new Blockly.FieldDropdown([["this", "this"], ["player", "player"]]), "OBJECT")
                    .appendField("along path")
                    .appendField(new Blockly.FieldTextInput("path1"), "PATH")
                    .appendField("speed:")
                    .appendField(new Blockly.FieldNumber(100, 1, 500), "SPEED");
                this.setPreviousStatement(true, null);
                this.setNextStatement(true, null);
                this.setColour("#9b59b6");
            }
        };

        Blockly.Blocks['find_path_to'] = {
            init: function() {
                this.appendDummyInput()
                    .appendField("üó∫Ô∏è Find Path to")
                    .appendField(new Blockly.FieldDropdown([["player", "player"], ["target", "target"]]), "TARGET");
                this.setPreviousStatement(true, null);
                this.setNextStatement(true, null);
                this.setColour("#9b59b6");
            }
        };

        Blockly.Blocks['ai_patrol'] = {
            init: function() {
                this.appendDummyInput()
                    .appendField("üö∂ AI Patrol between")
                    .appendField(new Blockly.FieldNumber(0, -1000, 1000), "X1")
                    .appendField("and")
                    .appendField(new Blockly.FieldNumber(400, -1000, 1000), "X2");
                this.setPreviousStatement(true, null);
                this.setNextStatement(true, null);
                this.setColour("#e67e22");
            }
        };

        Blockly.Blocks['ai_chase'] = {
            init: function() {
                this.appendDummyInput()
                    .appendField("üèÉ AI Chase")
                    .appendField(new Blockly.FieldDropdown([["player", "player"], ["target", "target"]]), "TARGET")
                    .appendField("speed:")
                    .appendField(new Blockly.FieldNumber(150, 1, 500), "SPEED");
                this.setPreviousStatement(true, null);
                this.setNextStatement(true, null);
                this.setColour("#e67e22");
            }
        };

        Blockly.Blocks['ai_flee'] = {
            init: function() {
                this.appendDummyInput()
                    .appendField("üò± AI Flee from")
                    .appendField(new Blockly.FieldDropdown([["player", "player"], ["danger", "danger"]]), "TARGET")
                    .appendField("speed:")
                    .appendField(new Blockly.FieldNumber(200, 1, 500), "SPEED");
                this.setPreviousStatement(true, null);
                this.setNextStatement(true, null);
                this.setColour("#e67e22");
            }
        };

        Blockly.Blocks['ai_init_state'] = {
            init: function() {
                this.appendValueInput("ENTITY")
                    .setCheck(null)
                    .appendField("üß† Initialize AI State for");
                this.appendDummyInput()
                    .appendField("Default State:")
                    .appendField(new Blockly.FieldTextInput("idle"), "DEFAULT_STATE");
                this.setPreviousStatement(true, null);
                this.setNextStatement(true, null);
                this.setColour("#3498db");
                this.setTooltip("Sets up the initial AI state for an entity.");
            }
        };

        Blockly.Blocks['ai_set_state'] = {
            init: function() {
                this.appendValueInput("ENTITY")
                    .setCheck(null)
                    .appendField("üß† Set AI State for");
                this.appendDummyInput()
                    .appendField("to:")
                    .appendField(new Blockly.FieldTextInput("patrolling"), "NEW_STATE");
                this.setPreviousStatement(true, null);
                this.setNextStatement(true, null);
                this.setColour("#3498db");
                this.setTooltip("Changes the AI state of an entity.");
            }
        };

        Blockly.Blocks['ai_is_in_state'] = {
            init: function() {
                this.appendValueInput("ENTITY")
                    .setCheck(null)
                    .appendField("üß† Is AI for");
                this.appendDummyInput()
                    .appendField("in state:")
                    .appendField(new Blockly.FieldTextInput("idle"), "STATE_NAME");
                this.setOutput(true, "Boolean");
                this.setColour("#3498db");
                this.setTooltip("Checks if an entity's AI is in a specific state.");
            }
        };

        Blockly.Blocks['jump_buffered'] = {
            init: function() {
                this.appendDummyInput()
                    .appendField("‚¨ÜÔ∏è Buffered Jump")
                    .appendField("force:")
                    .appendField(new Blockly.FieldNumber(300, 1, 1000), "FORCE")
                    .appendField("buffer:")
                    .appendField(new Blockly.FieldNumber(0.2, 0.05, 1, 0.05), "BUFFER");
                this.setPreviousStatement(true, null);
                this.setNextStatement(true, null);
                this.setColour("#9b59b6");
            }
        };

        Blockly.Blocks['dash'] = {
            init: function() {
                this.appendDummyInput()
                    .appendField("üí® Dash")
                    .appendField(new Blockly.FieldDropdown([["left", "LEFT"], ["right", "RIGHT"], ["up", "UP"], ["down", "DOWN"]]), "DIRECTION")
                    .appendField("distance:")
                    .appendField(new Blockly.FieldNumber(150, 1, 500), "DISTANCE");
                this.setPreviousStatement(true, null);
                this.setNextStatement(true, null);
                this.setColour("#9b59b6");
            }
        };

        Blockly.Blocks['knockback'] = {
            init: function() {
                this.appendDummyInput()
                    .appendField("üí• Knockback")
                    .appendField("force:")
                    .appendField(new Blockly.FieldNumber(200, 1, 1000), "FORCE")
                    .appendField("angle:")
                    .appendField(new Blockly.FieldNumber(45, 0, 360), "ANGLE");
                this.setPreviousStatement(true, null);
                this.setNextStatement(true, null);
                this.setColour("#9b59b6");
            }
        };

        Blockly.Blocks['set_ai_type'] = {
            init: function() {
                this.appendValueInput("ENTITY")
                    .setCheck(null)
                    .appendField("‚öôÔ∏è Set AI for");
                this.appendDummyInput()
                    .appendField("to")
                    .appendField(new Blockly.FieldDropdown([["Chase", "CHASE"], ["Flee", "FLEE"], ["Patrol", "PATROL"]]), "AI_TYPE");
                this.appendDummyInput("CHASE_PARAMS")
                    .appendField("Target Tag:")
                    .appendField(new Blockly.FieldTextInput("player"), "TARGET_TAG")
                    .appendField("Speed:")
                    .appendField(new Blockly.FieldNumber(150, 1, 500), "SPEED");
                this.setPreviousStatement(true, null);
                this.setNextStatement(true, null);
                this.setColour("#3498db");
                this.setTooltip("Configures AI behavior for an entity.");
            }
        };

        Blockly.Blocks['tilemap_create'] = {
            init: function() {
                this.appendDummyInput()
                    .appendField("üó∫Ô∏è Create Tilemap")
                    .appendField("Width (tiles):")
                    .appendField(new Blockly.FieldNumber(10, 1, 100), "WIDTH")
                    .appendField("Height (tiles):")
                    .appendField(new Blockly.FieldNumber(10, 1, 100), "HEIGHT")
                    .appendField("Tile Size (px):")
                    .appendField(new Blockly.FieldNumber(32, 8, 128), "TILE_SIZE");
                this.setOutput(true, "String");
                this.setColour("#9b59b6");
                this.setTooltip("Creates a new tilemap and returns its ID.");
            }
        };

        Blockly.Blocks['tilemap_set_tile'] = {
            init: function() {
                this.appendValueInput("TILEMAP_ID")
                    .setCheck("String")
                    .appendField("üó∫Ô∏è Set Tile on");
                this.appendDummyInput()
                    .appendField("at (")
                    .appendField(new Blockly.FieldNumber(0, 0, 100), "X")
                    .appendField(", ")
                    .appendField(new Blockly.FieldNumber(0, 0, 100), "Y")
                    .appendField(") to ID:")
                    .appendField(new Blockly.FieldNumber(0, -1, 999), "TILE_ID")
                    .appendField("Layer:")
                    .appendField(new Blockly.FieldDropdown([["Ground", "ground"], ["Objects", "objects"]]), "LAYER");
                this.setPreviousStatement(true, null);
                this.setNextStatement(true, null);
                this.setColour("#9b59b6");
                this.setTooltip("Sets a tile on a specific tilemap layer.");
            }
        };

        Blockly.Blocks['inventory_get_count'] = {
            init: function() {
                this.appendDummyInput()
                    .appendField("üéí Get Count of Item")
                    .appendField(new Blockly.FieldTextInput("wood"), "ITEM_ID");
                this.setOutput(true, "Number");
                this.setColour("#f39c12");
                this.setTooltip("Returns the total quantity of an item in the inventory.");
            }
        };

        Blockly.Blocks['inventory_swap_slots'] = {
            init: function() {
                this.appendDummyInput()
                    .appendField("üéí Swap Inventory Slots")
                    .appendField("Slot 1:")
                    .appendField(new Blockly.FieldNumber(0, 0, 19), "SLOT1")
                    .appendField("with Slot 2:")
                    .appendField(new Blockly.FieldNumber(1, 0, 19), "SLOT2");
                this.setPreviousStatement(true, null);
                this.setNextStatement(true, null);
                this.setColour("#f39c12");
                this.setTooltip("Swaps the contents of two inventory slots.");
            }
        };

        // === ADVANCED EVENT BLOCKS ===
        Blockly.Blocks['on_scene_load'] = {
            init: function() {
                this.appendDummyInput()
                    .appendField("üé¨ On Scene Load")
                    .appendField(new Blockly.FieldTextInput("main"), "SCENE");
                this.appendStatementInput("DO")
                    .appendField("do");
                this.setColour("#4a90e2");
            }
        };

        Blockly.Blocks['on_collision_tagged'] = {
            init: function() {
                this.appendDummyInput()
                    .appendField("üí• On")
                    .appendField(new Blockly.FieldDropdown([["player", "player"], ["enemy", "enemy"], ["coin", "coin"]]), "TAG1")
                    .appendField("hits")
                    .appendField(new Blockly.FieldDropdown([["enemy", "enemy"], ["wall", "wall"], ["pickup", "pickup"]]), "TAG2");
                this.appendStatementInput("DO")
                    .appendField("do");
                this.setColour("#4a90e2");
            }
        };

        Blockly.Blocks['on_mouse_click'] = {
            init: function() {
                this.appendDummyInput()
                    .appendField("üñ±Ô∏è On Mouse Click");
                this.appendStatementInput("DO")
                    .appendField("do");
                this.setColour("#4a90e2");
            }
        };

        Blockly.Blocks['on_object_destroyed'] = {
            init: function() {
                this.appendDummyInput()
                    .appendField("üíÄ When")
                    .appendField(new Blockly.FieldDropdown([["enemy", "enemy"], ["player", "player"]]), "TAG")
                    .appendField("destroyed");
                this.appendStatementInput("DO")
                    .appendField("do");
                this.setColour("#4a90e2");
            }
        };

        Blockly.Blocks['on_score_change'] = {
            init: function() {
                this.appendDummyInput()
                    .appendField("üìä When Score")
                    .appendField(new Blockly.FieldDropdown([["increases", "increase"], ["decreases", "decrease"]]), "TYPE");
                this.appendStatementInput("DO")
                    .appendField("do");
                this.setColour("#4a90e2");
            }
        };

        Blockly.Blocks['on_area_enter'] = {
            init: function() {
                this.appendDummyInput()
                    .appendField("üö™ On Enter Zone")
                    .appendField(new Blockly.FieldTextInput("zone1"), "ZONE");
                this.appendStatementInput("DO")
                    .appendField("do");
                this.setColour("#4a90e2");
            }
        };

        Blockly.Blocks['on_level_complete'] = {
            init: function() {
                this.appendDummyInput()
                    .appendField("üéâ On Level Complete");
                this.appendStatementInput("DO")
                    .appendField("do");
                this.setColour("#4a90e2");
            }
        };

        Blockly.Blocks['load_scene'] = {
            init: function() {
                this.appendDummyInput()
                    .appendField("üé¨ Load Scene")
                    .appendField(new Blockly.FieldTextInput("main"), "SCENE_NAME");
                this.setPreviousStatement(true, null);
                this.setNextStatement(true, null);
                this.setColour("#7b68ee");
                this.setTooltip("Load a new game scene/level");
            }
        };

        Blockly.Blocks['set_camera_target'] = {
            init: function() {
                this.appendValueInput("TARGET")
                    .setCheck(null)
                    .appendField("üì∑ Set Camera Target to");
                this.setPreviousStatement(true, null);
                this.setNextStatement(true, null);
                this.setColour("#7b68ee");
                this.setTooltip("Set the camera to follow an entity or position");
            }
        };

        Blockly.Blocks['pause_game'] = {
            init: function() {
                this.appendDummyInput()
                    .appendField("‚è∏Ô∏è Pause Game");
                this.setPreviousStatement(true, null);
                this.setNextStatement(true, null);
                this.setColour("#ff6b6b");
                this.setTooltip("Pause the game");
            }
        };

        Blockly.Blocks['resume_game'] = {
            init: function() {
                this.appendDummyInput()
                    .appendField("‚ñ∂Ô∏è Resume Game");
                this.setPreviousStatement(true, null);
                this.setNextStatement(true, null);
                this.setColour("#51cf66");
                this.setTooltip("Resume the game");
            }
        };

        Blockly.Blocks['set_time_scale'] = {
            init: function() {
                this.appendDummyInput()
                    .appendField("‚è±Ô∏è Set Time Scale to")
                    .appendField(new Blockly.FieldNumber(1, 0, 10), "SCALE");
                this.setPreviousStatement(true, null);
                this.setNextStatement(true, null);
                this.setColour("#7b68ee");
                this.setTooltip("Set game speed (1 = normal, 0.5 = half speed, 2 = double speed)");
            }
        };

        Blockly.Blocks['for_each_with_tag'] = {
            init: function() {
                this.appendDummyInput()
                    .appendField("üîÑ For each entity with tag")
                    .appendField(new Blockly.FieldTextInput("enemy"), "TAG");
                this.appendStatementInput("DO")
                    .appendField("do");
                this.setPreviousStatement(true, null);
                this.setNextStatement(true, null);
                this.setColour("#4a90e2");
                this.setTooltip("Loop through all entities with a specific tag");
            }
        };

        Blockly.Blocks['count_with_tag'] = {
            init: function() {
                this.appendDummyInput()
                    .appendField("üî¢ Count entities with tag")
                    .appendField(new Blockly.FieldTextInput("enemy"), "TAG");
                this.setOutput(true, "Number");
                this.setColour("#4a90e2");
                this.setTooltip("Returns the count of all entities with a specific tag");
            }
        };

        Blockly.Blocks['destroy_all_with_tag'] = {
            init: function() {
                this.appendDummyInput()
                    .appendField("üí• Destroy all entities with tag")
                    .appendField(new Blockly.FieldTextInput("enemy"), "TAG");
                this.setPreviousStatement(true, null);
                this.setNextStatement(true, null);
                this.setColour("#e74c3c");
                this.setTooltip("Destroys all entities with a specific tag");
            }
        };

        // ============ PHASE 1: NEW BLOCKS (INPUT, ENTITY, LOGIC) ============

        // === INPUT & CONTROLS (15 blocks) ===
        Blockly.Blocks['when_key_pressed'] = {
            init: function() {
                this.appendDummyInput()
                    .appendField("‚å®Ô∏è When Key")
                    .appendField(new Blockly.FieldTextInput("KeyA"), "KEY")
                    .appendField("Pressed");
                this.appendStatementInput("DO")
                    .setCheck(null)
                    .appendField("do");
                this.setColour("#4a90e2");
                this.setTooltip("When any keyboard key is pressed. Use key names like 'Space', 'ArrowUp', 'a', 'Enter'");
            }
        };

        Blockly.Blocks['when_key_released'] = {
            init: function() {
                this.appendDummyInput()
                    .appendField("‚å®Ô∏è When Key")
                    .appendField(new Blockly.FieldTextInput("KeyA"), "KEY")
                    .appendField("Released");
                this.appendStatementInput("DO")
                    .setCheck(null)
                    .appendField("do");
                this.setColour("#4a90e2");
                this.setTooltip("When a keyboard key is released");
            }
        };

        Blockly.Blocks['while_key_held'] = {
            init: function() {
                this.appendDummyInput()
                    .appendField("‚å®Ô∏è While Key")
                    .appendField(new Blockly.FieldTextInput("KeyA"), "KEY")
                    .appendField("Held");
                this.appendStatementInput("DO")
                    .setCheck(null)
                    .appendField("do");
                this.setColour("#4a90e2");
                this.setTooltip("While a key is being held down, execute this repeatedly");
            }
        };

        Blockly.Blocks['when_mouse_button_pressed'] = {
            init: function() {
                this.appendDummyInput()
                    .appendField("üñ±Ô∏è When Mouse")
                    .appendField(new Blockly.FieldDropdown([
                        ["Left Button", "LEFT"],
                        ["Right Button", "RIGHT"],
                        ["Middle Button", "MIDDLE"]
                    ]), "BUTTON")
                    .appendField("Pressed");
                this.appendStatementInput("DO")
                    .setCheck(null)
                    .appendField("do");
                this.setColour("#4a90e2");
                this.setTooltip("When a mouse button is pressed");
            }
        };

        Blockly.Blocks['when_mouse_button_released'] = {
            init: function() {
                this.appendDummyInput()
                    .appendField("üñ±Ô∏è When Mouse")
                    .appendField(new Blockly.FieldDropdown([
                        ["Left Button", "LEFT"],
                        ["Right Button", "RIGHT"],
                        ["Middle Button", "MIDDLE"]
                    ]), "BUTTON")
                    .appendField("Released");
                this.appendStatementInput("DO")
                    .setCheck(null)
                    .appendField("do");
                this.setColour("#4a90e2");
                this.setTooltip("When a mouse button is released");
            }
        };

        Blockly.Blocks['get_mouse_x'] = {
            init: function() {
                this.appendDummyInput()
                    .appendField("üñ±Ô∏è Mouse X");
                this.setOutput(true, "Number");
                this.setColour("#4a90e2");
                this.setTooltip("Get the current mouse X position");
            }
        };

        Blockly.Blocks['get_mouse_y'] = {
            init: function() {
                this.appendDummyInput()
                    .appendField("üñ±Ô∏è Mouse Y");
                this.setOutput(true, "Number");
                this.setColour("#4a90e2");
                this.setTooltip("Get the current mouse Y position");
            }
        };

        Blockly.Blocks['lock_cursor'] = {
            init: function() {
                this.appendDummyInput()
                    .appendField("üîí Lock Cursor");
                this.setPreviousStatement(true, null);
                this.setNextStatement(true, null);
                this.setColour("#4a90e2");
                this.setTooltip("Lock cursor to game canvas");
            }
        };

        Blockly.Blocks['unlock_cursor'] = {
            init: function() {
                this.appendDummyInput()
                    .appendField("üîì Unlock Cursor");
                this.setPreviousStatement(true, null);
                this.setNextStatement(true, null);
                this.setColour("#4a90e2");
                this.setTooltip("Unlock cursor from game canvas");
            }
        };

        Blockly.Blocks['enable_input'] = {
            init: function() {
                this.appendDummyInput()
                    .appendField("‚úÖ Enable Input");
                this.setPreviousStatement(true, null);
                this.setNextStatement(true, null);
                this.setColour("#4a90e2");
                this.setTooltip("Enable player input (keyboard/mouse)");
            }
        };

        Blockly.Blocks['disable_input'] = {
            init: function() {
                this.appendDummyInput()
                    .appendField("‚õî Disable Input");
                this.setPreviousStatement(true, null);
                this.setNextStatement(true, null);
                this.setColour("#4a90e2");
                this.setTooltip("Disable player input (keyboard/mouse)");
            }
        };

        Blockly.Blocks['is_input_enabled'] = {
            init: function() {
                this.appendDummyInput()
                    .appendField("Is Input Enabled?");
                this.setOutput(true, "Boolean");
                this.setColour("#4a90e2");
                this.setTooltip("Check if input is currently enabled");
            }
        };

        Blockly.Blocks['set_input_context'] = {
            init: function() {
                this.appendDummyInput()
                    .appendField("Set Input Context to")
                    .appendField(new Blockly.FieldDropdown([
                        ["Menu", "MENU"],
                        ["Gameplay", "GAMEPLAY"],
                        ["Cutscene", "CUTSCENE"]
                    ]), "CONTEXT");
                this.setPreviousStatement(true, null);
                this.setNextStatement(true, null);
                this.setColour("#4a90e2");
                this.setTooltip("Change input context for context-aware controls");
            }
        };

        Blockly.Blocks['is_key_pressed'] = {
            init: function() {
                this.appendDummyInput()
                    .appendField("Is Key")
                    .appendField(new Blockly.FieldTextInput("KeyA"), "KEY")
                    .appendField("Pressed?");
                this.setOutput(true, "Boolean");
                this.setColour("#4a90e2");
                this.setTooltip("Check if a specific key is currently pressed");
            }
        };

        // === ENTITY & TAG LOGIC (15 blocks) ===
        Blockly.Blocks['for_each_with_tag'] = {
            init: function() {
                const getTagOptions = () => {
                    const tags = AssetTagSystem.getAllTags();
                    const options = [["-- Select Tag --", ""]];
                    tags.forEach(tag => {
                        options.push([`üè∑Ô∏è ${tag}`, tag]);
                    });
                    return options;
                };

                this.appendDummyInput()
                    .appendField("For Each Entity with üè∑Ô∏è")
                    .appendField(new Blockly.FieldDropdown(getTagOptions), "TAG")
                    .appendField("as")
                    .appendField(new Blockly.FieldTextInput("entity"), "VAR");
                this.appendStatementInput("DO")
                    .setCheck(null)
                    .appendField("do");
                this.setPreviousStatement(true, null);
                this.setNextStatement(true, null);
                this.setColour("#e67e22");
                this.setTooltip("Loop through all entities with a specific tag");
            }
        };

        Blockly.Blocks['count_with_tag'] = {
            init: function() {
                const getTagOptions = () => {
                    const tags = AssetTagSystem.getAllTags();
                    const options = [["-- Select Tag --", ""]];
                    tags.forEach(tag => {
                        options.push([`üè∑Ô∏è ${tag}`, tag]);
                    });
                    return options;
                };

                this.appendDummyInput()
                    .appendField("Count Entities with üè∑Ô∏è")
                    .appendField(new Blockly.FieldDropdown(getTagOptions), "TAG");
                this.setOutput(true, "Number");
                this.setColour("#e67e22");
                this.setTooltip("Get the number of entities with a tag");
            }
        };

        Blockly.Blocks['destroy_all_with_tag'] = {
            init: function() {
                const getTagOptions = () => {
                    const tags = AssetTagSystem.getAllTags();
                    const options = [["-- Select Tag --", ""]];
                    tags.forEach(tag => {
                        options.push([`üè∑Ô∏è ${tag}`, tag]);
                    });
                    return options;
                };

                this.appendDummyInput()
                    .appendField("Destroy All üè∑Ô∏è")
                    .appendField(new Blockly.FieldDropdown(getTagOptions), "TAG");
                this.setPreviousStatement(true, null);
                this.setNextStatement(true, null);
                this.setColour("#e67e22");
                this.setTooltip("Remove all entities with a specific tag");
            }
        };

        Blockly.Blocks['clone_with_tag'] = {
            init: function() {
                const getTagOptions = () => {
                    const tags = AssetTagSystem.getAllTags();
                    const options = [["-- Select Tag --", ""]];
                    tags.forEach(tag => {
                        options.push([`üè∑Ô∏è ${tag}`, tag]);
                    });
                    return options;
                };

                this.appendDummyInput()
                    .appendField("Clone üè∑Ô∏è")
                    .appendField(new Blockly.FieldDropdown(getTagOptions), "TAG")
                    .appendField("at x:")
                    .appendField(new Blockly.FieldNumber(0, -5000, 5000), "X")
                    .appendField("y:")
                    .appendField(new Blockly.FieldNumber(0, -5000, 5000), "Y");
                this.setPreviousStatement(true, null);
                this.setNextStatement(true, null);
                this.setColour("#e67e22");
                this.setTooltip("Duplicate all entities with a tag at a new position");
            }
        };

        Blockly.Blocks['add_tag'] = {
            init: function() {
                const getTagOptions = () => {
                    const tags = AssetTagSystem.getAllTags();
                    const options = [["-- Select Tag --", ""]];
                    tags.forEach(tag => {
                        options.push([`üè∑Ô∏è ${tag}`, tag]);
                    });
                    return options;
                };

                this.appendValueInput("ENTITY")
                    .setCheck(null)
                    .appendField("Add Tag üè∑Ô∏è")
                    .appendField(new Blockly.FieldDropdown(getTagOptions), "TAG")
                    .appendField("to");
                this.setPreviousStatement(true, null);
                this.setNextStatement(true, null);
                this.setColour("#e67e22");
                this.setTooltip("Add a tag to an entity");
            }
        };

        Blockly.Blocks['remove_tag'] = {
            init: function() {
                const getTagOptions = () => {
                    const tags = AssetTagSystem.getAllTags();
                    const options = [["-- Select Tag --", ""]];
                    tags.forEach(tag => {
                        options.push([`üè∑Ô∏è ${tag}`, tag]);
                    });
                    return options;
                };

                this.appendValueInput("ENTITY")
                    .setCheck(null)
                    .appendField("Remove Tag üè∑Ô∏è")
                    .appendField(new Blockly.FieldDropdown(getTagOptions), "TAG")
                    .appendField("from");
                this.setPreviousStatement(true, null);
                this.setNextStatement(true, null);
                this.setColour("#e67e22");
                this.setTooltip("Remove a tag from an entity");
            }
        };

        Blockly.Blocks['has_tag'] = {
            init: function() {
                const getTagOptions = () => {
                    const tags = AssetTagSystem.getAllTags();
                    const options = [["-- Select Tag --", ""]];
                    tags.forEach(tag => {
                        options.push([`üè∑Ô∏è ${tag}`, tag]);
                    });
                    return options;
                };

                this.appendValueInput("ENTITY")
                    .setCheck(null)
                    .appendField("Does");
                this.appendDummyInput()
                    .appendField("have tag üè∑Ô∏è")
                    .appendField(new Blockly.FieldDropdown(getTagOptions), "TAG")
                    .appendField("?");
                this.setOutput(true, "Boolean");
                this.setColour("#e67e22");
                this.setTooltip("Check if entity has a specific tag");
            }
        };

        Blockly.Blocks['get_nearest_with_tag'] = {
            init: function() {
                const getTagOptions = () => {
                    const tags = AssetTagSystem.getAllTags();
                    const options = [["-- Select Tag --", ""]];
                    tags.forEach(tag => {
                        options.push([`üè∑Ô∏è ${tag}`, tag]);
                    });
                    return options;
                };

                this.appendValueInput("FROM")
                    .setCheck(null)
                    .appendField("Get Nearest üè∑Ô∏è")
                    .appendField(new Blockly.FieldDropdown(getTagOptions), "TAG")
                    .appendField("from");
                this.setOutput(true, null);
                this.setColour("#e67e22");
                this.setTooltip("Get the closest entity with a tag");
            }
        };

        Blockly.Blocks['get_random_with_tag'] = {
            init: function() {
                const getTagOptions = () => {
                    const tags = AssetTagSystem.getAllTags();
                    const options = [["-- Select Tag --", ""]];
                    tags.forEach(tag => {
                        options.push([`üè∑Ô∏è ${tag}`, tag]);
                    });
                    return options;
                };

                this.appendDummyInput()
                    .appendField("Get Random üè∑Ô∏è")
                    .appendField(new Blockly.FieldDropdown(getTagOptions), "TAG");
                this.setOutput(true, null);
                this.setColour("#e67e22");
                this.setTooltip("Get a random entity with a tag");
            }
        };

        Blockly.Blocks['get_all_with_tag'] = {
            init: function() {
                const getTagOptions = () => {
                    const tags = AssetTagSystem.getAllTags();
                    const options = [["-- Select Tag --", ""]];
                    tags.forEach(tag => {
                        options.push([`üè∑Ô∏è ${tag}`, tag]);
                    });
                    return options;
                };

                this.appendDummyInput()
                    .appendField("Get All üè∑Ô∏è")
                    .appendField(new Blockly.FieldDropdown(getTagOptions), "TAG");
                this.setOutput(true, "Array");
                this.setColour("#e67e22");
                this.setTooltip("Get an array of all entities with a tag");
            }
        };

        Blockly.Blocks['distance_to_nearest'] = {
            init: function() {
                const getTagOptions = () => {
                    const tags = AssetTagSystem.getAllTags();
                    const options = [["-- Select Tag --", ""]];
                    tags.forEach(tag => {
                        options.push([`üè∑Ô∏è ${tag}`, tag]);
                    });
                    return options;
                };

                this.appendValueInput("FROM")
                    .setCheck(null)
                    .appendField("Distance from")
                    .appendField("to nearest üè∑Ô∏è")
                    .appendField(new Blockly.FieldDropdown(getTagOptions), "TAG");
                this.setOutput(true, "Number");
                this.setColour("#e67e22");
                this.setTooltip("Get distance to the nearest entity with a tag");
            }
        };

        Blockly.Blocks['get_entity_position'] = {
            init: function() {
                this.appendValueInput("ENTITY")
                    .setCheck(null)
                    .appendField("Get")
                    .appendField(new Blockly.FieldDropdown([
                        ["X Position", "X"],
                        ["Y Position", "Y"]
                    ]), "AXIS")
                    .appendField("of");
                this.setOutput(true, "Number");
                this.setColour("#e67e22");
                this.setTooltip("Get the X or Y position of an entity");
            }
        };

        Blockly.Blocks['set_entity_position'] = {
            init: function() {
                this.appendValueInput("ENTITY")
                    .setCheck(null)
                    .appendField("Set Position of");
                this.appendValueInput("X")
                    .setCheck("Number")
                    .appendField("x:");
                this.appendValueInput("Y")
                    .setCheck("Number")
                    .appendField("y:");
                this.setPreviousStatement(true, null);
                this.setNextStatement(true, null);
                this.setColour("#e67e22");
                this.setTooltip("Set the X and Y position of an entity");
            }
        };

        Blockly.Blocks['on_tag_collision'] = {
            init: function() {
                const getTagOptions = () => {
                    const tags = AssetTagSystem.getAllTags();
                    const options = [["-- Select Tag --", ""]];
                    tags.forEach(tag => {
                        options.push([`üè∑Ô∏è ${tag}`, tag]);
                    });
                    return options;
                };

                this.appendDummyInput()
                    .appendField("When üè∑Ô∏è")
                    .appendField(new Blockly.FieldDropdown(getTagOptions), "TAG1")
                    .appendField("hits üè∑Ô∏è")
                    .appendField(new Blockly.FieldDropdown(getTagOptions), "TAG2");
                this.appendStatementInput("DO")
                    .setCheck(null)
                    .appendField("do");
                this.setColour("#4a90e2");
                this.setTooltip("When two tagged entities collide");
            }
        };

        Blockly.Blocks['tag_collision_exit'] = {
            init: function() {
                const getTagOptions = () => {
                    const tags = AssetTagSystem.getAllTags();
                    const options = [["-- Select Tag --", ""]];
                    tags.forEach(tag => {
                        options.push([`üè∑Ô∏è ${tag}`, tag]);
                    });
                    return options;
                };

                this.appendDummyInput()
                    .appendField("When üè∑Ô∏è")
                    .appendField(new Blockly.FieldDropdown(getTagOptions), "TAG1")
                    .appendField("leaves üè∑Ô∏è")
                    .appendField(new Blockly.FieldDropdown(getTagOptions), "TAG2");
                this.appendStatementInput("DO")
                    .setCheck(null)
                    .appendField("do");
                this.setColour("#4a90e2");
                this.setTooltip("When two tagged entities stop colliding");
            }
        };

        // === LOGIC & FLOW (15 blocks) ===
        Blockly.Blocks['for_loop'] = {
            init: function() {
                this.appendDummyInput()
                    .appendField("For")
                    .appendField(new Blockly.FieldTextInput("i"), "VAR")
                    .appendField("from");
                this.appendValueInput("FROM")
                    .setCheck("Number");
                this.appendValueInput("TO")
                    .setCheck("Number")
                    .appendField("to");
                this.appendStatementInput("DO")
                    .setCheck(null)
                    .appendField("do");
                this.setPreviousStatement(true, null);
                this.setNextStatement(true, null);
                this.setColour("#5b67a5");
                this.setTooltip("Loop from one number to another");
            }
        };

        Blockly.Blocks['repeat_n_times'] = {
            init: function() {
                this.appendValueInput("TIMES")
                    .setCheck("Number")
                    .appendField("Repeat");
                this.appendValueInput("TIMES2")
                    .setCheck("Number")
                    .appendField("times (or");
                this.appendDummyInput()
                    .appendField("times)");
                this.appendStatementInput("DO")
                    .setCheck(null)
                    .appendField("do");
                this.setPreviousStatement(true, null);
                this.setNextStatement(true, null);
                this.setColour("#5b67a5");
                this.setTooltip("Repeat a block N times");
            }
        };

        Blockly.Blocks['random_percent'] = {
            init: function() {
                this.appendValueInput("PERCENT")
                    .setCheck("Number")
                    .appendField("Random");
                this.appendDummyInput()
                    .appendField("% chance?");
                this.setOutput(true, "Boolean");
                this.setColour("#5b67a5");
                this.setTooltip("Return true X% of the time");
            }
        };

        Blockly.Blocks['weighted_choice'] = {
            init: function() {
                this.appendValueInput("OPTION1")
                    .setCheck(null)
                    .appendField("Choose from:");
                this.appendValueInput("WEIGHT1")
                    .setCheck("Number")
                    .appendField("(weight:");
                this.appendDummyInput()
                    .appendField(")");
                this.appendValueInput("OPTION2")
                    .setCheck(null)
                    .appendField("or");
                this.appendValueInput("WEIGHT2")
                    .setCheck("Number")
                    .appendField("(weight:");
                this.appendDummyInput()
                    .appendField(")");
                this.setOutput(true, null);
                this.setColour("#5b67a5");
                this.setTooltip("Randomly choose based on weights");
            }
        };

        Blockly.Blocks['cooldown_check'] = {
            init: function() {
                this.appendDummyInput()
                    .appendField("Is Cooldown")
                    .appendField(new Blockly.FieldTextInput("ability"), "NAME")
                    .appendField("ready?");
                this.setOutput(true, "Boolean");
                this.setColour("#5b67a5");
                this.setTooltip("Check if a cooldown has finished");
            }
        };

        Blockly.Blocks['set_cooldown'] = {
            init: function() {
                this.appendDummyInput()
                    .appendField("Set Cooldown")
                    .appendField(new Blockly.FieldTextInput("ability"), "NAME")
                    .appendField("for");
                this.appendValueInput("DURATION")
                    .setCheck("Number")
                    .appendField("seconds");
                this.setPreviousStatement(true, null);
                this.setNextStatement(true, null);
                this.setColour("#5b67a5");
                this.setTooltip("Start a cooldown timer");
            }
        };

        Blockly.Blocks['state_machine_init'] = {
            init: function() {
                this.appendDummyInput()
                    .appendField("Initialize State Machine")
                    .appendField(new Blockly.FieldTextInput("fsm"), "NAME")
                    .appendField("with states:")
                    .appendField(new Blockly.FieldTextInput("idle, run, jump, dash"), "STATES");
                this.setPreviousStatement(true, null);
                this.setNextStatement(true, null);
                this.setColour("#5b67a5");
                this.setTooltip("Create a state machine (comma-separated states)");
            }
        };

        Blockly.Blocks['state_machine_set'] = {
            init: function() {
                this.appendDummyInput()
                    .appendField("Set State Machine")
                    .appendField(new Blockly.FieldTextInput("fsm"), "NAME")
                    .appendField("to state:")
                    .appendField(new Blockly.FieldTextInput("idle"), "STATE");
                this.setPreviousStatement(true, null);
                this.setNextStatement(true, null);
                this.setColour("#5b67a5");
                this.setTooltip("Change the current state");
            }
        };

        Blockly.Blocks['state_machine_get'] = {
            init: function() {
                this.appendDummyInput()
                    .appendField("Get State from")
                    .appendField(new Blockly.FieldTextInput("fsm"), "NAME");
                this.setOutput(true, "String");
                this.setColour("#5b67a5");
                this.setTooltip("Get the current state");
            }
        };

        Blockly.Blocks['state_machine_is'] = {
            init: function() {
                this.appendDummyInput()
                    .appendField("Is State Machine")
                    .appendField(new Blockly.FieldTextInput("fsm"), "NAME")
                    .appendField("in state")
                    .appendField(new Blockly.FieldTextInput("idle"), "STATE")
                    .appendField("?");
                this.setOutput(true, "Boolean");
                this.setColour("#5b67a5");
                this.setTooltip("Check the current state");
            }
        };

        Blockly.Blocks['log_to_console'] = {
            init: function() {
                this.appendValueInput("VALUE")
                    .setCheck(null)
                    .appendField("Log to console:");
                this.setPreviousStatement(true, null);
                this.setNextStatement(true, null);
                this.setColour("#5b67a5");
                this.setTooltip("Print a value to the debug console");
            }
        };

        Blockly.Blocks['debug_assert'] = {
            init: function() {
                this.appendValueInput("CONDITION")
                    .setCheck("Boolean")
                    .appendField("Assert");
                this.appendValueInput("MESSAGE")
                    .setCheck("String")
                    .appendField("message if false:");
                this.setPreviousStatement(true, null);
                this.setNextStatement(true, null);
                this.setColour("#5b67a5");
                this.setTooltip("Assert a condition is true, log message if false");
            }
        };

        // ============ PRIORITY BLOCKS: AUDIO, PHYSICS, VISUAL EFFECTS ============

        // === AUDIO SYSTEM (3 blocks) ===
        Blockly.Blocks['play_sound'] = {
            init: function() {
                this.appendDummyInput()
                    .appendField("üîä Play Sound")
                    .appendField(new Blockly.FieldDropdown(() => {
                        try {
                            const am = typeof AssetManager !== 'undefined' ? AssetManager : (typeof EnhancedAssetManager !== 'undefined' ? EnhancedAssetManager : null);
                            const sounds = (am && am.assets && am.assets.sounds) || [];
                            return sounds.length > 0 
                                ? sounds.map(s => [s.name, s.id])
                                : [["No sounds", ""]];
                        } catch (e) {
                            console.warn('Sound dropdown error:', e);
                            return [["No sounds", ""]];
                        }
                    }), "SOUND")
                    .appendField("Volume:")
                    .appendField(new Blockly.FieldNumber(1, 0, 1, 0.1), "VOLUME")
                    .appendField(new Blockly.FieldCheckbox(false), "LOOP")
                    .appendField("Loop");
                this.setPreviousStatement(true, null);
                this.setNextStatement(true, null);
                this.setColour("#1abc9c");
                this.setTooltip("Play a sound effect with volume control");
            }
        };

        Blockly.Blocks['stop_sound'] = {
            init: function() {
                this.appendDummyInput()
                    .appendField("‚èπÔ∏è Stop Sound")
                    .appendField(new Blockly.FieldDropdown(() => {
                        try {
                            const am = typeof AssetManager !== 'undefined' ? AssetManager : (typeof EnhancedAssetManager !== 'undefined' ? EnhancedAssetManager : null);
                            const sounds = (am && am.assets && am.assets.sounds) || [];
                            return sounds.length > 0 
                                ? [["All Sounds", "ALL"], ...sounds.map(s => [s.name, s.id])]
                                : [["No sounds", ""]];
                        } catch (e) {
                            console.warn('Stop sound dropdown error:', e);
                            return [["No sounds", ""]];
                        }
                    }), "SOUND");
                this.setPreviousStatement(true, null);
                this.setNextStatement(true, null);
                this.setColour("#1abc9c");
                this.setTooltip("Stop a sound or all sounds");
            }
        };

        Blockly.Blocks['play_music'] = {
            init: function() {
                this.appendDummyInput()
                    .appendField("üéµ Play Music")
                    .appendField(new Blockly.FieldDropdown(() => {
                        try {
                            const am = typeof AssetManager !== 'undefined' ? AssetManager : (typeof EnhancedAssetManager !== 'undefined' ? EnhancedAssetManager : null);
                            const sounds = (am && am.assets && am.assets.sounds) || [];
                            return sounds.length > 0 
                                ? sounds.map(s => [s.name, s.id])
                                : [["No music", ""]];
                        } catch (e) {
                            console.warn('Play music dropdown error:', e);
                            return [["No music", ""]];
                        }
                    }), "MUSIC")
                    .appendField("Fade In:")
                    .appendField(new Blockly.FieldNumber(0, 0, 10, 0.5), "FADE")
                    .appendField("sec");
                this.setPreviousStatement(true, null);
                this.setNextStatement(true, null);
                this.setColour("#1abc9c");
                this.setTooltip("Play background music with optional fade-in");
            }
        };

        // === PHYSICS SYSTEM (3 blocks) ===
        Blockly.Blocks['apply_force'] = {
            init: function() {
                this.appendValueInput("ENTITY")
                    .setCheck(null)
                    .appendField("‚ö° Apply Force to");
                this.appendValueInput("FORCE_X")
                    .setCheck("Number")
                    .appendField("X:");
                this.appendValueInput("FORCE_Y")
                    .setCheck("Number")
                    .appendField("Y:");
                this.setPreviousStatement(true, null);
                this.setNextStatement(true, null);
                this.setColour("#9b59b6");
                this.setTooltip("Apply physics force to entity (acceleration-based)");
            }
        };

        Blockly.Blocks['is_grounded'] = {
            init: function() {
                this.appendValueInput("ENTITY")
                    .setCheck(null)
                    .appendField("üü¢ Is");
                this.appendDummyInput()
                    .appendField("Grounded?")
                    .appendField("Check Distance:")
                    .appendField(new Blockly.FieldNumber(5, 1, 50), "DISTANCE");
                this.setOutput(true, "Boolean");
                this.setColour("#9b59b6");
                this.setTooltip("Check if entity is touching ground (collision below)");
            }
        };

        Blockly.Blocks['raycast'] = {
            init: function() {
                this.appendValueInput("FROM_X")
                    .setCheck("Number")
                    .appendField("üì° Raycast from X:");
                this.appendValueInput("FROM_Y")
                    .setCheck("Number")
                    .appendField("Y:");
                this.appendValueInput("TO_X")
                    .setCheck("Number")
                    .appendField("to X:");
                this.appendValueInput("TO_Y")
                    .setCheck("Number")
                    .appendField("Y:");
                this.appendDummyInput()
                    .appendField("Tag Filter:")
                    .appendField(new Blockly.FieldDropdown(() => {
                        const tags = AssetTagSystem.getAllTags();
                        return [["Any", ""], ...tags.map(t => [t, t])];
                    }), "TAG");
                this.setOutput(true, null);
                this.setColour("#9b59b6");
                this.setTooltip("Cast a ray and return first entity hit");
            }
        };

        // === VISUAL EFFECTS (3 blocks) ===
        Blockly.Blocks['set_opacity'] = {
            init: function() {
                this.appendValueInput("ENTITY")
                    .setCheck(null)
                    .appendField("üëª Set Opacity of");
                this.appendValueInput("OPACITY")
                    .setCheck("Number")
                    .appendField("to");
                this.appendDummyInput()
                    .appendField("(0-1)");
                this.setPreviousStatement(true, null);
                this.setNextStatement(true, null);
                this.setColour("#f39c12");
                this.setTooltip("Set sprite transparency (0=invisible, 1=opaque)");
            }
        };

        Blockly.Blocks['flip_sprite'] = {
            init: function() {
                this.appendValueInput("ENTITY")
                    .setCheck(null)
                    .appendField("üîÑ Flip");
                this.appendDummyInput()
                    .appendField(new Blockly.FieldDropdown([
                        ["Horizontally", "H"],
                        ["Vertically", "V"],
                        ["Both", "BOTH"],
                        ["Reset", "NONE"]
                    ]), "DIRECTION");
                this.setPreviousStatement(true, null);
                this.setNextStatement(true, null);
                this.setColour("#f39c12");
                this.setTooltip("Flip sprite direction");
            }
        };

        Blockly.Blocks['camera_shake'] = {
            init: function() {
                this.appendDummyInput()
                    .appendField("üì∑ Camera Shake")
                    .appendField("Intensity:")
                    .appendField(new Blockly.FieldNumber(10, 1, 50), "INTENSITY")
                    .appendField("Duration:")
                    .appendField(new Blockly.FieldNumber(0.5, 0.1, 5, 0.1), "DURATION")
                    .appendField("sec");
                this.setPreviousStatement(true, null);
                this.setNextStatement(true, null);
                this.setColour("#3498db");
                this.setTooltip("Shake camera for visual impact");
            }
        };

        // === GAME STATE MANAGEMENT (5 blocks) ===
        Blockly.Blocks['pause_game'] = {
            init: function() {
                this.appendDummyInput()
                    .appendField("‚è∏Ô∏è Pause Game");
                this.setPreviousStatement(true, null);
                this.setNextStatement(true, null);
                this.setColour("#16a085");
                this.setTooltip("Pause all game updates");
            }
        };

        Blockly.Blocks['resume_game'] = {
            init: function() {
                this.appendDummyInput()
                    .appendField("‚ñ∂Ô∏è Resume Game");
                this.setPreviousStatement(true, null);
                this.setNextStatement(true, null);
                this.setColour("#16a085");
                this.setTooltip("Resume paused game");
            }
        };

        Blockly.Blocks['load_scene'] = {
            init: function() {
                this.appendValueInput("SCENE_NAME")
                    .setCheck("String")
                    .appendField("üé¨ Load Scene:");
                this.appendDummyInput()
                    .appendField(new Blockly.FieldCheckbox(true), "PRESERVE_STATE")
                    .appendField("Preserve State");
                this.setPreviousStatement(true, null);
                this.setNextStatement(true, null);
                this.setColour("#16a085");
                this.setTooltip("Load a different scene/level");
            }
        };

        Blockly.Blocks['game_over'] = {
            init: function() {
                this.appendDummyInput()
                    .appendField("üíÄ Game Over")
                    .appendField(new Blockly.FieldCheckbox(true), "SHOW_SCORE")
                    .appendField("Show Score");
                this.setPreviousStatement(true, null);
                this.setNextStatement(true, null);
                this.setColour("#16a085");
                this.setTooltip("End the game and show score");
            }
        };

        Blockly.Blocks['restart_level'] = {
            init: function() {
                this.appendDummyInput()
                    .appendField("üîÑ Restart Level");
                this.setPreviousStatement(true, null);
                this.setNextStatement(true, null);
                this.setColour("#16a085");
                this.setTooltip("Restart current level");
            }
        };

        // === COMBAT SYSTEM (2 blocks) ===
        Blockly.Blocks['deal_damage'] = {
            init: function() {
                this.appendValueInput("TARGET")
                    .setCheck(null)
                    .appendField("‚öîÔ∏è Deal");
                this.appendValueInput("DAMAGE")
                    .setCheck("Number")
                    .appendField("damage to");
                this.appendDummyInput()
                    .appendField(new Blockly.FieldCheckbox(true), "KNOCKBACK")
                    .appendField("Knockback");
                this.setPreviousStatement(true, null);
                this.setNextStatement(true, null);
                this.setColour("#e74c3c");
                this.setTooltip("Deal damage to entity");
            }
        };

        Blockly.Blocks['create_hitbox'] = {
            init: function() {
                this.appendValueInput("ENTITY")
                    .setCheck(null)
                    .appendField("ü•ä Create Hitbox on");
                this.appendValueInput("WIDTH")
                    .setCheck("Number")
                    .appendField("W:");
                this.appendValueInput("HEIGHT")
                    .setCheck("Number")
                    .appendField("H:");
                this.appendValueInput("DURATION")
                    .setCheck("Number")
                    .appendField("Duration (sec):");
                this.appendDummyInput()
                    .appendField("Offset X:")
                    .appendField(new Blockly.FieldNumber(0, -100, 100), "OFFSET_X")
                    .appendField("Y:")
                    .appendField(new Blockly.FieldNumber(0, -100, 100), "OFFSET_Y");
                this.setPreviousStatement(true, null);
                this.setNextStatement(true, null);
                this.setColour("#e74c3c");
                this.setTooltip("Create temporary damage hitbox");
            }
        };

        // === ADDITIONAL ESSENTIAL (1 block) ===
        Blockly.Blocks['set_z_layer'] = {
            init: function() {
                this.appendValueInput("ENTITY")
                    .setCheck(null)
                    .appendField("üìê Set Z-Layer of");
                this.appendValueInput("LAYER")
                    .setCheck("Number")
                    .appendField("to");
                this.setPreviousStatement(true, null);
                this.setNextStatement(true, null);
                this.setColour("#f39c12");
                this.setTooltip("Control draw order (higher = on top)");
            }
        };

        // === UI BLOCKS ===
        Blockly.Blocks['ui_button'] = {
            init: function() {
                this.appendDummyInput()
                    .appendField("üîò Button")
                    .appendField(new Blockly.FieldTextInput("Click Me"), "TEXT");
                this.appendValueInput("X")
                    .setCheck("Number")
                    .appendField("at x:");
                this.appendValueInput("Y")
                    .setCheck("Number")
                    .appendField("y:");
                this.appendValueInput("WIDTH")
                    .setCheck("Number")
                    .appendField("width:");
                this.appendValueInput("HEIGHT")
                    .setCheck("Number")
                    .appendField("height:");
                this.appendStatementInput("ON_CLICK")
                    .setCheck(null)
                    .appendField("on click do");
                this.setPreviousStatement(true, null);
                this.setNextStatement(true, null);
                this.setColour("#3498db");
                this.setTooltip("Create a clickable button at position");
            }
        };

        Blockly.Blocks['ui_text'] = {
            init: function() {
                this.appendDummyInput()
                    .appendField("üìù Text")
                    .appendField(new Blockly.FieldTextInput("Hello World"), "CONTENT");
                this.appendValueInput("X")
                    .setCheck("Number")
                    .appendField("at x:");
                this.appendValueInput("Y")
                    .setCheck("Number")
                    .appendField("y:");
                this.appendValueInput("SIZE")
                    .setCheck("Number")
                    .appendField("size:");
                this.appendDummyInput()
                    .appendField("color:")
                    .appendField(new Blockly.FieldColour("#ffffff"), "COLOR");
                this.setPreviousStatement(true, null);
                this.setNextStatement(true, null);
                this.setColour("#3498db");
                this.setTooltip("Display text on screen at position");
            }
        };

        Blockly.Blocks['ui_dialog'] = {
            init: function() {
                this.appendDummyInput()
                    .appendField("üí¨ Dialog Box")
                    .appendField(new Blockly.FieldTextInput("Message"), "TITLE");
                this.appendValueInput("MESSAGE")
                    .setCheck("String")
                    .appendField("message:");
                this.appendDummyInput()
                    .appendField("buttons:")
                    .appendField(new Blockly.FieldTextInput("OK,Cancel"), "BUTTONS");
                this.appendStatementInput("ON_BUTTON_CLICK")
                    .setCheck(null)
                    .appendField("on button click do");
                this.setPreviousStatement(true, null);
                this.setNextStatement(true, null);
                this.setColour("#3498db");
                this.setTooltip("Show a dialog box with custom buttons");
            }
        };

        Blockly.Blocks['ui_hud_element'] = {
            init: function() {
                this.appendDummyInput()
                    .appendField("üìä HUD Element")
                    .appendField(new Blockly.FieldDropdown([
                        ["Health Bar", "Health Bar"],
                        ["Score", "Score"],
                        ["Timer", "Timer"],
                        ["Custom", "Custom"]
                    ]), "TYPE");
                this.appendValueInput("X")
                    .setCheck("Number")
                    .appendField("at x:");
                this.appendValueInput("Y")
                    .setCheck("Number")
                    .appendField("y:");
                this.appendValueInput("WIDTH")
                    .setCheck("Number")
                    .appendField("width:");
                this.appendValueInput("HEIGHT")
                    .setCheck("Number")
                    .appendField("height:");
                this.appendDummyInput()
                    .appendField("variable:")
                    .appendField(new Blockly.FieldTextInput("score"), "VARIABLE");
                this.setPreviousStatement(true, null);
                this.setNextStatement(true, null);
                this.setColour("#3498db");
                this.setTooltip("Add a HUD element like health bar or score");
            }
        };

        Blockly.Blocks['ui_menu'] = {
            init: function() {
                this.appendDummyInput()
                    .appendField("üéØ Menu")
                    .appendField(new Blockly.FieldTextInput("Main Menu"), "TITLE");
                this.appendDummyInput()
                    .appendField("items:")
                    .appendField(new Blockly.FieldTextInput("Start Game,Options,Quit"), "ITEMS");
                this.appendStatementInput("ON_ITEM_SELECT")
                    .setCheck(null)
                    .appendField("on item select do");
                this.setPreviousStatement(true, null);
                this.setNextStatement(true, null);
                this.setColour("#3498db");
                this.setTooltip("Create a menu with selectable items");
            }
        };

        Blockly.Blocks['ui_get_input_value'] = {
            init: function() {
                this.appendDummyInput()
                    .appendField("‚å®Ô∏è Get Input Value")
                    .appendField(new Blockly.FieldTextInput("username"), "NAME");
                this.setOutput(true, "String");
                this.setColour("#3498db");
                this.setTooltip("Get value from UI input field");
            }
        };

        Blockly.Blocks['ui_show_notification'] = {
            init: function() {
                this.appendDummyInput()
                    .appendField("üîî Show Notification")
                    .appendField(new Blockly.FieldTextInput("Achievement Unlocked!"), "MESSAGE");
                this.appendValueInput("SECONDS")
                    .setCheck("Number")
                    .appendField("for (sec):");
                this.setPreviousStatement(true, null);
                this.setNextStatement(true, null);
                this.setColour("#3498db");
                this.setTooltip("Show notification message for duration");
            }
        };

        Blockly.Blocks['ui_inventory_display'] = {
            init: function() {
                this.appendDummyInput()
                    .appendField("üéí Inventory Display");
                this.appendValueInput("X")
                    .setCheck("Number")
                    .appendField("at x:");
                this.appendValueInput("Y")
                    .setCheck("Number")
                    .appendField("y:");
                this.appendValueInput("SLOT_COUNT")
                    .setCheck("Number")
                    .appendField("slots:");
                this.appendValueInput("SLOT_SIZE")
                    .setCheck("Number")
                    .appendField("size:");
                this.setPreviousStatement(true, null);
                this.setNextStatement(true, null);
                this.setColour("#3498db");
                this.setTooltip("Display inventory with slots");
            }
        };

        // === TOUCH & GESTURE BLOCKS ===
        Blockly.Blocks['on_touch_start'] = {
            init: function() {
                this.appendDummyInput()
                    .appendField("üëÜ On Touch Start");
                this.appendStatementInput("DO")
                    .setCheck(null)
                    .appendField("do");
                this.setColour("#e74c3c");
                this.setTooltip("Runs when finger touches screen");
            }
        };

        Blockly.Blocks['on_swipe'] = {
            init: function() {
                this.appendDummyInput()
                    .appendField("‚ÜóÔ∏è On Swipe")
                    .appendField(new Blockly.FieldDropdown([
                        ["Any", "any"],
                        ["Left", "left"],
                        ["Right", "right"],
                        ["Up", "up"],
                        ["Down", "down"]
                    ]), "DIRECTION");
                this.appendStatementInput("DO")
                    .setCheck(null)
                    .appendField("do");
                this.setColour("#e74c3c");
                this.setTooltip("Runs when user swipes finger");
            }
        };

        Blockly.Blocks['on_pinch'] = {
            init: function() {
                this.appendDummyInput()
                    .appendField("ü§è On Pinch");
                this.appendStatementInput("DO")
                    .setCheck(null)
                    .appendField("do");
                this.setColour("#e74c3c");
                this.setTooltip("Runs when user pinches (two-finger zoom)");
            }
        };

        Blockly.Blocks['on_double_tap'] = {
            init: function() {
                this.appendDummyInput()
                    .appendField("üëÜüëÜ On Double Tap");
                this.appendStatementInput("DO")
                    .setCheck(null)
                    .appendField("do");
                this.setColour("#e74c3c");
                this.setTooltip("Runs when user taps twice quickly");
            }
        };

        Blockly.Blocks['get_touch_count'] = {
            init: function() {
                this.appendDummyInput()
                    .appendField("üëÜ Touch Count");
                this.setOutput(true, "Number");
                this.setColour("#e74c3c");
                this.setTooltip("Number of fingers currently touching screen");
            }
        };

        Blockly.Blocks['get_touch_position'] = {
            init: function() {
                this.appendDummyInput()
                    .appendField("üìç Touch Position")
                    .appendField(new Blockly.FieldDropdown([
                        ["X", "x"],
                        ["Y", "y"]
                    ]), "AXIS")
                    .appendField("finger:")
                    .appendField(new Blockly.FieldNumber(0, 0, 10, 1), "INDEX");
                this.setOutput(true, "Number");
                this.setColour("#e74c3c");
                this.setTooltip("Get X or Y position of touch point");
            }
        };

        // === EXPORT BLOCKS REMOVED (Not part of V1) ===

        // Code generators
        Blockly.JavaScript.forBlock['on_game_start'] = function(block) {
            var statements = Blockly.JavaScript.statementToCode(block, 'DO');
            return 'onGameStart(() => {\n' + statements + '});\n';
        };

        Blockly.JavaScript.forBlock['on_key_press'] = function(block) {
            var key = block.getFieldValue('KEY');
            var statements = Blockly.JavaScript.statementToCode(block, 'DO');
            return 'onKeyPress("' + key + '", () => {\n' + statements + '});\n';
        };

        Blockly.JavaScript.forBlock['on_collision'] = function(block) {
            var obj1 = block.getFieldValue('OBJECT1');
            var obj2 = block.getFieldValue('OBJECT2');
            var statements = Blockly.JavaScript.statementToCode(block, 'DO');
            return 'onCollision("' + obj1 + '", "' + obj2 + '", () => {\n' + statements + '});\n';
        };

        Blockly.JavaScript.forBlock['on_timer'] = function(block) {
            var seconds = block.getFieldValue('SECONDS');
            var statements = Blockly.JavaScript.statementToCode(block, 'DO');
            return 'everySeconds(' + seconds + ', () => {\n' + statements + '});\n';
        };

        Blockly.JavaScript.forBlock['move_player'] = function(block) {
            var direction = block.getFieldValue('DIRECTION');
            var amount = block.getFieldValue('AMOUNT');
            return 'movePlayer("' + direction + '", ' + amount + ');\n';
        };

        Blockly.JavaScript.forBlock['spawn_sprite'] = function(block) {
            var sprite = block.getFieldValue('SPRITE');
            var x = block.getFieldValue('X');
            var y = block.getFieldValue('Y');
            return 'spawnSprite("' + sprite + '", ' + x + ', ' + y + ');\n';
        };

        Blockly.JavaScript.forBlock['destroy_sprite'] = function(block) {
            var target = block.getFieldValue('TARGET');
            return 'destroySprite("' + target + '");\n';
        };

        Blockly.JavaScript.forBlock['add_score'] = function(block) {
            var points = block.getFieldValue('POINTS');
            return 'addScore(' + points + ');\n';
        };

        Blockly.JavaScript.forBlock['create_keyframe'] = function(block) {
            const tag = block.getFieldValue('TAG');
            const time = block.getFieldValue('TIME');
            return `createKeyframeForTag("${tag}", ${time});\n`;
        };

        Blockly.JavaScript.forBlock['set_keyframe_property'] = function(block) {
            const property = block.getFieldValue('PROPERTY');
            const value = block.getFieldValue('VALUE');
            return `setKeyframeProperty("${property}", ${value});\n`;
        };

        Blockly.JavaScript.forBlock['animate_keyframes'] = function(block) {
            const tag = block.getFieldValue('TAG');
            const startTime = block.getFieldValue('START_TIME');
            const endTime = block.getFieldValue('END_TIME');
            const easing = block.getFieldValue('EASING');
            return `animateKeyframes("${tag}", ${startTime}, ${endTime}, "${easing}");\n`;
        };

        Blockly.JavaScript.forBlock['play_animation'] = function(block) {
            const animation = block.getFieldValue('ANIMATION');
            const tag = block.getFieldValue('TAG');
            const loop = block.getFieldValue('LOOP') === 'TRUE';
            return `playAnimationOnTag("${animation}", "${tag}", {loop: ${loop}});\n`;
        };

        Blockly.JavaScript.forBlock['stop_animation'] = function(block) {
            const animation = block.getFieldValue('ANIMATION');
            const tag = block.getFieldValue('TAG');
            return `stopAnimationOnTag("${animation}", "${tag}");\n`;
        };

        Blockly.JavaScript.forBlock['animation_with_keyframes'] = function(block) {
            const animation = block.getFieldValue('ANIMATION');
            const tag = block.getFieldValue('TAG');
            const duration = block.getFieldValue('DURATION');
            const keyframeStatements = Blockly.JavaScript.statementToCode(block, 'KEYFRAMES');
            return `playAnimationWithKeyframes("${animation}", "${tag}", ${duration}, () => {\n${keyframeStatements}});\n`;
        };

        // === MOVEMENT GENERATORS ===
        Blockly.JavaScript.forBlock['set_velocity'] = function(block) {
            const axis = block.getFieldValue('AXIS');
            const value = block.getFieldValue('VALUE');
            return `setVelocity("${axis}", ${value});\n`;
        };

        Blockly.JavaScript.forBlock['apply_gravity'] = function(block) {
            const force = block.getFieldValue('FORCE');
            return `applyGravity(${force});\n`;
        };

        Blockly.JavaScript.forBlock['apply_friction'] = function(block) {
            const amount = block.getFieldValue('AMOUNT');
            return `applyFriction(${amount});\n`;
        };

        // === COLLISION GENERATORS ===
        Blockly.JavaScript.forBlock['collision_response'] = function(block) {
            const target = block.getFieldValue('TARGET');
            const response = block.getFieldValue('RESPONSE');
            const statements = Blockly.JavaScript.statementToCode(block, 'DO');
            return `onCollisionResponse("${target}", "${response}", () => {\n${statements}});\n`;
        };

        // === CAMERA GENERATORS ===
        Blockly.JavaScript.forBlock['camera_follow'] = function(block) {
            const target = block.getFieldValue('TARGET');
            const smooth = block.getFieldValue('SMOOTH');
            return `cameraFollow("${target}", ${smooth});\n`;
        };

        Blockly.JavaScript.forBlock['camera_clamp'] = function(block) {
            const minX = block.getFieldValue('MINX');
            const maxX = block.getFieldValue('MAXX');
            return `cameraClamp(${minX}, ${maxX});\n`;
        };

        // === STATE GENERATORS ===
        Blockly.JavaScript.forBlock['set_variable'] = function(block) {
            const varName = block.getFieldValue('VARNAME');
            const value = block.getFieldValue('VALUE');
            return `gameState["${varName}"] = ${value};\n`;
        };

        Blockly.JavaScript.forBlock['get_variable'] = function(block) {
            const varName = block.getFieldValue('VARNAME');
            return [`gameState["${varName}"]`, Blockly.JavaScript.ORDER_MEMBER];
        };

        Blockly.JavaScript.forBlock['create_array'] = function(block) {
            const arrayName = block.getFieldValue('ARRAYNAME');
            return `gameState["${arrayName}"] = [];\n`;
        };

        Blockly.JavaScript.forBlock['array_push'] = function(block) {
            const arrayName = block.getFieldValue('ARRAYNAME');
            const item = Blockly.JavaScript.valueToCode(block, 'ITEM', Blockly.JavaScript.ORDER_NONE) || 'null';
            return `gameState["${arrayName}"].push(${item});\n`;
        };

        // === HEALTH GENERATORS ===
        Blockly.JavaScript.forBlock['set_health'] = function(block) {
            const value = block.getFieldValue('VALUE');
            return `setHealth(${value});\n`;
        };

        Blockly.JavaScript.forBlock['add_health'] = function(block) {
            const amount = block.getFieldValue('AMOUNT');
            return `addHealth(${amount});\n`;
        };

        Blockly.JavaScript.forBlock['set_lives'] = function(block) {
            const value = block.getFieldValue('VALUE');
            return `setLives(${value});\n`;
        };

        // === SAVE/LOAD GENERATORS ===
        Blockly.JavaScript.forBlock['save_game'] = function(block) {
            return `saveGameState();\n`;
        };

        Blockly.JavaScript.forBlock['load_game'] = function(block) {
            return `loadGameState();\n`;
        };

        // === SNIPPET 2 CODE GENERATORS ===
        Blockly.JavaScript.forBlock['on_scene_load'] = function(block) {
            const scene = block.getFieldValue('SCENE');
            const statements = Blockly.JavaScript.statementToCode(block, 'DO');
            return `onSceneLoad("${scene}", () => {\n${statements}});\n`;
        };

        Blockly.JavaScript.forBlock['on_collision_tagged'] = function(block) {
            const tag1 = block.getFieldValue('TAG1');
            const tag2 = block.getFieldValue('TAG2');
            const statements = Blockly.JavaScript.statementToCode(block, 'DO');
            return `onCollisionTagged("${tag1}", "${tag2}", () => {\n${statements}});\n`;
        };

        Blockly.JavaScript.forBlock['on_mouse_click'] = function(block) {
            const statements = Blockly.JavaScript.statementToCode(block, 'DO');
            return `onMouseClick(() => {\n${statements}});\n`;
        };

        Blockly.JavaScript.forBlock['on_object_destroyed'] = function(block) {
            const tag = block.getFieldValue('TAG');
            const statements = Blockly.JavaScript.statementToCode(block, 'DO');
            return `onObjectDestroyed("${tag}", () => {\n${statements}});\n`;
        };

        Blockly.JavaScript.forBlock['on_score_change'] = function(block) {
            const type = block.getFieldValue('TYPE');
            const statements = Blockly.JavaScript.statementToCode(block, 'DO');
            return `onScoreChange("${type}", () => {\n${statements}});\n`;
        };

        Blockly.JavaScript.forBlock['on_area_enter'] = function(block) {
            const zone = block.getFieldValue('ZONE');
            const statements = Blockly.JavaScript.statementToCode(block, 'DO');
            return `onAreaEnter("${zone}", () => {\n${statements}});\n`;
        };

        Blockly.JavaScript.forBlock['on_level_complete'] = function(block) {
            const statements = Blockly.JavaScript.statementToCode(block, 'DO');
            return `onLevelComplete(() => {\n${statements}});\n`;
        };

        Blockly.JavaScript.forBlock['load_scene'] = function(block) {
            const sceneName = block.getFieldValue('SCENE_NAME');
            return `loadScene("${sceneName}");\n`;
        };

        Blockly.JavaScript.forBlock['set_camera_target'] = function(block) {
            const target = Blockly.JavaScript.valueToCode(block, 'TARGET', Blockly.JavaScript.ORDER_NONE) || 'null';
            return `setCameraTarget(${target});\n`;
        };

        Blockly.JavaScript.forBlock['pause_game'] = function(block) {
            return `pauseGame();\n`;
        };

        Blockly.JavaScript.forBlock['resume_game'] = function(block) {
            return `resumeGame();\n`;
        };

        Blockly.JavaScript.forBlock['set_time_scale'] = function(block) {
            const scale = block.getFieldValue('SCALE');
            return `setTimeScale(${scale});\n`;
        };

        Blockly.JavaScript.forBlock['for_each_with_tag'] = function(block) {
            const tag = block.getFieldValue('TAG');
            const statements = Blockly.JavaScript.statementToCode(block, 'DO');
            return `forEachWithTag("${tag}", (entity) => {\n${statements}});\n`;
        };

        Blockly.JavaScript.forBlock['count_with_tag'] = function(block) {
            const tag = block.getFieldValue('TAG');
            return [`countWithTag("${tag}")`, Blockly.JavaScript.ORDER_FUNCTION_CALL];
        };

        Blockly.JavaScript.forBlock['destroy_all_with_tag'] = function(block) {
            const tag = block.getFieldValue('TAG');
            return `destroyAllWithTag("${tag}");\n`;
        };

        // === SNIPPET 3 CODE GENERATORS ===
        Blockly.JavaScript.forBlock['move_along_path'] = function(block) {
            const object = block.getFieldValue('OBJECT');
            const path = block.getFieldValue('PATH');
            const speed = block.getFieldValue('SPEED');
            return `moveAlongPath("${object}", "${path}", ${speed});\n`;
        };

        Blockly.JavaScript.forBlock['find_path_to'] = function(block) {
            const target = block.getFieldValue('TARGET');
            return `findPathTo("${target}");\n`;
        };

        Blockly.JavaScript.forBlock['ai_patrol'] = function(block) {
            const x1 = block.getFieldValue('X1');
            const x2 = block.getFieldValue('X2');
            return `aiPatrol(${x1}, ${x2});\n`;
        };

        Blockly.JavaScript.forBlock['ai_chase'] = function(block) {
            const target = block.getFieldValue('TARGET');
            const speed = block.getFieldValue('SPEED');
            return `aiChase("${target}", ${speed});\n`;
        };

        Blockly.JavaScript.forBlock['ai_flee'] = function(block) {
            const target = block.getFieldValue('TARGET');
            const speed = block.getFieldValue('SPEED');
            return `aiFlee("${target}", ${speed});\n`;
        };

        Blockly.JavaScript.forBlock['ai_init_state'] = function(block) {
            const entity = Blockly.JavaScript.valueToCode(block, 'ENTITY', Blockly.JavaScript.ORDER_NONE) || 'null';
            const defaultState = block.getFieldValue('DEFAULT_STATE');
            return `aiInitState(${entity}, "${defaultState}");\n`;
        };

        Blockly.JavaScript.forBlock['ai_set_state'] = function(block) {
            const entity = Blockly.JavaScript.valueToCode(block, 'ENTITY', Blockly.JavaScript.ORDER_NONE) || 'null';
            const newState = block.getFieldValue('NEW_STATE');
            return `aiSetState(${entity}, "${newState}");\n`;
        };

        Blockly.JavaScript.forBlock['ai_is_in_state'] = function(block) {
            const entity = Blockly.JavaScript.valueToCode(block, 'ENTITY', Blockly.JavaScript.ORDER_NONE) || 'null';
            const stateName = block.getFieldValue('STATE_NAME');
            return [`aiIsInState(${entity}, "${stateName}")`, Blockly.JavaScript.ORDER_FUNCTION_CALL];
        };

        Blockly.JavaScript.forBlock['jump_buffered'] = function(block) {
            const force = block.getFieldValue('FORCE');
            const buffer = block.getFieldValue('BUFFER');
            return `jumpBuffered(${force}, ${buffer});\n`;
        };

        Blockly.JavaScript.forBlock['dash'] = function(block) {
            const direction = block.getFieldValue('DIRECTION');
            const distance = block.getFieldValue('DISTANCE');
            return `dash("${direction}", ${distance});\n`;
        };

        Blockly.JavaScript.forBlock['knockback'] = function(block) {
            const force = block.getFieldValue('FORCE');
            const angle = block.getFieldValue('ANGLE');
            return `knockback(${force}, ${angle});\n`;
        };

        Blockly.JavaScript.forBlock['set_ai_type'] = function(block) {
            const entity = Blockly.JavaScript.valueToCode(block, 'ENTITY', Blockly.JavaScript.ORDER_NONE) || 'null';
            const aiType = block.getFieldValue('AI_TYPE');
            const targetTag = block.getFieldValue('TARGET_TAG');
            const speed = block.getFieldValue('SPEED');

            let metadataStr = '';
            if (aiType === 'CHASE') {
                metadataStr = `{ aiType: 'chase', targetTag: "${targetTag}", speed: ${speed} }`;
            } else if (aiType === 'FLEE') {
                metadataStr = `{ aiType: 'flee', threatTag: "${targetTag}", speed: ${speed} }`;
            } else if (aiType === 'PATROL') {
                metadataStr = `{ aiType: 'patrol', x1: 0, x2: 400 }`;
            }

            return `${entity}.aiMetadata = ${metadataStr};\n`;
        };

        Blockly.JavaScript.forBlock['tilemap_create'] = function(block) {
            const width = block.getFieldValue('WIDTH');
            const height = block.getFieldValue('HEIGHT');
            const tileSize = block.getFieldValue('TILE_SIZE');
            return [`createTilemap(${width}, ${height}, ${tileSize}, ${tileSize})`, Blockly.JavaScript.ORDER_FUNCTION_CALL];
        };

        Blockly.JavaScript.forBlock['tilemap_set_tile'] = function(block) {
            const tilemapId = Blockly.JavaScript.valueToCode(block, 'TILEMAP_ID', Blockly.JavaScript.ORDER_ATOMIC) || '""';
            const x = block.getFieldValue('X');
            const y = block.getFieldValue('Y');
            const tileId = block.getFieldValue('TILE_ID');
            const layer = block.getFieldValue('LAYER');
            return `setTile(${tilemapId}, ${x}, ${y}, ${tileId}, "${layer}");\n`;
        };

        Blockly.JavaScript.forBlock['inventory_get_count'] = function(block) {
            const itemId = block.getFieldValue('ITEM_ID');
            return [`inventoryGetCount("${itemId}")`, Blockly.JavaScript.ORDER_FUNCTION_CALL];
        };

        Blockly.JavaScript.forBlock['inventory_swap_slots'] = function(block) {
            const slot1 = block.getFieldValue('SLOT1');
            const slot2 = block.getFieldValue('SLOT2');
            return `inventorySwapSlots(${slot1}, ${slot2});\n`;
        };

        // === SNIPPET 4 CODE GENERATORS ===
        Blockly.JavaScript.forBlock['inventory_add'] = function(block) {
            const item = block.getFieldValue('ITEM');
            const quantity = block.getFieldValue('QUANTITY');
            return `inventoryAdd("${item}", ${quantity});\n`;
        };

        Blockly.JavaScript.forBlock['inventory_remove'] = function(block) {
            const item = block.getFieldValue('ITEM');
            const quantity = block.getFieldValue('QUANTITY');
            return `inventoryRemove("${item}", ${quantity});\n`;
        };

        Blockly.JavaScript.forBlock['inventory_has'] = function(block) {
            const item = block.getFieldValue('ITEM');
            return [`inventoryHas("${item}")`, Blockly.JavaScript.ORDER_FUNCTION_CALL];
        };

        Blockly.JavaScript.forBlock['apply_powerup'] = function(block) {
            const type = block.getFieldValue('TYPE');
            const duration = block.getFieldValue('DURATION');
            return `applyPowerup("${type}", ${duration});\n`;
        };

        Blockly.JavaScript.forBlock['apply_debuff'] = function(block) {
            const type = block.getFieldValue('TYPE');
            const duration = block.getFieldValue('DURATION');
            return `applyDebuff("${type}", ${duration});\n`;
        };

        Blockly.JavaScript.forBlock['has_buff'] = function(block) {
            const buff = block.getFieldValue('BUFF');
            return [`hasBuff("${buff}")`, Blockly.JavaScript.ORDER_FUNCTION_CALL];
        };

        Blockly.JavaScript.forBlock['pickup_create'] = function(block) {
            const type = block.getFieldValue('TYPE');
            const x = block.getFieldValue('X');
            const y = block.getFieldValue('Y');
            return `createPickup("${type}", ${x}, ${y});\n`;
        };

        // === SNIPPET 1 CODE GENERATORS ===
        Blockly.JavaScript.forBlock['switch_case'] = function(block) {
            const value = Blockly.JavaScript.valueToCode(block, 'VALUE', Blockly.JavaScript.ORDER_NONE) || '0';
            const match0 = block.getFieldValue('MATCH0');
            const case0 = Blockly.JavaScript.statementToCode(block, 'CASE0');
            const defaultCase = Blockly.JavaScript.statementToCode(block, 'DEFAULT');
            return `switch(${value}) {
  case ${match0}:
${case0}
    break;
  default:
${defaultCase}
}
`;
        };

        Blockly.JavaScript.forBlock['while_loop'] = function(block) {
            const condition = Blockly.JavaScript.valueToCode(block, 'CONDITION', Blockly.JavaScript.ORDER_NONE) || 'false';
            const statements = Blockly.JavaScript.statementToCode(block, 'DO');
            return `while(${condition}) {\n${statements}}\n`;
        };

        Blockly.JavaScript.forBlock['repeat_until'] = function(block) {
            const condition = Blockly.JavaScript.valueToCode(block, 'CONDITION', Blockly.JavaScript.ORDER_NONE) || 'true';
            const statements = Blockly.JavaScript.statementToCode(block, 'DO');
            return `do {\n${statements}} while(!(${condition}));\n`;
        };

        Blockly.JavaScript.forBlock['loop_break'] = function(block) {
            return 'break;\n';
        };

        Blockly.JavaScript.forBlock['loop_continue'] = function(block) {
            return 'continue;\n';
        };

        Blockly.JavaScript.forBlock['delay'] = function(block) {
            const seconds = block.getFieldValue('SECONDS');
            const statements = Blockly.JavaScript.statementToCode(block, 'THEN');
            return `delay(${seconds}, () => {\n${statements}});\n`;
        };

        Blockly.JavaScript.forBlock['cooldown'] = function(block) {
            const name = block.getFieldValue('NAME');
            const duration = block.getFieldValue('DURATION');
            const statements = Blockly.JavaScript.statementToCode(block, 'DO');
            return `cooldown("${name}", ${duration}, () => {\n${statements}});\n`;
        };

        Blockly.JavaScript.forBlock['random_choice'] = function(block) {
            const min = block.getFieldValue('MIN');
            const max = block.getFieldValue('MAX');
            return [`randomInt(${min}, ${max})`, Blockly.JavaScript.ORDER_FUNCTION_CALL];
        };

        Blockly.JavaScript.forBlock['weighted_random'] = function(block) {
            const weight1 = Blockly.JavaScript.valueToCode(block, 'WEIGHT1', Blockly.JavaScript.ORDER_NONE) || '1';
            const weight2 = Blockly.JavaScript.valueToCode(block, 'WEIGHT2', Blockly.JavaScript.ORDER_NONE) || '1';
            return [`weightedRandom([${weight1}, ${weight2}])`, Blockly.JavaScript.ORDER_FUNCTION_CALL];
        };

        Blockly.JavaScript.forBlock['define_function'] = function(block) {
            const name = block.getFieldValue('NAME');
            const statements = Blockly.JavaScript.statementToCode(block, 'DO');
            return `function ${name}() {\n${statements}}\n`;
        };

        Blockly.JavaScript.forBlock['call_function'] = function(block) {
            const name = block.getFieldValue('NAME');
            return `${name}();\n`;
        };

        // ============ PHASE 1: NEW GENERATORS (INPUT, ENTITY, LOGIC) ============

        // === INPUT & CONTROLS GENERATORS ===
        Blockly.JavaScript.forBlock['when_key_pressed'] = function(block) {
            const key = block.getFieldValue('KEY');
            const statements = Blockly.JavaScript.statementToCode(block, 'DO');
            return `onKeyPressed("${key}", () => {\n${statements}});\n`;
        };

        Blockly.JavaScript.forBlock['when_key_released'] = function(block) {
            const key = block.getFieldValue('KEY');
            const statements = Blockly.JavaScript.statementToCode(block, 'DO');
            return `onKeyReleased("${key}", () => {\n${statements}});\n`;
        };

        Blockly.JavaScript.forBlock['while_key_held'] = function(block) {
            const key = block.getFieldValue('KEY');
            const statements = Blockly.JavaScript.statementToCode(block, 'DO');
            return `whileKeyHeld("${key}", () => {\n${statements}});\n`;
        };

        Blockly.JavaScript.forBlock['when_mouse_button_pressed'] = function(block) {
            const button = block.getFieldValue('BUTTON');
            const statements = Blockly.JavaScript.statementToCode(block, 'DO');
            return `onMouseButtonPressed("${button}", () => {\n${statements}});\n`;
        };

        Blockly.JavaScript.forBlock['when_mouse_button_released'] = function(block) {
            const button = block.getFieldValue('BUTTON');
            const statements = Blockly.JavaScript.statementToCode(block, 'DO');
            return `onMouseButtonReleased("${button}", () => {\n${statements}});\n`;
        };

        Blockly.JavaScript.forBlock['get_mouse_x'] = function(block) {
            return ['getMouseX()', Blockly.JavaScript.ORDER_FUNCTION_CALL];
        };

        Blockly.JavaScript.forBlock['get_mouse_y'] = function(block) {
            return ['getMouseY()', Blockly.JavaScript.ORDER_FUNCTION_CALL];
        };

        Blockly.JavaScript.forBlock['lock_cursor'] = function(block) {
            return 'lockCursor();\n';
        };

        Blockly.JavaScript.forBlock['unlock_cursor'] = function(block) {
            return 'unlockCursor();\n';
        };

        Blockly.JavaScript.forBlock['enable_input'] = function(block) {
            return 'enableInput();\n';
        };

        Blockly.JavaScript.forBlock['disable_input'] = function(block) {
            return 'disableInput();\n';
        };

        Blockly.JavaScript.forBlock['is_input_enabled'] = function(block) {
            return ['isInputEnabled()', Blockly.JavaScript.ORDER_FUNCTION_CALL];
        };

        Blockly.JavaScript.forBlock['set_input_context'] = function(block) {
            const context = block.getFieldValue('CONTEXT');
            return `setInputContext("${context}");\n`;
        };

        Blockly.JavaScript.forBlock['is_key_pressed'] = function(block) {
            const key = block.getFieldValue('KEY');
            return [`isKeyPressed("${key}")`, Blockly.JavaScript.ORDER_FUNCTION_CALL];
        };

        // === ENTITY & TAG LOGIC GENERATORS ===
        Blockly.JavaScript.forBlock['for_each_with_tag'] = function(block) {
            const tag = block.getFieldValue('TAG');
            const varName = block.getFieldValue('VAR');
            const statements = Blockly.JavaScript.statementToCode(block, 'DO');
            return `forEachWithTag("${tag}", (${varName}) => {\n${statements}});\n`;
        };

        Blockly.JavaScript.forBlock['count_with_tag'] = function(block) {
            const tag = block.getFieldValue('TAG');
            return [`countWithTag("${tag}")`, Blockly.JavaScript.ORDER_FUNCTION_CALL];
        };

        Blockly.JavaScript.forBlock['destroy_all_with_tag'] = function(block) {
            const tag = block.getFieldValue('TAG');
            return `destroyAllWithTag("${tag}");\n`;
        };

        Blockly.JavaScript.forBlock['clone_with_tag'] = function(block) {
            const tag = block.getFieldValue('TAG');
            const x = block.getFieldValue('X');
            const y = block.getFieldValue('Y');
            return `cloneWithTag("${tag}", ${x}, ${y});\n`;
        };

        Blockly.JavaScript.forBlock['add_tag'] = function(block) {
            const tag = block.getFieldValue('TAG');
            const entity = Blockly.JavaScript.valueToCode(block, 'ENTITY', Blockly.JavaScript.ORDER_NONE) || 'null';
            return `addTag(${entity}, "${tag}");\n`;
        };

        Blockly.JavaScript.forBlock['remove_tag'] = function(block) {
            const tag = block.getFieldValue('TAG');
            const entity = Blockly.JavaScript.valueToCode(block, 'ENTITY', Blockly.JavaScript.ORDER_NONE) || 'null';
            return `removeTag(${entity}, "${tag}");\n`;
        };

        Blockly.JavaScript.forBlock['has_tag'] = function(block) {
            const tag = block.getFieldValue('TAG');
            const entity = Blockly.JavaScript.valueToCode(block, 'ENTITY', Blockly.JavaScript.ORDER_NONE) || 'null';
            return [`hasTag(${entity}, "${tag}")`, Blockly.JavaScript.ORDER_FUNCTION_CALL];
        };

        Blockly.JavaScript.forBlock['get_nearest_with_tag'] = function(block) {
            const tag = block.getFieldValue('TAG');
            const from = Blockly.JavaScript.valueToCode(block, 'FROM', Blockly.JavaScript.ORDER_NONE) || 'null';
            return [`getNearestWithTag(${from}, "${tag}")`, Blockly.JavaScript.ORDER_FUNCTION_CALL];
        };

        Blockly.JavaScript.forBlock['get_random_with_tag'] = function(block) {
            const tag = block.getFieldValue('TAG');
            return [`getRandomWithTag("${tag}")`, Blockly.JavaScript.ORDER_FUNCTION_CALL];
        };

        Blockly.JavaScript.forBlock['get_all_with_tag'] = function(block) {
            const tag = block.getFieldValue('TAG');
            return [`getAllWithTag("${tag}")`, Blockly.JavaScript.ORDER_FUNCTION_CALL];
        };

        Blockly.JavaScript.forBlock['distance_to_nearest'] = function(block) {
            const tag = block.getFieldValue('TAG');
            const from = Blockly.JavaScript.valueToCode(block, 'FROM', Blockly.JavaScript.ORDER_NONE) || 'null';
            return [`distanceToNearest(${from}, "${tag}")`, Blockly.JavaScript.ORDER_FUNCTION_CALL];
        };

        Blockly.JavaScript.forBlock['get_entity_position'] = function(block) {
            const axis = block.getFieldValue('AXIS');
            const entity = Blockly.JavaScript.valueToCode(block, 'ENTITY', Blockly.JavaScript.ORDER_NONE) || 'null';
            return [`getEntityPosition(${entity}, "${axis}")`, Blockly.JavaScript.ORDER_FUNCTION_CALL];
        };

        Blockly.JavaScript.forBlock['set_entity_position'] = function(block) {
            const entity = Blockly.JavaScript.valueToCode(block, 'ENTITY', Blockly.JavaScript.ORDER_NONE) || 'null';
            const x = Blockly.JavaScript.valueToCode(block, 'X', Blockly.JavaScript.ORDER_NONE) || '0';
            const y = Blockly.JavaScript.valueToCode(block, 'Y', Blockly.JavaScript.ORDER_NONE) || '0';
            return `setEntityPosition(${entity}, ${x}, ${y});\n`;
        };

        Blockly.JavaScript.forBlock['on_tag_collision'] = function(block) {
            const tag1 = block.getFieldValue('TAG1');
            const tag2 = block.getFieldValue('TAG2');
            const statements = Blockly.JavaScript.statementToCode(block, 'DO');
            return `onTagCollision("${tag1}", "${tag2}", () => {\n${statements}});\n`;
        };

        Blockly.JavaScript.forBlock['tag_collision_exit'] = function(block) {
            const tag1 = block.getFieldValue('TAG1');
            const tag2 = block.getFieldValue('TAG2');
            const statements = Blockly.JavaScript.statementToCode(block, 'DO');
            return `onTagCollisionExit("${tag1}", "${tag2}", () => {\n${statements}});\n`;
        };

        // === LOGIC & FLOW GENERATORS ===
        Blockly.JavaScript.forBlock['for_loop'] = function(block) {
            const varName = block.getFieldValue('VAR');
            const from = Blockly.JavaScript.valueToCode(block, 'FROM', Blockly.JavaScript.ORDER_NONE) || '0';
            const to = Blockly.JavaScript.valueToCode(block, 'TO', Blockly.JavaScript.ORDER_NONE) || '10';
            const statements = Blockly.JavaScript.statementToCode(block, 'DO');
            return `for (let ${varName} = ${from}; ${varName} <= ${to}; ${varName}++) {\n${statements}}\n`;
        };

        Blockly.JavaScript.forBlock['repeat_n_times'] = function(block) {
            const times = Blockly.JavaScript.valueToCode(block, 'TIMES', Blockly.JavaScript.ORDER_NONE) || '1';
            const statements = Blockly.JavaScript.statementToCode(block, 'DO');
            return `for (let _i = 0; _i < ${times}; _i++) {\n${statements}}\n`;
        };

        Blockly.JavaScript.forBlock['random_percent'] = function(block) {
            const percent = Blockly.JavaScript.valueToCode(block, 'PERCENT', Blockly.JavaScript.ORDER_NONE) || '50';
            return [`(Math.random() * 100 < ${percent})`, Blockly.JavaScript.ORDER_LOGICAL_NOT];
        };

        Blockly.JavaScript.forBlock['weighted_choice'] = function(block) {
            const option1 = Blockly.JavaScript.valueToCode(block, 'OPTION1', Blockly.JavaScript.ORDER_NONE) || 'null';
            const weight1 = Blockly.JavaScript.valueToCode(block, 'WEIGHT1', Blockly.JavaScript.ORDER_NONE) || '1';
            const option2 = Blockly.JavaScript.valueToCode(block, 'OPTION2', Blockly.JavaScript.ORDER_NONE) || 'null';
            const weight2 = Blockly.JavaScript.valueToCode(block, 'WEIGHT2', Blockly.JavaScript.ORDER_NONE) || '1';
            return [`weightedChoice([${option1}, ${option2}], [${weight1}, ${weight2}])`, Blockly.JavaScript.ORDER_FUNCTION_CALL];
        };

        Blockly.JavaScript.forBlock['cooldown_check'] = function(block) {
            const name = block.getFieldValue('NAME');
            return [`isCooldownReady("${name}")`, Blockly.JavaScript.ORDER_FUNCTION_CALL];
        };

        Blockly.JavaScript.forBlock['set_cooldown'] = function(block) {
            const name = block.getFieldValue('NAME');
            const duration = Blockly.JavaScript.valueToCode(block, 'DURATION', Blockly.JavaScript.ORDER_NONE) || '1';
            return `setCooldown("${name}", ${duration});\n`;
        };

        Blockly.JavaScript.forBlock['state_machine_init'] = function(block) {
            const name = block.getFieldValue('NAME');
            const states = block.getFieldValue('STATES');
            return `const ${name} = initStateMachine([${states.split(',').map(s => `"${s.trim()}"`).join(', ')}]);\n`;
        };

        Blockly.JavaScript.forBlock['state_machine_set'] = function(block) {
            const name = block.getFieldValue('NAME');
            const state = block.getFieldValue('STATE');
            return `setState(${name}, "${state}");\n`;
        };

        Blockly.JavaScript.forBlock['state_machine_get'] = function(block) {
            const name = block.getFieldValue('NAME');
            return [`getState(${name})`, Blockly.JavaScript.ORDER_FUNCTION_CALL];
        };

        Blockly.JavaScript.forBlock['state_machine_is'] = function(block) {
            const name = block.getFieldValue('NAME');
            const state = block.getFieldValue('STATE');
            return [`isState(${name}, "${state}")`, Blockly.JavaScript.ORDER_FUNCTION_CALL];
        };

        Blockly.JavaScript.forBlock['log_to_console'] = function(block) {
            const value = Blockly.JavaScript.valueToCode(block, 'VALUE', Blockly.JavaScript.ORDER_NONE) || 'null';
            return `console.log(${value});\n`;
        };

        Blockly.JavaScript.forBlock['debug_assert'] = function(block) {
            const condition = Blockly.JavaScript.valueToCode(block, 'CONDITION', Blockly.JavaScript.ORDER_NONE) || 'true';
            const message = Blockly.JavaScript.valueToCode(block, 'MESSAGE', Blockly.JavaScript.ORDER_NONE) || '"Assertion failed"';
            return `if (!(${condition})) console.error(${message});\n`;
        };

        // ============ PRIORITY GENERATORS: AUDIO, PHYSICS, VISUAL EFFECTS ============

        // === AUDIO GENERATORS ===
        Blockly.JavaScript.forBlock['play_sound'] = function(block) {
            const soundId = block.getFieldValue('SOUND');
            const volume = block.getFieldValue('VOLUME');
            const loop = block.getFieldValue('LOOP') === 'TRUE';
            return `playSound("${soundId}", ${volume}, ${loop});\n`;
        };

        Blockly.JavaScript.forBlock['stop_sound'] = function(block) {
            const soundId = block.getFieldValue('SOUND');
            return `stopSound("${soundId}");\n`;
        };

        Blockly.JavaScript.forBlock['play_music'] = function(block) {
            const musicId = block.getFieldValue('MUSIC');
            const fadeTime = block.getFieldValue('FADE');
            return `playMusic("${musicId}", ${fadeTime});\n`;
        };

        // === PHYSICS GENERATORS ===
        Blockly.JavaScript.forBlock['apply_force'] = function(block) {
            const entity = Blockly.JavaScript.valueToCode(block, 'ENTITY', Blockly.JavaScript.ORDER_NONE) || 'null';
            const forceX = Blockly.JavaScript.valueToCode(block, 'FORCE_X', Blockly.JavaScript.ORDER_NONE) || '0';
            const forceY = Blockly.JavaScript.valueToCode(block, 'FORCE_Y', Blockly.JavaScript.ORDER_NONE) || '0';
            return `applyForce(${entity}, ${forceX}, ${forceY});\n`;
        };

        Blockly.JavaScript.forBlock['is_grounded'] = function(block) {
            const entity = Blockly.JavaScript.valueToCode(block, 'ENTITY', Blockly.JavaScript.ORDER_NONE) || 'null';
            const distance = block.getFieldValue('DISTANCE');
            return [`isGrounded(${entity}, ${distance})`, Blockly.JavaScript.ORDER_FUNCTION_CALL];
        };

        Blockly.JavaScript.forBlock['raycast'] = function(block) {
            const fromX = Blockly.JavaScript.valueToCode(block, 'FROM_X', Blockly.JavaScript.ORDER_NONE) || '0';
            const fromY = Blockly.JavaScript.valueToCode(block, 'FROM_Y', Blockly.JavaScript.ORDER_NONE) || '0';
            const toX = Blockly.JavaScript.valueToCode(block, 'TO_X', Blockly.JavaScript.ORDER_NONE) || '0';
            const toY = Blockly.JavaScript.valueToCode(block, 'TO_Y', Blockly.JavaScript.ORDER_NONE) || '0';
            const tag = block.getFieldValue('TAG');
            return [`raycast(${fromX}, ${fromY}, ${toX}, ${toY}, "${tag}")`, Blockly.JavaScript.ORDER_FUNCTION_CALL];
        };

        // === VISUAL EFFECTS GENERATORS ===
        Blockly.JavaScript.forBlock['set_opacity'] = function(block) {
            const entity = Blockly.JavaScript.valueToCode(block, 'ENTITY', Blockly.JavaScript.ORDER_NONE) || 'null';
            const opacity = Blockly.JavaScript.valueToCode(block, 'OPACITY', Blockly.JavaScript.ORDER_NONE) || '1';
            return `setOpacity(${entity}, ${opacity});\n`;
        };

        Blockly.JavaScript.forBlock['flip_sprite'] = function(block) {
            const entity = Blockly.JavaScript.valueToCode(block, 'ENTITY', Blockly.JavaScript.ORDER_NONE) || 'null';
            const direction = block.getFieldValue('DIRECTION');
            return `flipSprite(${entity}, "${direction}");\n`;
        };

        Blockly.JavaScript.forBlock['camera_shake'] = function(block) {
            const intensity = block.getFieldValue('INTENSITY');
            const duration = block.getFieldValue('DURATION');
            return `cameraShake(${intensity}, ${duration});\n`;
        };

        // === GAME STATE GENERATORS ===
        Blockly.JavaScript.forBlock['pause_game'] = function(block) {
            return `pauseGame();\n`;
        };

        Blockly.JavaScript.forBlock['resume_game'] = function(block) {
            return `resumeGame();\n`;
        };

        Blockly.JavaScript.forBlock['load_scene'] = function(block) {
            const sceneName = Blockly.JavaScript.valueToCode(block, 'SCENE_NAME', Blockly.JavaScript.ORDER_NONE) || '""';
            const preserve = block.getFieldValue('PRESERVE_STATE') === 'TRUE';
            return `loadScene(${sceneName}, ${preserve});\n`;
        };

        Blockly.JavaScript.forBlock['game_over'] = function(block) {
            const showScore = block.getFieldValue('SHOW_SCORE') === 'TRUE';
            return `gameOver(${showScore});\n`;
        };

        Blockly.JavaScript.forBlock['restart_level'] = function(block) {
            return `restartLevel();\n`;
        };

        // === COMBAT GENERATORS ===
        Blockly.JavaScript.forBlock['deal_damage'] = function(block) {
            const target = Blockly.JavaScript.valueToCode(block, 'TARGET', Blockly.JavaScript.ORDER_NONE) || 'null';
            const damage = Blockly.JavaScript.valueToCode(block, 'DAMAGE', Blockly.JavaScript.ORDER_NONE) || '0';
            const knockback = block.getFieldValue('KNOCKBACK') === 'TRUE';
            return `dealDamage(${target}, ${damage}, ${knockback});\n`;
        };

        Blockly.JavaScript.forBlock['create_hitbox'] = function(block) {
            const entity = Blockly.JavaScript.valueToCode(block, 'ENTITY', Blockly.JavaScript.ORDER_NONE) || 'null';
            const width = Blockly.JavaScript.valueToCode(block, 'WIDTH', Blockly.JavaScript.ORDER_NONE) || '32';
            const height = Blockly.JavaScript.valueToCode(block, 'HEIGHT', Blockly.JavaScript.ORDER_NONE) || '32';
            const duration = Blockly.JavaScript.valueToCode(block, 'DURATION', Blockly.JavaScript.ORDER_NONE) || '0.2';
            const offsetX = block.getFieldValue('OFFSET_X');
            const offsetY = block.getFieldValue('OFFSET_Y');
            return `createHitbox(${entity}, ${width}, ${height}, ${duration}, ${offsetX}, ${offsetY});\n`;
        };

        // === ADDITIONAL ESSENTIAL GENERATORS ===
        Blockly.JavaScript.forBlock['set_z_layer'] = function(block) {
            const entity = Blockly.JavaScript.valueToCode(block, 'ENTITY', Blockly.JavaScript.ORDER_NONE) || 'null';
            const layer = Blockly.JavaScript.valueToCode(block, 'LAYER', Blockly.JavaScript.ORDER_NONE) || '0';
            return `setZLayer(${entity}, ${layer});\n`;
        };

        // === UI GENERATORS ===
        Blockly.JavaScript.forBlock['ui_button'] = function(block) {
            const text = block.getFieldValue('TEXT');
            const x = Blockly.JavaScript.valueToCode(block, 'X', Blockly.JavaScript.ORDER_NONE) || '100';
            const y = Blockly.JavaScript.valueToCode(block, 'Y', Blockly.JavaScript.ORDER_NONE) || '100';
            const width = Blockly.JavaScript.valueToCode(block, 'WIDTH', Blockly.JavaScript.ORDER_NONE) || '120';
            const height = Blockly.JavaScript.valueToCode(block, 'HEIGHT', Blockly.JavaScript.ORDER_NONE) || '40';
            const onClickStatements = Blockly.JavaScript.statementToCode(block, 'ON_CLICK');
            return `createUIButton("${text}", ${x}, ${y}, ${width}, ${height}, () => {\n${onClickStatements}});\n`;
        };

        Blockly.JavaScript.forBlock['ui_text'] = function(block) {
            const content = block.getFieldValue('CONTENT');
            const x = Blockly.JavaScript.valueToCode(block, 'X', Blockly.JavaScript.ORDER_NONE) || '100';
            const y = Blockly.JavaScript.valueToCode(block, 'Y', Blockly.JavaScript.ORDER_NONE) || '100';
            const fontSize = Blockly.JavaScript.valueToCode(block, 'SIZE', Blockly.JavaScript.ORDER_NONE) || '16';
            const color = block.getFieldValue('COLOR');
            return `createUIText("${content}", ${x}, ${y}, ${fontSize}, "${color}");\n`;
        };

        Blockly.JavaScript.forBlock['ui_dialog'] = function(block) {
            const title = block.getFieldValue('TITLE');
            const message = Blockly.JavaScript.valueToCode(block, 'MESSAGE', Blockly.JavaScript.ORDER_NONE) || '""';
            const buttons = block.getFieldValue('BUTTONS');
            const onButtonClickStatements = Blockly.JavaScript.statementToCode(block, 'ON_BUTTON_CLICK');
            return `showUIDialog("${title}", ${message}, "${buttons}", (buttonIndex) => {\n${onButtonClickStatements}});\n`;
        };

        Blockly.JavaScript.forBlock['ui_hud_element'] = function(block) {
            const hudType = block.getFieldValue('TYPE');
            const x = Blockly.JavaScript.valueToCode(block, 'X', Blockly.JavaScript.ORDER_NONE) || '20';
            const y = Blockly.JavaScript.valueToCode(block, 'Y', Blockly.JavaScript.ORDER_NONE) || '20';
            const width = Blockly.JavaScript.valueToCode(block, 'WIDTH', Blockly.JavaScript.ORDER_NONE) || '200';
            const height = Blockly.JavaScript.valueToCode(block, 'HEIGHT', Blockly.JavaScript.ORDER_NONE) || '30';
            const variableName = block.getFieldValue('VARIABLE');
            return `createHUDElement("${hudType}", ${x}, ${y}, ${width}, ${height}, "${variableName}");\n`;
        };

        Blockly.JavaScript.forBlock['ui_menu'] = function(block) {
            const title = block.getFieldValue('TITLE');
            const items = block.getFieldValue('ITEMS');
            const onItemSelectStatements = Blockly.JavaScript.statementToCode(block, 'ON_ITEM_SELECT');
            return `createUIMenu("${title}", "${items}", (itemIndex) => {\n${onItemSelectStatements}});\n`;
        };

        Blockly.JavaScript.forBlock['ui_get_input_value'] = function(block) {
            const name = block.getFieldValue('NAME');
            return [`getUIInputValue("${name}")`, Blockly.JavaScript.ORDER_FUNCTION_CALL];
        };

        Blockly.JavaScript.forBlock['ui_show_notification'] = function(block) {
            const message = block.getFieldValue('MESSAGE');
            const seconds = Blockly.JavaScript.valueToCode(block, 'SECONDS', Blockly.JavaScript.ORDER_NONE) || '3';
            return `showUINotification("${message}", ${seconds});\n`;
        };

        Blockly.JavaScript.forBlock['ui_inventory_display'] = function(block) {
            const x = Blockly.JavaScript.valueToCode(block, 'X', Blockly.JavaScript.ORDER_NONE) || '500';
            const y = Blockly.JavaScript.valueToCode(block, 'Y', Blockly.JavaScript.ORDER_NONE) || '20';
            const slotCount = Blockly.JavaScript.valueToCode(block, 'SLOT_COUNT', Blockly.JavaScript.ORDER_NONE) || '10';
            const slotSize = Blockly.JavaScript.valueToCode(block, 'SLOT_SIZE', Blockly.JavaScript.ORDER_NONE) || '40';
            return `createInventoryDisplay(${x}, ${y}, ${slotCount}, ${slotSize});\n`;
        };

        // === TOUCH & GESTURE GENERATORS ===
        Blockly.JavaScript.forBlock['on_touch_start'] = function(block) {
            const statements = Blockly.JavaScript.statementToCode(block, 'DO');
            return `onTouchStart((touch) => {\n${statements}});\n`;
        };

        Blockly.JavaScript.forBlock['on_swipe'] = function(block) {
            const direction = block.getFieldValue('DIRECTION');
            const statements = Blockly.JavaScript.statementToCode(block, 'DO');
            const dirCheck = direction === 'any' ? 'true' : `direction === '${direction}'`;
            return `onSwipe((direction, velocity) => {
  if (${dirCheck}) {
${statements}  }
});
`;
        };

        Blockly.JavaScript.forBlock['on_pinch'] = function(block) {
            const statements = Blockly.JavaScript.statementToCode(block, 'DO');
            return `onPinch((scale, center) => {\n${statements}});\n`;
        };

        Blockly.JavaScript.forBlock['on_double_tap'] = function(block) {
            const statements = Blockly.JavaScript.statementToCode(block, 'DO');
            return `onDoubleTap((position) => {\n${statements}});\n`;
        };

        Blockly.JavaScript.forBlock['get_touch_count'] = function(block) {
            return [`getTouchCount()`, Blockly.JavaScript.ORDER_FUNCTION_CALL];
        };

        Blockly.JavaScript.forBlock['get_touch_position'] = function(block) {
            const axis = block.getFieldValue('AXIS');
            const index = block.getFieldValue('INDEX');
            return [`getTouchPosition(${index}).${axis}`, Blockly.JavaScript.ORDER_MEMBER];
        };


        // Initialize Blockly workspace (workspace already declared above)
        const STORAGE_KEY = 'lupiforge_project_' + (window.LUPIFORGE_CURRENT_USER && window.LUPIFORGE_CURRENT_USER.id ? window.LUPIFORGE_CURRENT_USER.id : 'guest');

        // Utility functions
        function showToast(message, isError = false) {
            const toast = document.getElementById('toast');
            toast.textContent = message;
            toast.className = 'toast show' + (isError ? ' error' : '');
            setTimeout(() => toast.classList.remove('show'), 3000);
        }

        function getProjectData() {
            const projectName = document.getElementById('projectName').value.trim() || 'Untitled Game';
            const code = Blockly.JavaScript.workspaceToCode(workspace);
            const xml = Blockly.Xml.workspaceToDom(workspace);
            const xmlText = Blockly.Xml.domToText(xml);
            
            return {
                name: projectName,
                gameTitle: projectName,
                version: '1.0.0',
                xml: xmlText,
                code: code,
                blocks: workspace.getAllBlocks(false).map(block => ({
                    type: block.type,
                    id: block.id,
                    inputs: block.inputList ? block.inputList.reduce((acc, input) => {
                        acc[input.name] = input.fieldRow && input.fieldRow[0] ? input.fieldRow[0].getValue() : null;
                        return acc;
                    }, {}) : {}
                })),
                settings: {
                    gameTitle: projectName,
                    version: '1.0.0',
                    orientation: 'landscape',
                    resolution: { width: 800, height: 600 },
                    touchConfig: {
                        enableMultiTouch: true,
                        swipeSensitivity: 0.5,
                        pinchEnabled: true
                    },
                    physics: {
                        gravity: 9.8,
                        friction: 0.8
                    }
                }
            };
        }

        function updateSaveStatus() {
            const status = document.getElementById('saveStatus');
            const now = new Date();
            status.textContent = `Saved at ${now.toLocaleTimeString()}`;
        }

        function saveProject() {
            const projectName = document.getElementById('projectName').value.trim() || 'Untitled Game';
            const xml = Blockly.Xml.workspaceToDom(workspace);
            const xmlText = Blockly.Xml.domToText(xml);
            const code = Blockly.JavaScript.workspaceToCode(workspace);

            const projectData = {
                name: projectName,
                xml: xmlText,
                code: code,
                timestamp: new Date().toISOString()
            };

            localStorage.setItem(STORAGE_KEY, JSON.stringify(projectData));
            updateSaveStatus();
            showToast('‚úÖ Project saved locally');
            console.log('Project saved locally:', projectData);

            // Also attempt to persist to server (best-effort). Uses CSRF cookie.
            try{
                const csrftoken = (document.cookie.match(/csrftoken=([^;]+)/)||[])[1] || '';
                const saveData = {
                    title: projectName,
                    description: 'Saved from in-browser editor',
                    logic_json: { xml: xmlText, code: code }
                };
                
                // Include game_id if editing existing game
                if (window.LUPIFORGE_GAME_ID) {
                    saveData.game_id = window.LUPIFORGE_GAME_ID;
                }
                
                fetch('{% url "save_game" %}', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-CSRFToken': csrftoken,
                        'X-Requested-With': 'XMLHttpRequest'
                    },
                    body: JSON.stringify(saveData)
                }).then(async res => {
                    if(!res.ok) throw new Error('Save failed');
                    const data = await res.json();
                    
                    // Store game_id for future saves
                    if (data.game_id && !window.LUPIFORGE_GAME_ID) {
                        window.LUPIFORGE_GAME_ID = data.game_id;
                        console.log('Game ID assigned:', data.game_id);
                    }
                    
                    showToast('üíæ Saved to your account');
                    console.log('Server save response:', data);
                }).catch(err => {
                    console.warn('Server save failed:', err);
                });
            }catch(e){ console.warn('Error persisting to server', e); }

            // Check achievements
            const blockCount = workspace.getAllBlocks(false).length;
            if (blockCount >= 1) {
                AchievementManager.check('first_game');
            }
            if (blockCount >= 10) {
                AchievementManager.check('ten_blocks');
            }
            AchievementManager.check('first_save');
        }

        function loadProject() {
            const saved = localStorage.getItem(STORAGE_KEY);
            if (saved) {
                try {
                    const projectData = JSON.parse(saved);
                    document.getElementById('projectName').value = projectData.name;
                    const xml = Blockly.utils.xml.textToDom(projectData.xml);
                    Blockly.Xml.domToWorkspace(xml, workspace);
                    
                    const savedDate = new Date(projectData.timestamp);
                    document.getElementById('saveStatus').textContent = 
                        `Loaded from ${savedDate.toLocaleDateString()}`;
                    
                    console.log('Project loaded:', projectData);
                    showToast('üìÇ Project loaded!');
                } catch (e) {
                    console.error('Failed to load project:', e);
                    showToast('‚ùå Failed to load project', true);
                }
            }
        }

        function clearProject() {
            if (confirm('‚ö†Ô∏è Are you sure you want to clear the workspace? This cannot be undone.')) {
                workspace.clear();
                document.getElementById('projectName').value = '';
                localStorage.removeItem(STORAGE_KEY);
                document.getElementById('saveStatus').textContent = 'Never saved';
                showToast('üóëÔ∏è Workspace cleared');
            }
        }

        function preparePublish() {
            const projectName = document.getElementById('projectName').value.trim();
            if (!projectName) {
                showToast('‚ùå Please enter a game title first!', true);
                return;
            }

            const blockCount = workspace.getAllBlocks(false).length;
            if (blockCount === 0) {
                showToast('‚ùå Your game needs blocks to publish!', true);
                return;
            }

            document.getElementById('modalGameTitle').textContent = projectName;
            document.getElementById('publishModal').classList.add('show');
        }

        function publishGame() {
            const projectName = document.getElementById('projectName').value.trim();
            const xml = Blockly.Xml.workspaceToDom(workspace);
            const xmlText = Blockly.Xml.domToText(xml);
            const code = Blockly.JavaScript.workspaceToCode(workspace);

            const publishData = {
                title: projectName,
                logic_json: xmlText,
                generated_code: code,
                visibility: 'pending',
                submitted_at: new Date().toISOString()
            };

            // In production, this would be: POST /games/api/publish/
            console.log('Game ready for publication:', publishData);
            console.log('API Endpoint: POST /games/api/publish/');
            console.log('Headers: {"Authorization": "Bearer <token>", "Content-Type": "application/json"}');
            
            document.getElementById('publishModal').classList.remove('show');
            showToast('üöÄ Game submitted for review!');
            
            // Show what would be sent to backend
            const output = document.getElementById('output');
            output.textContent = `üì§ PUBLISH DATA (Ready for API):\n\n${JSON.stringify(publishData, null, 2)}`;
            output.classList.add('show');

            // Check achievement
            AchievementManager.check('first_publish');

            // Show submission toast
            showToast('üöÄ Game Submitted! Your game is now pending moderator review.');
        }


        // Moderation Manager
        const ModerationManager = {
            queue: [],
            currentGame: null,
            isModerator: false,

            init() {
                this.checkModeratorRole();
                if (this.isModerator) {
                    document.getElementById('moderationBtn').style.display = 'block';
                    this.generateMockQueue();
                    this.attachEvents();
                }
            },

            checkModeratorRole() {
                const userRole = localStorage.getItem('user_role') || 'player';
                this.isModerator = userRole === 'moderator' || userRole === 'admin';
                console.log('User role:', userRole, 'Is moderator:', this.isModerator);
            },

            attachEvents() {
                document.getElementById('moderationBtn').addEventListener('click', () => this.show());
                document.getElementById('closeModeration').addEventListener('click', () => {
                    document.getElementById('moderationModal').classList.remove('show');
                });
                document.getElementById('closeModPreview').addEventListener('click', () => {
                    document.getElementById('moderationPreviewModal').classList.remove('show');
                });
                document.getElementById('approveGame').addEventListener('click', () => this.approveGame());
                document.getElementById('rejectGame').addEventListener('click', () => this.rejectGame());
            },

            show() {
                document.getElementById('moderationModal').classList.add('show');
                this.loadQueue();
            },

            loadQueue() {
                console.log('Loading moderation queue');
                console.log('API Endpoint: GET /games/api/moderation/queue/');
                this.renderStats();
                this.renderQueue();
            },

            generateMockQueue() {
                const names = ['Player1', 'Creator2', 'Designer3', 'Gamer4', 'Builder5'];
                const games = ['Epic Adventure', 'Puzzle Master', 'Racing Pro', 'Space Battle', 'Platform Hero'];
                for (let i = 0; i < 10; i++) {
                    this.queue.push({
                        id: i + 1,
                        title: games[i % games.length] + ' v' + (i + 1),
                        author: names[i % names.length],
                        submitted: new Date(Date.now() - Math.random() * 48 * 60 * 60 * 1000).toLocaleString(),
                        status: 'pending'
                    });
                }
            },

            renderStats() {
                const pending = this.queue.filter(g => g.status === 'pending').length;
                const approved = Math.floor(Math.random() * 20) + 5;
                const rejected = Math.floor(Math.random() * 10) + 2;
                document.getElementById('pendingCount').textContent = pending;
                document.getElementById('approvedCount').textContent = approved;
                document.getElementById('rejectedCount').textContent = rejected;
            },

            renderQueue() {
                const container = document.getElementById('moderationQueue');
                const pending = this.queue.filter(g => g.status === 'pending');
                if (pending.length === 0) {
                    container.innerHTML = '<p style="text-align: center; color: #95a5a6; padding: 40px;">‚úÖ All caught up! No games pending review.</p>';
                    return;
                }
                container.innerHTML = pending.map(game => `
                    <div class="mod-item">
                        <div class="mod-item-info">
                            <div class="mod-item-title">${game.title}</div>
                            <div class="mod-item-meta">
                                By ${game.author} ‚Ä¢ Submitted ${game.submitted}
                            </div>
                        </div>
                        <div class="mod-item-actions">
                            <button class="mod-btn review" onclick="ModerationManager.reviewGame(${game.id})">üëÅÔ∏è Review</button>
                            <button class="mod-btn approve" onclick="ModerationManager.quickApprove(${game.id})">‚úÖ</button>
                            <button class="mod-btn reject" onclick="ModerationManager.quickReject(${game.id})">‚ùå</button>
                        </div>
                    </div>
                `).join('');
            },

            reviewGame(gameId) {
                this.currentGame = this.queue.find(g => g.id === gameId);
                document.getElementById('modGameTitle').textContent = this.currentGame.title;
                document.getElementById('modGameAuthor').textContent = this.currentGame.author;
                document.getElementById('modGameDate').textContent = this.currentGame.submitted;
                document.getElementById('moderationPreviewModal').classList.add('show');
                this.renderGamePreview();
            },

            renderGamePreview() {
                const canvas = document.getElementById('modGameCanvas');
                const ctx = canvas.getContext('2d');
                ctx.fillStyle = '#000';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                ctx.fillStyle = '#27ae60';
                ctx.font = '24px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('Game Preview', canvas.width / 2, canvas.height / 2);
                ctx.fillText(this.currentGame.title, canvas.width / 2, canvas.height / 2 + 40);
            },

            quickApprove(gameId) {
                if (confirm('Quick approve this game?')) {
                    this.performApproval(gameId, '');
                }
            },

            quickReject(gameId) {
                const feedback = prompt('Reason for rejection:');
                if (feedback) {
                    this.performRejection(gameId, feedback);
                }
            },

            approveGame() {
                const feedback = document.getElementById('modFeedback').value;
                this.performApproval(this.currentGame.id, feedback);
                document.getElementById('moderationPreviewModal').classList.remove('show');
            },

            rejectGame() {
                const feedback = document.getElementById('modFeedback').value;
                if (!feedback) {
                    showToast('‚ùå Please provide feedback for rejection', true);
                    return;
                }
                this.performRejection(this.currentGame.id, feedback);
                document.getElementById('moderationPreviewModal').classList.remove('show');
            },

            performApproval(gameId, feedback) {
                const game = this.queue.find(g => g.id === gameId);
                game.status = 'approved';
                console.log('Game approved:', gameId, feedback);
                console.log('API Endpoint: POST /games/api/approve/', {game_id: gameId, feedback});
                showToast(`‚úÖ ${game.title} approved! üéâ Your game has been approved and is now live!`);
                this.loadQueue();
            },

            performRejection(gameId, feedback) {
                const game = this.queue.find(g => g.id === gameId);
                game.status = 'rejected';
                console.log('Game rejected:', gameId, feedback);
                console.log('API Endpoint: POST /games/api/reject/', {game_id: gameId, feedback});
                showToast(`‚ùå ${game.title} rejected. Your game needs changes: ${feedback}`);
                this.loadQueue();
            }
        };




        // === AUTOSAVE MANAGER ===
        const AutosaveManager = {
            saveTimeout: null,
            indicator: null,

            init() {
                this.indicator = document.getElementById('autosaveIndicator');
                
                workspace.addChangeListener((event) => {
                    if (event.type === Blockly.Events.UI) return;
                    this.triggerAutosave();
                });

                document.getElementById('projectName').addEventListener('input', () => {
                    this.triggerAutosave();
                });
            },

            triggerAutosave() {
                clearTimeout(this.saveTimeout);
                this.showIndicator('saving');

                this.saveTimeout = setTimeout(() => {
                    this.performSave();
                }, 1000);
            },

            performSave() {
                const projectName = document.getElementById('projectName').value.trim() || 'Untitled Game';
                const xml = Blockly.Xml.workspaceToDom(workspace);
                const xmlText = Blockly.Xml.domToText(xml);
                const code = Blockly.JavaScript.workspaceToCode(workspace);

                const projectData = {
                    name: projectName,
                    xml: xmlText,
                    code: code,
                    timestamp: new Date().toISOString()
                };

                localStorage.setItem(STORAGE_KEY, JSON.stringify(projectData));
                this.showIndicator('saved');
                
                console.log('Autosaved:', projectData.name);

                setTimeout(() => this.hideIndicator(), 2000);
            },

            showIndicator(state) {
                this.indicator.className = `autosave-indicator show ${state}`;
                this.indicator.textContent = state === 'saving' ? 'üíæ Saving...' : '‚úì Saved';
            },

            hideIndicator() {
                this.indicator.classList.remove('show');
            }
        };

            console.log('‚úÖ Custom Blockly blocks defined');
            return true;
        } // End defineCustomBlocks()

        // === DEBUG CONSOLE ===
        const EnhancedDebugConsole = {
    output: null,
    isCollapsed: true,
    logs: [],
    filters: {
        log: true,
        warn: true,
        error: true,
        info: true
    },
    maxLogs: 500,
    
    init() {
        this.output = document.getElementById('debugOutput');
        this.createFilterUI();
        this.attachEvents();
        this.interceptConsoleLogs();
    },
    
    createFilterUI() {
        const header = document.querySelector('.debug-header');
        const filterContainer = document.createElement('div');
        filterContainer.style.cssText = 'display: flex; gap: 5px; margin-left: 10px;';
        filterContainer.innerHTML = `
            <button class="debug-filter-btn active" data-filter="log" style="padding: 3px 8px; background: #4ec9b0; color: #000; border: none; border-radius: 3px; font-size: 10px; cursor: pointer;">LOG</button>
            <button class="debug-filter-btn active" data-filter="warn" style="padding: 3px 8px; background: #dcdcaa; color: #000; border: none; border-radius: 3px; font-size: 10px; cursor: pointer;">WARN</button>
            <button class="debug-filter-btn active" data-filter="error" style="padding: 3px 8px; background: #f48771; color: #000; border: none; border-radius: 3px; font-size: 10px; cursor: pointer;">ERROR</button>
            <button class="debug-filter-btn active" data-filter="info" style="padding: 3px 8px; background: #3498db; color: #fff; border: none; border-radius: 3px; font-size: 10px; cursor: pointer;">INFO</button>
        `;
        
        const controls = header.querySelector('.debug-controls');
        controls.parentNode.insertBefore(filterContainer, controls);
        
        filterContainer.querySelectorAll('.debug-filter-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                const filter = btn.dataset.filter;
                this.filters[filter] = !this.filters[filter];
                btn.classList.toggle('active', this.filters[filter]);
                btn.style.opacity = this.filters[filter] ? '1' : '0.3';
                this.render();
            });
        });
    },
    
    attachEvents() {
        document.getElementById('toggleConsole').addEventListener('click', (e) => {
            e.stopPropagation();
            this.toggle();
        });
        
        document.getElementById('clearConsole').addEventListener('click', (e) => {
            e.stopPropagation();
            this.clear();
        });
        
        document.querySelector('.debug-header').addEventListener('click', () => {
            this.toggle();
        });
        
        this.addSearchBar();
    },
    
    addSearchBar() {
        const controls = document.querySelector('.debug-controls');
        const searchInput = document.createElement('input');
        searchInput.type = 'text';
        searchInput.placeholder = 'Search logs...';
        searchInput.style.cssText = 'padding: 4px 8px; background: #0f3460; color: white; border: 1px solid #533483; border-radius: 3px; font-size: 11px; width: 150px; margin-right: 5px;';
        
        searchInput.addEventListener('input', (e) => {
            const query = e.target.value.toLowerCase();
            this.render(query);
        });
        
        controls.parentNode.insertBefore(searchInput, controls);
    },
    
    interceptConsoleLogs() {
        const originalLog = console.log;
        const originalWarn = console.warn;
        const originalError = console.error;
        
        console.log = (...args) => {
            originalLog.apply(console, args);
            this.log(args.join(' '), 'log');
        };
        
        console.warn = (...args) => {
            originalWarn.apply(console, args);
            this.warn(args.join(' '));
        };
        
        console.error = (...args) => {
            originalError.apply(console, args);
            this.error(args.join(' '));
        };
    },
    
    toggle() {
        const consoleEl = document.getElementById('debugConsole');
        this.isCollapsed = !this.isCollapsed;
        consoleEl.classList.toggle('collapsed', this.isCollapsed);
        document.getElementById('toggleConsole').textContent = this.isCollapsed ? '‚ñ≤' : '‚ñº';
    },
    
    clear() {
        this.logs = [];
        this.output.innerHTML = '';
        this.log('Console cleared', 'info');
    },
    
    log(message, type = 'log', metadata = {}) {
        const timestamp = new Date().toLocaleTimeString();
        const logEntry = {
            id: Date.now() + Math.random(),
            message,
            type,
            timestamp,
            metadata,
            stack: metadata.stack || new Error().stack
        };
        
        this.logs.push(logEntry);
        
        if (this.logs.length > this.maxLogs) {
            this.logs.shift();
        }
        
        this.render();
        
        if (type === 'error' && this.isCollapsed) {
            this.toggle();
        }
    },
    
    warn(message) {
        this.log(message, 'warn');
    },
    
    error(message, metadata = {}) {
        this.log(message, 'error', metadata);
    },
    
    render(searchQuery = '') {
        this.output.innerHTML = '';
        
        const filteredLogs = this.logs.filter(log => {
            const matchesFilter = this.filters[log.type];
            const matchesSearch = !searchQuery || log.message.toLowerCase().includes(searchQuery);
            return matchesFilter && matchesSearch;
        });
        
        filteredLogs.forEach(log => {
            const entry = document.createElement('div');
            entry.className = `debug-${log.type}`;
            entry.style.cssText = 'cursor: pointer; padding: 4px 0; border-bottom: 1px solid rgba(83, 52, 131, 0.2);';
            
            entry.innerHTML = `
                <span class="debug-timestamp">[${log.timestamp}]</span>
                ${this.formatMessage(log.message)}
            `;
            
            entry.addEventListener('click', () => {
                this.showLogDetails(log);
            });
            
            this.output.appendChild(entry);
        });
        
        this.output.scrollTop = this.output.scrollHeight;
    },
    
    formatMessage(message) {
        return message.replace(/block_(\w+)/g, (match, id) => {
            return `<span class="clickable-block" data-block-id="${id}" style="color: #3498db; text-decoration: underline; cursor: pointer;">${match}</span>`;
        });
    },
    
    showLogDetails(log) {
        const modal = document.createElement('div');
        modal.className = 'modal show';
        modal.style.zIndex = '10000';
        
        modal.innerHTML = `
            <div class="modal-content" style="max-width: 700px;">
                <h2>üîç Log Details</h2>
                <div style="background: #0f3460; padding: 15px; border-radius: 5px; margin: 15px 0;">
                    <div style="color: #bbb; font-size: 12px; margin-bottom: 10px;">
                        <strong>Type:</strong> <span style="color: ${this.getTypeColor(log.type)}">${log.type.toUpperCase()}</span><br>
                        <strong>Time:</strong> ${log.timestamp}
                    </div>
                    <div style="color: white; font-family: monospace; white-space: pre-wrap; word-break: break-word;">
                        ${log.message}
                    </div>
                </div>
                ${log.stack ? `
                    <details style="margin: 15px 0;">
                        <summary style="cursor: pointer; color: #95a5a6; font-size: 12px;">Stack Trace</summary>
                        <pre style="background: #0f3460; padding: 10px; border-radius: 5px; overflow-x: auto; font-size: 10px; color: #bbb; margin-top: 10px;">${log.stack}</pre>
                    </details>
                ` : ''}
                <div class="modal-buttons">
                    <button onclick="this.closest('.modal').remove()" style="background: #95a5a6;">Close</button>
                    <button onclick="navigator.clipboard.writeText('${log.message}'); showToast('üìã Copied to clipboard'); this.closest('.modal').remove();" style="background: #3498db;">Copy</button>
                </div>
            </div>
        `;
        
        document.body.appendChild(modal);
    },
    
    getTypeColor(type) {
        const colors = {
            log: '#4ec9b0',
            warn: '#dcdcaa',
            error: '#f48771',
            info: '#3498db'
        };
        return colors[type] || '#ffffff';
    },
    
    highlightBlock(blockId) {
        if (!window.workspace) return;
        
        const blocks = workspace.getAllBlocks(false);
        const targetBlock = blocks.find(b => b.id === blockId);
        
        if (targetBlock) {
            workspace.centerOnBlock(targetBlock.id);
            targetBlock.select();
            showToast('üìç Jumped to block');
        }
    },
    
    updateState(gameState) {
        if (!gameState) return;
        
        const stateMonitor = document.getElementById('stateMonitor');
        if (!stateMonitor) return;
        
        stateMonitor.style.display = 'block';
        
        const stateHTML = `
            <div style="color: #4ec9b0; font-weight: bold; margin-bottom: 10px;">
                üìä LIVE STATE 
                <button onclick="EnhancedDebugConsole.exportState()" style="float: right; padding: 2px 8px; background: #533483; color: white; border: none; border-radius: 3px; font-size: 10px; cursor: pointer;">Export JSON</button>
            </div>
            <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 10px; font-size: 11px;">
                ${this.renderStateProperty('Score', gameState.score || 0)}
                ${this.renderStateProperty('Health', gameState.health || 0)}
                ${this.renderStateProperty('Lives', gameState.lives || 0)}
                ${this.renderStateProperty('Entities', gameState.entities?.length || 0)}
                ${this.renderStateProperty('Camera X', Math.round(gameState.camera?.x || 0))}
                ${this.renderStateProperty('Camera Y', Math.round(gameState.camera?.y || 0))}
            </div>
        `;
        
        stateMonitor.innerHTML = stateHTML;
    },
    
    renderStateProperty(label, value) {
        return `<div><span style="color: #dcdcaa;">${label}:</span> <span style="color: white;">${value}</span></div>`;
    },
    
    exportState() {
        if (PreviewManager.runtime) {
            const stateJSON = JSON.stringify(PreviewManager.runtime.gameState, null, 2);
            navigator.clipboard.writeText(stateJSON);
            showToast('üìã State exported to clipboard');
            this.log('State exported: ' + stateJSON.length + ' chars', 'info');
        }
    },
    
    hideState() {
        const stateMonitor = document.getElementById('stateMonitor');
        if (stateMonitor) {
            stateMonitor.style.display = 'none';
        }
    }
};

document.addEventListener('click', (e) => {
    if (e.target.classList.contains('clickable-block')) {
        const blockId = e.target.dataset.blockId;
        EnhancedDebugConsole.highlightBlock(blockId);
    }
});

        // === DEBUG OVERLAY SYSTEM (First instance - commented out, using second one) ===
        /*
        if (typeof DebugOverlaySystem === 'undefined') {
        window.DebugOverlaySystem = class DebugOverlaySystem {
          constructor(renderSystem, entityManager, canvas) {
            this.enabled = false;
            this.showHitboxes = true;
            this.showPerformance = true;
            this.showEntityInfo = true;
            this.renderSystem = renderSystem;
            this.entityManager = entityManager;
            this.lastFrameTime = 0;
            this.frameCount = 0;
            this.fps = 60;
            this.canvas = canvas;
            this.ctx = canvas.getContext('2d');
            this.setupEventListeners();
          }

          setupEventListeners() {
            window.addEventListener('keydown', (e) => {
              if (e.key === 'F3') {
                this.toggle();
              } else if (e.key === 'F4') {
                this.toggleHitboxes();
              } else if (e.key === 'F5') {
                this.togglePerformance();
              } else if (e.key === 'F6') {
                this.toggleEntityInfo();
              }
            });
          }

          toggle() {
            this.enabled = !this.enabled;
            console.log(`Debug overlay ${this.enabled ? 'enabled' : 'disabled'}`);
            return this.enabled;
          }

          toggleHitboxes() {
            this.showHitboxes = !this.showHitboxes;
            console.log(`Hitboxes ${this.showHitboxes ? 'enabled' : 'disabled'}`);
            return this.showHitboxes;
          }

          togglePerformance() {
            this.showPerformance = !this.showPerformance;
            console.log(`Performance metrics ${this.showPerformance ? 'enabled' : 'disabled'}`);
            return this.showPerformance;
          }

          toggleEntityInfo() {
            this.showEntityInfo = !this.showEntityInfo;
            console.log(`Entity info ${this.showEntityInfo ? 'enabled' : 'disabled'}`);
            return this.showEntityInfo;
          }

          update(deltaTime) {
            if (!this.enabled) return;
            
            this.frameCount++;
            const now = performance.now();
            if (now - this.lastFrameTime >= 1000) {
              this.fps = this.frameCount;
              this.frameCount = 0;
              this.lastFrameTime = now;
            }
          }

          render() {
            if (!this.enabled) return;

            this.ctx.save();
            this.ctx.setTransform(1, 0, 0, 1, 0, 0);
            
            if (this.showHitboxes) {
              this.renderHitboxes();
            }
            
            if (this.showPerformance) {
              this.renderPerformanceMetrics();
            }
            
            if (this.showEntityInfo) {
              this.renderEntityInfo();
            }
            
            this.ctx.restore();
          }

          renderHitboxes() {
            const entities = this.entityManager?.getAllEntities?.() || [];
            const camera = this.renderSystem?.getCameraPosition?.() || { x: 0, y: 0 };
            const zoom = this.renderSystem?.getCameraZoom?.() || 1;
            
            entities.forEach(entity => {
              if (!entity.width || !entity.height) return;
              
              const screenPos = this.renderSystem && this.renderSystem.worldToScreen 
                ? this.renderSystem.worldToScreen(entity.x, entity.y)
                : { x: entity.x - camera.x, y: entity.y - camera.y };
              
              this.ctx.save();
              this.ctx.setTransform(1, 0, 0, 1, 0, 0);
              
              this.ctx.strokeStyle = entity.tags?.includes('player') ? '#3498db' : 
                                     entity.tags?.includes('enemy') ? '#e74c3c' : 
                                     entity.tags?.includes('collectible') ? '#2ecc71' : '#f1c40f';
              this.ctx.lineWidth = 2;
              this.ctx.strokeRect(
                screenPos.x - (entity.width / 2) * zoom,
                screenPos.y - (entity.height / 2) * zoom,
                entity.width * zoom,
                entity.height * zoom
              );
              
              this.ctx.font = '10px Arial';
              this.ctx.fillStyle = this.ctx.strokeStyle;
              this.ctx.textAlign = 'center';
              this.ctx.fillText(
                entity.id ? `ID: ${entity.id}` : entity.type || 'Entity',
                screenPos.x,
                screenPos.y - (entity.height / 2) * zoom - 5
              );
              
              if (entity.tags && entity.tags.length > 0) {
                this.ctx.font = '8px Arial';
                this.ctx.fillStyle = '#ecf0f1';
                entity.tags.forEach((tag, index) => {
                  this.ctx.fillText(
                    tag,
                    screenPos.x,
                    screenPos.y - (entity.height / 2) * zoom + (index * 10) + 10
                  );
                });
              }
              
              this.ctx.restore();
            });
          }

          renderPerformanceMetrics() {
            this.ctx.save();
            this.ctx.setTransform(1, 0, 0, 1, 0, 0);
            
            const metrics = [
              `FPS: ${Math.round(this.fps)}`,
              `Entities: ${this.entityManager?.getEntityCount?.() || 0}`,
              `Camera: (${Math.round(this.renderSystem?.getCameraPosition?.()?.x || 0)}, ${Math.round(this.renderSystem?.getCameraPosition?.()?.y || 0)})`,
              `Zoom: ${(this.renderSystem?.getCameraZoom?.() || 1).toFixed(2)}`
            ];
            
            this.ctx.font = '12px Arial';
            this.ctx.fillStyle = '#27ae60';
            this.ctx.textAlign = 'left';
            
            metrics.forEach((metric, index) => {
              this.ctx.fillText(metric, 10, 30 + (index * 20));
            });
            
            if (performance.memory) {
              const usedMB = Math.round(performance.memory.usedJSHeapSize / 1048576);
              const totalMB = Math.round(performance.memory.totalJSHeapSize / 1048576);
              this.ctx.fillText(`Memory: ${usedMB}/${totalMB} MB`, 10, 30 + (metrics.length * 20));
            }
            
            this.ctx.restore();
          }

          renderEntityInfo() {
            const mousePos = this.getMousePosition();
            if (!mousePos) return;
            
            const worldMouse = this.renderSystem?.screenToWorld
              ? this.renderSystem.screenToWorld(mousePos.x, mousePos.y)
              : mousePos;
            const nearbyEntities = this.entityManager?.getEntitiesNear?.(worldMouse.x, worldMouse.y, 100) || [];
            
            if (nearbyEntities.length === 0) return;
            
            this.ctx.save();
            this.ctx.setTransform(1, 0, 0, 1, 0, 0);
            
            const panelX = mousePos.x + 20;
            const panelY = mousePos.y + 20;
            const panelWidth = 200;
            
            this.ctx.fillStyle = 'rgba(22, 33, 62, 0.85)';
            this.ctx.fillRect(panelX, panelY, panelWidth, (nearbyEntities.length * 80) + 20);
            this.ctx.strokeStyle = '#533483';
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(panelX, panelY, panelWidth, (nearbyEntities.length * 80) + 20);
            
            this.ctx.font = '14px Arial';
            this.ctx.fillStyle = '#ecf0f1';
            this.ctx.textAlign = 'left';
            this.ctx.fillText('Entity Inspector', panelX + 10, panelY + 20);
            
            nearbyEntities.forEach((entity, index) => {
              const startY = panelY + 40 + (index * 80);
              
              this.ctx.font = '12px Arial';
              this.ctx.fillStyle = '#3498db';
              this.ctx.fillText(`Type: ${entity.type || 'Unknown'}`, panelX + 10, startY);
              this.ctx.fillStyle = '#95a5a6';
              this.ctx.fillText(`ID: ${entity.id || 'N/A'}`, panelX + 10, startY + 15);
              
              this.ctx.fillStyle = '#2ecc71';
              this.ctx.fillText(`Pos: (${Math.round(entity.x)}, ${Math.round(entity.y)})`, panelX + 10, startY + 30);
              
              if (entity.health !== undefined) {
                this.ctx.fillStyle = '#e74c3c';
                this.ctx.fillText(`Health: ${Math.round(entity.health)}`, panelX + 10, startY + 45);
              }
              
              if (entity.velocityX !== undefined || entity.velocityY !== undefined) {
                this.ctx.fillStyle = '#9b59b6';
                const velX = entity.velocityX ? Math.round(entity.velocityX) : 0;
                const velY = entity.velocityY ? Math.round(entity.velocityY) : 0;
                this.ctx.fillText(`Velocity: (${velX}, ${velY})`, panelX + 10, startY + 60);
              }
            });
            
            this.ctx.restore();
          }

          getMousePosition() {
            if (typeof inputSystem !== 'undefined' && inputSystem.getMouseX && inputSystem.getMouseY) {
              return {
                x: inputSystem.getMouseX(),
                y: inputSystem.getMouseY()
              };
            }
            return null;
          }

          drawDebugText(text, x, y, color = '#ecf0f1', size = 12) {
            if (!this.enabled) return;
            
            this.ctx.save();
            this.ctx.setTransform(1, 0, 0, 1, 0, 0);
            this.ctx.font = `${size}px Arial`;
            this.ctx.fillStyle = color;
            this.ctx.textAlign = 'left';
            this.ctx.fillText(text, x, y);
            this.ctx.restore();
          }

          drawDebugRect(x, y, width, height, color = '#f1c40f', lineWidth = 2) {
            if (!this.enabled) return;
            
            this.ctx.save();
            this.ctx.setTransform(1, 0, 0, 1, 0, 0);
            this.ctx.strokeStyle = color;
            this.ctx.lineWidth = lineWidth;
            this.ctx.strokeRect(x, y, width, height);
            this.ctx.restore();
          }

          drawDebugCircle(x, y, radius, color = '#3498db', lineWidth = 2) {
            if (!this.enabled) return;
            
            this.ctx.save();
            this.ctx.setTransform(1, 0, 0, 1, 0, 0);
            this.ctx.beginPath();
            this.ctx.arc(x, y, radius, 0, Math.PI * 2);
            this.ctx.strokeStyle = color;
            this.ctx.lineWidth = lineWidth;
            this.ctx.stroke();
            this.ctx.restore();
          }

          drawDebugLine(x1, y1, x2, y2, color = '#e74c3c', lineWidth = 2) {
            if (!this.enabled) return;
            
            this.ctx.save();
            this.ctx.setTransform(1, 0, 0, 1, 0, 0);
            this.ctx.beginPath();
            this.ctx.moveTo(x1, y1);
            this.ctx.lineTo(x2, y2);
            this.ctx.strokeStyle = color;
            this.ctx.lineWidth = lineWidth;
            this.ctx.stroke();
            this.ctx.restore();
          }

          log(message, category = 'info') {
            if (!this.enabled) return;
            
            const timestamp = new Date().toLocaleTimeString();
            const color = category === 'error' ? '#e74c3c' : 
                         category === 'warning' ? '#f39c12' : 
                         category === 'success' ? '#2ecc71' : '#3498db';
            
            console.log(`[DEBUG] [${timestamp}] [${category.toUpperCase()}] ${message}`);
            
            if (window.EnhancedDebugConsole) {
              window.EnhancedDebugConsole.log(`[${timestamp}] ${message}`, category);
            }
          }

          drawGrid(size = 32, color = 'rgba(255, 255, 255, 0.1)', majorLineColor = 'rgba(255, 255, 255, 0.3)') {
            if (!this.enabled) return;
            
            const camera = this.renderSystem?.getCameraPosition?.() || { x: 0, y: 0 };
            const zoom = this.renderSystem?.getCameraZoom?.() || 1;
            const width = this.canvas.width / zoom;
            const height = this.canvas.height / zoom;
            
            this.ctx.save();
            this.ctx.translate(-camera.x, -camera.y);
            this.ctx.scale(zoom, zoom);
            
            this.ctx.strokeStyle = color;
            this.ctx.lineWidth = 1;
            
            for (let x = Math.floor(camera.x / size) * size; x < camera.x + width; x += size) {
              this.ctx.beginPath();
              this.ctx.moveTo(x, camera.y);
              this.ctx.lineTo(x, camera.y + height);
              
              if (Math.abs(x) % (size * 10) === 0) {
                this.ctx.strokeStyle = majorLineColor;
                this.ctx.lineWidth = 2;
              } else {
                this.ctx.strokeStyle = color;
                this.ctx.lineWidth = 1;
              }
              
              this.ctx.stroke();
            }
            
            for (let y = Math.floor(camera.y / size) * size; y < camera.y + height; y += size) {
              this.ctx.beginPath();
              this.ctx.moveTo(camera.x, y);
              this.ctx.lineTo(camera.x + width, y);
              
              if (Math.abs(y) % (size * 10) === 0) {
                this.ctx.strokeStyle = majorLineColor;
                this.ctx.lineWidth = 2;
              } else {
                this.ctx.strokeStyle = color;
                this.ctx.lineWidth = 1;
              }
              
              this.ctx.stroke();
            }
            
            this.ctx.restore();
          }
        }
        } else {
            console.warn('‚ö†Ô∏è DebugOverlaySystem already declared. Using existing instance.');
        }
        */

        // Initialize global DebugOverlaySystem instance
        window.debugOverlaySystem = null;

        function toggleDebugOverlay() {
          if (!window.debugOverlaySystem) return false;
          return window.debugOverlaySystem.toggle();
        }

        function isDebugOverlayEnabled() {
          return window.debugOverlaySystem?.enabled || false;
        }

        function logDebug(message, category = 'info') {
          if (window.debugOverlaySystem) {
            window.debugOverlaySystem.log(message, category);
          }
        }

        // === GAME RUNTIME CLASS ===
        class GameRuntime {
            constructor() {
                this.canvas = null;
                this.ctx = null;
                this.gameState = {
                    score: 0,
                    health: 100,
                    lives: 3,
                    camera: { x: 0, y: 0, targetX: 0, targetY: 0, smooth: 0.1 },
                    inventory: { slots: Array(20).fill(null) },
                    buffs: {},
                    cooldowns: {},
                    zones: []
                };
                this.entities = [];
                this.background = null;
                this.keys = {};
                this.mouse = { x: 0, y: 0, clicked: false };
                this.eventHandlers = {
                    onStart: [],
                    onKeyPress: {},
                    onKeyRelease: {},
                    onMouseClick: [],
                    onCollision: [],
                    onTimer: [],
                    onSceneLoad: {},
                    onObjectDestroyed: {},
                    onScoreChange: [],
                    onAreaEnter: {},
                    onLevelComplete: []
                };
                this.userFunctions = {};
                this.delayedCalls = [];
                this.aiStates = new Map();
                this.tilemaps = [];
                this.itemDefinitions = {
                    wood: { name: "Wood", icon: "ü™µ", stackable: true, maxStack: 99 },
                    stone: { name: "Stone", icon: "ü™®", stackable: true, maxStack: 99 },
                    sword_basic: { name: "Basic Sword", icon: "‚öîÔ∏è", stackable: false, type: "weapon", damage: 10 }
                };
                this.paused = false;
                this.timeScale = 1.0;
            }

            initialize(canvas, ctx, code) {
                this.canvas = canvas;
                this.ctx = ctx;
                this.resetState();
                this.setupInput();
                this.compileGameCode(code);
                this.triggerStartEvents();
            }

            resetState() {
                this.gameState = {
                    score: 0,
                    health: 100,
                    lives: 3,
                    camera: { x: 0, y: 0, targetX: 0, targetY: 0, smooth: 0.1 },
                    inventory: { slots: Array(20).fill(null) },
                    buffs: {},
                    cooldowns: {},
                    zones: [],
                    entities: []
                };
                this.entities = [];
                this.keys = {};
                this.mouse = { x: 0, y: 0, clicked: false };
                this.delayedCalls = [];
                this.aiStates.clear();
                this.tilemaps = [];
            }

            setupInput() {
                this.canvas.addEventListener('mousemove', (e) => {
                    const rect = this.canvas.getBoundingClientRect();
                    this.mouse.x = e.clientX - rect.left;
                    this.mouse.y = e.clientY - rect.top;
                });

                this.canvas.addEventListener('click', (e) => {
                    this.mouse.clicked = true;
                    this.triggerMouseClick();
                    setTimeout(() => this.mouse.clicked = false, 100);
                });

                window.addEventListener('keydown', (e) => {
                    if (!this.keys[e.key]) {
                        this.keys[e.key] = true;
                        this.triggerKeyEvents(e.key, 'press');
                    }
                });

                window.addEventListener('keyup', (e) => {
                    this.keys[e.key] = false;
                    this.triggerKeyEvents(e.key, 'release');
                });
            }

            setBackground(imageData) {
                const img = new Image();
                img.onload = () => {
                    this.background = img;
                };
                img.src = imageData;
            }

            compileGameCode(code) {
                const sandbox = {
                    onGameStart: (fn) => this.eventHandlers.onStart.push(fn),
                    onSceneLoad: (scene, fn) => {
                        if (!this.eventHandlers.onSceneLoad[scene]) this.eventHandlers.onSceneLoad[scene] = [];
                        this.eventHandlers.onSceneLoad[scene].push(fn);
                    },
                    onKeyPress: (key, fn) => {
                        if (!this.eventHandlers.onKeyPress[key]) this.eventHandlers.onKeyPress[key] = [];
                        this.eventHandlers.onKeyPress[key].push(fn);
                    },
                    onMouseClick: (fn) => this.eventHandlers.onMouseClick.push(fn),
                    onCollision: (obj1, obj2, fn) => this.eventHandlers.onCollision.push({ obj1, obj2, fn }),
                    onCollisionTagged: (tag1, tag2, fn) => this.eventHandlers.onCollision.push({ tag1, tag2, fn, usesTags: true }),
                    onObjectDestroyed: (tag, fn) => {
                        if (!this.eventHandlers.onObjectDestroyed[tag]) this.eventHandlers.onObjectDestroyed[tag] = [];
                        this.eventHandlers.onObjectDestroyed[tag].push(fn);
                    },
                    onScoreChange: (type, fn) => this.eventHandlers.onScoreChange.push({ type, fn }),
                    onAreaEnter: (zone, fn) => {
                        if (!this.eventHandlers.onAreaEnter[zone]) this.eventHandlers.onAreaEnter[zone] = [];
                        this.eventHandlers.onAreaEnter[zone].push(fn);
                    },
                    onLevelComplete: (fn) => this.eventHandlers.onLevelComplete.push(fn),
                    everySeconds: (seconds, fn) => this.eventHandlers.onTimer.push({ interval: seconds * 1000, lastTrigger: 0, fn }),
                    
                    movePlayer: (dir, amt) => this.movePlayer(dir, amt),
                    setVelocity: (axis, val) => this.setVelocity(axis, val),
                    applyGravity: (force) => this.applyGravity(force),
                    applyFriction: (amt) => this.applyFriction(amt),
                    jumpBuffered: (force, buffer) => this.jumpBuffered(force, buffer),
                    dash: (dir, dist) => this.dash(dir, dist),
                    knockback: (force, angle) => this.knockback(force, angle),
                    moveAlongPath: (obj, path, speed) => this.moveAlongPath(obj, path, speed),
                    findPathTo: (target) => this.findPathTo(target),
                    
                    aiPatrol: (x1, x2) => this.aiPatrol(x1, x2),
                    
                    aiInitState: (entity, defaultState) => {
                        if (entity && typeof entity.id === 'number') {
                            if (!this.aiStates.has(entity.id)) {
                                this.aiStates.set(entity.id, { currentState: defaultState, data: {} });
                            }
                        }
                    },
                    aiSetState: (entity, newState, data = {}) => {
                        if (entity && typeof entity.id === 'number') {
                            const state = this.aiStates.get(entity.id);
                            if (state) {
                                EnhancedDebugConsole.log(`AI ${entity.id} changed state: ${state.currentState} -> ${newState}`);
                                state.currentState = newState;
                                state.data = { ...state.data, ...data };
                            }
                        }
                    },
                    aiGetState: (entity) => {
                        if (entity && typeof entity.id === 'number') {
                            const state = this.aiStates.get(entity.id);
                            return state ? state.currentState : null;
                        }
                        return null;
                    },
                    aiIsInState: (entity, stateName) => {
                        const state = this.aiGetState(entity);
                        return state === stateName;
                    },
                    
                    aiChase: (target, speed) => this.aiChase(target, speed),
                    aiFlee: (target, speed) => this.aiFlee(target, speed),
                    
                    spawnSprite: (type, x, y) => this.spawnSprite(type, x, y),
                    destroySprite: (target) => this.destroySprite(target),
                    
                    inventoryAdd: (item, qty) => this.inventoryAdd(item, qty),
                    inventoryRemove: (item, qty) => this.inventoryRemove(item, qty),
                    inventoryHas: (item) => this.inventoryHas(item),
                    inventoryGetCount: (item) => this.inventoryGetCount(item),
                    inventorySwapSlots: (slot1, slot2) => this.inventorySwapSlots(slot1, slot2),
                    
                    createTilemap: (w, h, tw, th) => this.createTilemap(w, h, tw, th),
                    setTile: (mapId, x, y, tileId, layer) => this.setTile(mapId, x, y, tileId, layer),
                    getTile: (mapId, x, y, layer) => this.getTile(mapId, x, y, layer),
                    
                    applyPowerup: (type, dur) => this.applyPowerup(type, dur),
                    applyDebuff: (type, dur) => this.applyDebuff(type, dur),
                    hasBuff: (buff) => this.hasBuff(buff),
                    createPickup: (type, x, y) => this.createPickup(type, x, y),
                    
                    cameraFollow: (target, smooth) => this.cameraFollow(target, smooth),
                    cameraClamp: (minX, maxX) => this.cameraClamp(minX, maxX),
                    setCameraPosition: (x, y) => this.setCameraPosition(x, y),
                    setCameraZoom: (zoom) => this.setCameraZoom(zoom),
                    setCameraBounds: (minX, maxX, minY, maxY) => this.setCameraBounds(minX, maxX, minY, maxY),
                    cameraShake: (intensity, duration) => this.cameraShake(intensity, duration),
                    transitionCamera: (toX, toY, duration, easing) => this.transitionCamera(toX, toY, duration, easing),
                    getCameraPosition: () => this.getCameraPosition(),
                    getCameraZoom: () => this.getCameraZoom(),
                    screenToWorld: (x, y) => this.screenToWorld(x, y),
                    worldToScreen: (x, y) => this.worldToScreen(x, y),
                    
                    setHealth: (val) => this.gameState.health = val,
                    addHealth: (amt) => this.gameState.health = Math.max(0, this.gameState.health + amt),
                    setLives: (val) => this.gameState.lives = val,
                    addScore: (pts) => {
                        const oldScore = this.gameState.score;
                        this.gameState.score += pts;
                        this.triggerScoreChange(pts > 0 ? 'increase' : 'decrease');
                    },
                    
                    delay: (seconds, fn) => this.delay(seconds, fn),
                    cooldown: (name, duration, fn) => this.cooldown(name, duration, fn),
                    randomInt: (min, max) => Math.floor(Math.random() * (max - min + 1)) + min,
                    weightedRandom: (weights) => {
                        const total = weights.reduce((a, b) => a + b, 0);
                        let random = Math.random() * total;
                        for (let i = 0; i < weights.length; i++) {
                            if (random < weights[i]) return i;
                            random -= weights[i];
                        }
                        return weights.length - 1;
                    },
                    
                    saveGameState: () => this.saveGameState(),
                    loadGameState: () => this.loadGameState(),
                    
                    loadScene: (name) => this.loadScene(name),
                    setCameraTarget: (entityOrX, y) => this.setCameraTarget(entityOrX, y),
                    updateCamera: () => this.updateCamera(),
                    pauseGame: () => this.pauseGame(),
                    resumeGame: () => this.resumeGame(),
                    setTimeScale: (scale) => this.setTimeScale(scale),
                    forEachWithTag: (tag, callback) => this.forEachWithTag(tag, callback),
                    countWithTag: (tag) => this.countWithTag(tag),
                    destroyAllWithTag: (tag) => this.destroyAllWithTag(tag),
                    
                    gameState: this.gameState
                };

                try {
                    const fn = new Function(...Object.keys(sandbox), code);
                    fn(...Object.values(sandbox));
                    EnhancedDebugConsole.log('‚úÖ Game code compiled successfully');
                } catch (error) {
                    EnhancedDebugConsole.error('‚ùå Compilation Error: ' + error.message);
                    throw error;
                }
            }

            triggerStartEvents() {
                this.eventHandlers.onStart.forEach(fn => {
                    try {
                        fn();
                    } catch (error) {
                        EnhancedDebugConsole.error('Start Event Error: ' + error.message);
                    }
                });
            }

            triggerKeyEvents(key, type) {
                const keyMap = {
                    'ArrowUp': 'UP',
                    'ArrowDown': 'DOWN',
                    'ArrowLeft': 'LEFT',
                    'ArrowRight': 'RIGHT',
                    ' ': 'SPACE'
                };
                const mappedKey = keyMap[key] || key.toUpperCase();
                
                const handlers = type === 'press' ? this.eventHandlers.onKeyPress : this.eventHandlers.onKeyRelease;
                if (handlers && handlers[mappedKey]) {
                    handlers[mappedKey].forEach(fn => {
                        try {
                            fn();
                        } catch (error) {
                            DebugConsole.error(`Key ${type} error: ${error.message}`);
                        }
                    });
                }
            }

            triggerMouseClick() {
                this.eventHandlers.onMouseClick.forEach(fn => {
                    try {
                        fn();
                    } catch (error) {
                        DebugConsole.error('Mouse click error: ' + error.message);
                    }
                });
            }

            triggerScoreChange(type) {
                this.eventHandlers.onScoreChange
                    .filter(h => h.type === type)
                    .forEach(h => {
                        try {
                            h.fn();
                        } catch (error) {
                            DebugConsole.error('Score change error: ' + error.message);
                        }
                    });
            }

            update(deltaTime) {
                if (this.paused) return;

                const now = Date.now();
                
                this.updateCamera();
                
                this.entities.forEach(entity => {
                    if (entity.aiMetadata) {
                        const aiMetadata = entity.aiMetadata;
                        if (aiMetadata.aiType === 'chase') {
                            this.aiChase(aiMetadata.targetTag, aiMetadata.speed, entity.id);
                        } else if (aiMetadata.aiType === 'flee') {
                            this.aiFlee(aiMetadata.threatTag, aiMetadata.speed, entity.id);
                        }
                    }
                });
                
                this.eventHandlers.onTimer.forEach(timer => {
                    if (now - timer.lastTrigger >= timer.interval) {
                        timer.lastTrigger = now;
                        try {
                            timer.fn();
                        } catch (error) {
                            DebugConsole.error('Timer error: ' + error.message);
                        }
                    }
                });

                this.delayedCalls = this.delayedCalls.filter(call => {
                    if (now >= call.time) {
                        try {
                            call.fn();
                        } catch (error) {
                            DebugConsole.error('Delayed call error: ' + error.message);
                        }
                        return false;
                    }
                    return true;
                });

                Object.keys(this.gameState.buffs).forEach(buff => {
                    if (this.gameState.buffs[buff] < now) {
                        delete this.gameState.buffs[buff];
                    }
                });

                const cam = this.gameState.camera;
                cam.x += (cam.targetX - cam.x) * cam.smooth;
                cam.y += (cam.targetY - cam.y) * cam.smooth;

                DebugConsole.updateState(this.gameState);
            }

            render() {
                this.ctx.fillStyle = '#000';
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

                if (this.background) {
                    this.ctx.drawImage(this.background, 0, 0, this.canvas.width, this.canvas.height);
                }

                this.renderTilemaps();

                this.ctx.save();
                this.ctx.translate(-this.gameState.camera.x, -this.gameState.camera.y);

                this.entities.forEach(entity => {
                    if (entity.currentAnimationFrame) {
                        const anim = entity.currentAnimationFrame.animation;
                        const frameIdx = entity.currentAnimationFrame.frameIndex;
                        const spriteImage = entity.currentAnimationFrame.spriteImage;
                        
                        if (spriteImage && spriteImage.complete && spriteImage.naturalWidth > 0) {
                            const frameCol = frameIdx % anim.framesPerRow;
                            const frameRow = Math.floor(frameIdx / anim.framesPerRow);
                            const srcX = Math.round(frameCol * anim.frameWidth);
                            const srcY = Math.round(frameRow * anim.frameHeight);
                            
                            const offset = (anim.frameOffsets && anim.frameOffsets[frameIdx]) || { centerX: anim.frameWidth / 2, bottomY: anim.frameHeight };
                            
                            const drawX = Math.round(entity.x - offset.centerX);
                            const drawY = Math.round(entity.y - offset.bottomY);
                            
                            try {
                                this.ctx.drawImage(
                                    spriteImage,
                                    srcX, srcY, anim.frameWidth, anim.frameHeight,
                                    drawX, drawY, anim.frameWidth, anim.frameHeight
                                );
                            } catch (e) {
                                console.warn(`Animation render error: ${e.message}`);
                                this.ctx.fillStyle = entity.color || '#27ae60';
                                this.ctx.fillRect(entity.x, entity.y, entity.width, entity.height);
                            }
                        } else {
                            this.ctx.fillStyle = entity.color || '#27ae60';
                            this.ctx.fillRect(entity.x, entity.y, entity.width, entity.height);
                        }
                    } else if (entity.sprite) {
                        this.ctx.drawImage(entity.sprite, entity.x, entity.y, entity.width, entity.height);
                    } else {
                        this.ctx.fillStyle = entity.color || '#27ae60';
                        this.ctx.fillRect(entity.x, entity.y, entity.width, entity.height);
                    }
                    
                    if (window.debugOverlays && window.debugOverlays.enabled) {
                        this.ctx.strokeStyle = '#ffff00';
                        this.ctx.strokeRect(entity.x, entity.y, entity.width, entity.height);
                        this.ctx.fillStyle = '#ffff00';
                        this.ctx.font = '10px monospace';
                        this.ctx.fillText(entity.type, entity.x, entity.y - 5);
                    }
                });

                this.ctx.restore();

                if (window.debugOverlays && window.debugOverlays.enabled) {
                    this.renderDebugOverlays();
                }
            }

            renderDebugOverlays() {
                this.ctx.fillStyle = 'rgba(255, 255, 0, 0.8)';
                this.ctx.font = '12px monospace';
                this.ctx.fillText(`Entities: ${this.entities.length}`, 10, 20);
                this.ctx.fillText(`Health: ${this.gameState.health}`, 10, 35);
                this.ctx.fillText(`Score: ${this.gameState.score}`, 10, 50);
                this.ctx.fillText(`Buffs: ${Object.keys(this.gameState.buffs).length}`, 10, 65);
            }

            movePlayer(dir, amt) {
                const player = this.entities.find(e => e.tags && e.tags.includes('player'));
                if (!player) return;
                
                const movement = {
                    'UP': { x: 0, y: -amt },
                    'DOWN': { x: 0, y: amt },
                    'LEFT': { x: -amt, y: 0 },
                    'RIGHT': { x: amt, y: 0 }
                };
                
                if (movement[dir]) {
                    player.x += movement[dir].x;
                    player.y += movement[dir].y;
                }
            }

            jumpBuffered(force, buffer) {
                DebugConsole.log(`Jump buffered: force=${force}, buffer=${buffer}s`);
            }

            dash(dir, dist) {
                DebugConsole.log(`Dash ${dir} distance=${dist}`);
            }

            knockback(force, angle) {
                DebugConsole.log(`Knockback: force=${force}, angle=${angle}¬∞`);
            }

            moveAlongPath(obj, path, speed) {
                DebugConsole.log(`Move ${obj} along ${path} at speed ${speed}`);
            }

            findPathTo(target) {
                DebugConsole.log(`Pathfinding to ${target}`);
            }

            aiPatrol(x1, x2) {
                const entity = this.entities[this.entities.length - 1];
                if (!entity) return;
                
                if (!this.aiStates.has(entity.id)) {
                    this.aiStates.set(entity.id, { patrolDir: 1, x1, x2 });
                }
                
                const state = this.aiStates.get(entity.id);
                entity.x += state.patrolDir * 2;
                
                if (entity.x >= x2) state.patrolDir = -1;
                if (entity.x <= x1) state.patrolDir = 1;
            }

            aiChase(targetEntityTag, speed, entityID) {
                const chaserEntity = entityID !== undefined ? this.entities.find(e => e.id === entityID) : this.entities[this.entities.length - 1];
                if (!chaserEntity) {
                    EnhancedDebugConsole.warn(`AI Chase: Chaser entity (ID: ${entityID}) not found.`);
                    return;
                }

                const targetEntity = this.entities.reduce((closest, entity) => {
                    if (entity.tags && entity.tags.includes(targetEntityTag) && entity.id !== chaserEntity.id) {
                        const dist = Math.sqrt(
                            Math.pow(entity.x - chaserEntity.x, 2) +
                            Math.pow(entity.y - chaserEntity.y, 2)
                        );
                        if (!closest || dist < closest.dist) {
                            return { entity, dist };
                        }
                    }
                    return closest;
                }, null);

                if (targetEntity) {
                    const dx = targetEntity.entity.x - chaserEntity.x;
                    const dy = targetEntity.entity.y - chaserEntity.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    if (distance > 0) {
                        chaserEntity.vx = (dx / distance) * speed;
                        chaserEntity.vy = (dy / distance) * speed;
                    }
                } else {
                    chaserEntity.vx = 0;
                    chaserEntity.vy = 0;
                }
            }

            aiFlee(targetEntityTag, speed, entityID) {
                const fleeEntity = entityID !== undefined ? this.entities.find(e => e.id === entityID) : this.entities[this.entities.length - 1];
                if (!fleeEntity) {
                    EnhancedDebugConsole.warn(`AI Flee: Fleeing entity (ID: ${entityID}) not found.`);
                    return;
                }

                const targetEntity = this.entities.reduce((closest, entity) => {
                    if (entity.tags && entity.tags.includes(targetEntityTag) && entity.id !== fleeEntity.id) {
                        const dist = Math.sqrt(
                            Math.pow(entity.x - fleeEntity.x, 2) +
                            Math.pow(entity.y - fleeEntity.y, 2)
                        );
                        if (!closest || dist < closest.dist) {
                            return { entity, dist };
                        }
                    }
                    return closest;
                }, null);

                if (targetEntity) {
                    const dx = fleeEntity.x - targetEntity.entity.x;
                    const dy = fleeEntity.y - targetEntity.entity.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    if (distance > 0) {
                        fleeEntity.vx = (dx / distance) * speed;
                        fleeEntity.vy = (dy / distance) * speed;
                    }
                } else {
                    fleeEntity.vx = 0;
                    fleeEntity.vy = 0;
                }
            }

            inventoryAdd(itemID, quantity = 1) {
                const itemDef = this.itemDefinitions[itemID];
                if (!itemDef) {
                    EnhancedDebugConsole.error(`Unknown item ID: ${itemID}`);
                    return false;
                }

                if (itemDef.stackable) {
                    for (let i = 0; i < this.gameState.inventory.slots.length; i++) {
                        const slot = this.gameState.inventory.slots[i];
                        if (slot && slot.id === itemID && slot.qty < itemDef.maxStack) {
                            const spaceLeft = itemDef.maxStack - slot.qty;
                            const toAdd = Math.min(quantity, spaceLeft);
                            slot.qty += toAdd;
                            quantity -= toAdd;
                            if (quantity <= 0) break;
                        }
                    }
                }

                if (quantity > 0) {
                    for (let i = 0; i < this.gameState.inventory.slots.length; i++) {
                        if (!this.gameState.inventory.slots[i]) {
                            const maxPossible = itemDef.stackable ? itemDef.maxStack : 1;
                            const toAdd = Math.min(quantity, maxPossible);
                            this.gameState.inventory.slots[i] = { id: itemID, qty: toAdd };
                            quantity -= toAdd;
                            if (quantity <= 0) break;
                        }
                    }
                }

                if (quantity > 0) {
                    EnhancedDebugConsole.warn(`Could not add ${quantity}x ${itemID}, inventory full or item not stackable enough.`);
                    return false;
                }
                EnhancedDebugConsole.log(`Added items to inventory`);
                return true;
            }

            inventoryRemove(itemID, quantity = 1) {
                let removed = 0;
                for (let i = 0; i < this.gameState.inventory.slots.length; i++) {
                    const slot = this.gameState.inventory.slots[i];
                    if (slot && slot.id === itemID) {
                        const toRemove = Math.min(quantity - removed, slot.qty);
                        slot.qty -= toRemove;
                        removed += toRemove;
                        if (slot.qty <= 0) {
                            this.gameState.inventory.slots[i] = null;
                        }
                        if (removed >= quantity) break;
                    }
                }
                if (removed === quantity) {
                    EnhancedDebugConsole.log(`Removed ${removed}x ${itemID} from inventory`);
                    return true;
                } else {
                    EnhancedDebugConsole.warn(`Could not remove ${quantity}x ${itemID}, not enough in inventory.`);
                    return false;
                }
            }

            inventoryHas(itemID, quantity = 1) {
                let count = 0;
                for (const slot of this.gameState.inventory.slots) {
                    if (slot && slot.id === itemID) {
                        count += slot.qty;
                        if (count >= quantity) return true;
                    }
                }
                return false;
            }

            inventoryGetCount(itemID) {
                let count = 0;
                for (const slot of this.gameState.inventory.slots) {
                    if (slot && slot.id === itemID) {
                        count += slot.qty;
                    }
                }
                return count;
            }

            inventorySwapSlots(slotIndex1, slotIndex2) {
                if (slotIndex1 >= 0 && slotIndex1 < this.gameState.inventory.slots.length &&
                    slotIndex2 >= 0 && slotIndex2 < this.gameState.inventory.slots.length) {
                    const temp = this.gameState.inventory.slots[slotIndex1];
                    this.gameState.inventory.slots[slotIndex1] = this.gameState.inventory.slots[slotIndex2];
                    this.gameState.inventory.slots[slotIndex2] = temp;
                    EnhancedDebugConsole.log(`Swapped inventory slots ${slotIndex1} and ${slotIndex2}`);
                }
            }

            createTilemap(widthInTiles, heightInTiles, tileWidth, tileHeight, defaultTileID = 0) {
                EnhancedDebugConsole.log(`Creating tilemap: ${widthInTiles}x${heightInTiles}, tile: ${tileWidth}x${tileHeight}`);
                const newMap = {
                    id: `tilemap_${this.tilemaps.length}`,
                    width: widthInTiles,
                    height: heightInTiles,
                    tileWidth: tileWidth,
                    tileHeight: tileHeight,
                    layers: {
                        ground: Array(widthInTiles * heightInTiles).fill(defaultTileID),
                        objects: Array(widthInTiles * heightInTiles).fill(-1),
                        collision: Array(widthInTiles * heightInTiles).fill(false)
                    }
                };
                this.tilemaps.push(newMap);
                return newMap.id;
            }

            setTile(tilemapID, x, y, tileID, layerName = 'ground') {
                const map = this.tilemaps.find(t => t.id === tilemapID);
                if (map && x >= 0 && x < map.width && y >= 0 && y < map.height) {
                    const index = y * map.width + x;
                    if (map.layers[layerName]) {
                        map.layers[layerName][index] = tileID;
                        EnhancedDebugConsole.log(`Set tile at (${x},${y}) on layer '${layerName}' to ID ${tileID}`);
                    } else {
                        EnhancedDebugConsole.warn(`Tilemap layer '${layerName}' does not exist.`);
                    }
                } else {
                    EnhancedDebugConsole.warn(`Invalid tilemap ID or coordinates: ${tilemapID}, (${x}, ${y})`);
                }
            }

            getTile(tilemapID, x, y, layerName = 'ground') {
                const map = this.tilemaps.find(t => t.id === tilemapID);
                if (map && x >= 0 && x < map.width && y >= 0 && y < map.height) {
                    const index = y * map.width + x;
                    if (map.layers[layerName]) {
                        return map.layers[layerName][index];
                    }
                }
                return -1;
            }

            renderTilemaps() {
                for (const map of this.tilemaps) {
                    for (const layerName in map.layers) {
                        if (layerName === 'collision') continue;
                        const layer = map.layers[layerName];
                        for (let y = 0; y < map.height; y++) {
                            for (let x = 0; x < map.width; x++) {
                                const index = y * map.width + x;
                                const tileID = layer[index];
                                if (tileID !== -1) {
                                    this.ctx.fillStyle = `hsl(${tileID * 30 % 360}, 50%, 50%)`;
                                    this.ctx.fillRect(x * map.tileWidth, y * map.tileHeight, map.tileWidth, map.tileHeight);
                                    this.ctx.strokeStyle = 'black';
                                    this.ctx.strokeRect(x * map.tileWidth, y * map.tileHeight, map.tileWidth, map.tileHeight);
                                }
                            }
                        }
                    }
                }
            }

            applyPowerup(type, duration) {
                this.gameState.buffs[type] = Date.now() + (duration * 1000);
                DebugConsole.log(`Applied powerup: ${type} for ${duration}s`);
            }

            applyDebuff(type, duration) {
                this.gameState.buffs[`debuff_${type}`] = Date.now() + (duration * 1000);
                DebugConsole.log(`Applied debuff: ${type} for ${duration}s`);
            }

            hasBuff(buff) {
                return this.gameState.buffs[buff] && this.gameState.buffs[buff] > Date.now();
            }

            createPickup(type, x, y) {
                this.spawnSprite(type, x, y);
                DebugConsole.log(`Created pickup: ${type} at (${x}, ${y})`);
            }

            delay(seconds, fn) {
                this.delayedCalls.push({
                    time: Date.now() + (seconds * 1000),
                    fn
                });
            }

            cooldown(name, duration, fn) {
                const now = Date.now();
                const cooldownEnd = this.gameState.cooldowns[name] || 0;
                
                if (now >= cooldownEnd) {
                    this.gameState.cooldowns[name] = now + (duration * 1000);
                    try {
                        fn();
                    } catch (error) {
                        DebugConsole.error(`Cooldown '${name}' error: ${error.message}`);
                    }
                }
            }

            spawnSprite(type, x, y) {
                const entity = {
                    id: Date.now() + Math.random(),
                    type,
                    x,
                    y,
                    width: 32,
                    height: 32,
                    tags: [type]
                };
                
                const animation = Object.values(AssetManager.assets.animations || []).find(a => a.name === type);
                if (animation) {
                    if (!gameAnimationRuntime.spriteSheetCache.has(animation.id)) {
                        const img = new Image();
                        img.src = animation.spriteSheet;
                        gameAnimationRuntime.spriteSheetCache.set(animation.id, img);
                    }
                    
                    entity.currentAnimationFrame = {
                        animation: animation,
                        frameIndex: 0,
                        spriteImage: gameAnimationRuntime.spriteSheetCache.get(animation.id)
                    };
                    entity.width = animation.frameWidth;
                    entity.height = animation.frameHeight;
                }
                
                this.entities.push(entity);
                this.gameState.entities = this.entities;
                DebugConsole.log(`Spawned ${type} at (${x}, ${y})`);
            }

            destroySprite(target) {
                const before = this.entities.length;
                
                if (target === 'THIS') {
                    this.entities.pop();
                } else if (target.startsWith('ALL_')) {
                    const tag = target.replace('ALL_', '').toLowerCase();
                    this.entities = this.entities.filter(e => !e.tags || !e.tags.includes(tag));
                } else {
                    this.entities = this.entities.filter(e => e.type !== target);
                }
                
                this.gameState.entities = this.entities;
                DebugConsole.log(`Destroyed ${before - this.entities.length} entities`);
            }

            saveGameState() {
                const saveData = {
                    score: this.gameState.score,
                    health: this.gameState.health,
                    lives: this.gameState.lives,
                    inventory: this.gameState.inventory,
                    timestamp: Date.now()
                };
                localStorage.setItem('lupiforge_gamesave', JSON.stringify(saveData));
                DebugConsole.log('Game state saved');
            }

            loadGameState() {
                const saved = localStorage.getItem('lupiforge_gamesave');
                if (saved) {
                    const saveData = JSON.parse(saved);
                    this.gameState.score = saveData.score;
                    this.gameState.health = saveData.health;
                    this.gameState.lives = saveData.lives;
                    this.gameState.inventory = saveData.inventory;
                    DebugConsole.log('Game state loaded');
                }
            }

            cameraFollow(target, smooth) {
                this.gameState.camera.smooth = smooth;
                const targetEntity = this.entities.find(e => e.tags && e.tags.includes(target));
                if (targetEntity) {
                    this.gameState.camera.targetX = targetEntity.x - this.canvas.width / 2;
                    this.gameState.camera.targetY = targetEntity.y - this.canvas.height / 2;
                }
            }

            cameraClamp(minX, maxX) {
                this.gameState.camera.x = Math.max(minX, Math.min(maxX, this.gameState.camera.x));
            }

            setVelocity(axis, val) {
                DebugConsole.log(`Set ${axis} velocity to ${val}`);
            }

            applyGravity(force) {
                DebugConsole.log(`Applied gravity force: ${force}`);
            }

            applyFriction(amt) {
                DebugConsole.log(`Applied friction: ${amt}`);
            }

            getScore() {
                return this.gameState.score;
            }

            stop() {
                DebugConsole.log('Game runtime stopped');
                DebugConsole.hideState();
            }

            loadScene(sceneName) {
                EnhancedDebugConsole.log(`üé¨ Loading scene: ${sceneName}`);
                this.entities = [];
                this.gameState.inventory = { slots: Array(20).fill(null) };
                this.gameState.score = 0;
                this.gameState.health = 100;
                this.gameState.lives = 3;
            }

            setCameraTarget(entityOrX, y = null) {
                if (typeof entityOrX === 'object' && entityOrX.x !== undefined) {
                    this.gameState.camera.targetX = entityOrX.x - this.canvas.width / 2;
                    this.gameState.camera.targetY = entityOrX.y - this.canvas.height / 2;
                } else if (typeof entityOrX === 'number' && y !== null) {
                    this.gameState.camera.targetX = entityOrX - this.canvas.width / 2;
                    this.gameState.camera.targetY = y - this.canvas.height / 2;
                } else {
                    this.gameState.camera.targetX = null;
                    this.gameState.camera.targetY = null;
                }
            }

            updateCamera() {
                if (this.gameState.camera.targetX !== null && this.gameState.camera.targetY !== null) {
                    this.gameState.camera.x += (this.gameState.camera.targetX - this.gameState.camera.x) * this.gameState.camera.smooth;
                    this.gameState.camera.y += (this.gameState.camera.targetY - this.gameState.camera.y) * this.gameState.camera.smooth;
                }
            }

            setCameraPosition(x, y) {
                this.gameState.camera.targetX = x;
                this.gameState.camera.targetY = y;
            }

            setCameraZoom(zoom) {
                this.gameState.camera.zoom = Math.max(0.1, Math.min(5, zoom));
            }

            setCameraBounds(minX, maxX, minY, maxY) {
                this.gameState.camera.bounds = { minX, maxX, minY, maxY };
            }

            cameraShake(intensity, duration) {
                this.gameState.camera.shake = { intensity, duration, elapsed: 0 };
                this.gameState.camera.isShaking = true;
            }

            transitionCamera(toX, toY, duration, easing = 'linear') {
                this.gameState.camera.transition = {
                    fromX: this.gameState.camera.x,
                    fromY: this.gameState.camera.y,
                    toX, toY, duration, elapsed: 0, easing
                };
            }

            getCameraPosition() {
                return { x: this.gameState.camera.x, y: this.gameState.camera.y };
            }

            getCameraZoom() {
                return this.gameState.camera.zoom;
            }

            screenToWorld(screenX, screenY) {
                const rect = this.canvas.getBoundingClientRect();
                const aX = screenX - rect.left, aY = screenY - rect.top;
                const cam = this.gameState.camera;
                return {
                    x: (aX / cam.zoom) + cam.x - (this.canvas.width / 2),
                    y: (aY / cam.zoom) + cam.y - (this.canvas.height / 2)
                };
            }

            worldToScreen(worldX, worldY) {
                const cam = this.gameState.camera;
                return {
                    x: (worldX - cam.x) * cam.zoom + (this.canvas.width / 2),
                    y: (worldY - cam.y) * cam.zoom + (this.canvas.height / 2)
                };
            }

            pauseGame() {
                this.paused = true;
                EnhancedDebugConsole.log('‚è∏Ô∏è Game Paused');
            }

            resumeGame() {
                this.paused = false;
                EnhancedDebugConsole.log('‚ñ∂Ô∏è Game Resumed');
            }

            setTimeScale(scale) {
                this.timeScale = scale;
                EnhancedDebugConsole.log(`‚è±Ô∏è Time Scale: ${scale.toFixed(2)}`);
            }

            forEachWithTag(tag, callback) {
                this.entities.forEach(entity => {
                    if (entity.tags && entity.tags.includes(tag)) {
                        callback(entity);
                    }
                });
            }

            countWithTag(tag) {
                return this.entities.filter(e => e.tags && e.tags.includes(tag)).length;
            }

            destroyAllWithTag(tag) {
                this.entities = this.entities.filter(e => !(e.tags && e.tags.includes(tag)));
                EnhancedDebugConsole.log(`Destroyed all entities with tag '${tag}'`);
            }
        }



        // Asset Manager Functions
        const EnhancedAssetManager = {
            assets: {
                sprites: [],
                sounds: [],
                backgrounds: [],
                animations: []
            },
            currentType: 'sprites',
            backgroundAsset: null,

            init() {
                this.loadAssets();
                this.attachEvents();
                this.render();
                this.attachAnimationUpload();
            },

            loadAssets() {
                const saved = localStorage.getItem('lupiforge_assets');
                if (saved) {
                    const data = JSON.parse(saved);
                    this.assets = {
                        sprites: (data.assets && data.assets.sprites) || [],
                        sounds: (data.assets && data.assets.sounds) || [],
                        backgrounds: (data.assets && data.assets.backgrounds) || [],
                        animations: (data.assets && data.assets.animations) || []
                    };
                    this.backgroundAsset = data.backgroundAsset || null;
                }
            },

            saveAssets() {
                const assetsCopy = {
                    sprites: this.assets.sprites,
                    sounds: this.assets.sounds,
                    backgrounds: this.assets.backgrounds,
                    animations: this.assets.animations.map(anim => ({
                        ...anim,
                        spriteSheet: null
                    }))
                };
                
                try {
                    localStorage.setItem('lupiforge_assets', JSON.stringify({
                        assets: assetsCopy,
                        backgroundAsset: this.backgroundAsset
                    }));
                } catch (e) {
                    console.warn('Asset save to localStorage failed, using IndexedDB:', e.message);
                    this.saveAssetsToIndexedDB();
                }
                
                this.saveSpriteSheetsToDB();
            },
            
            saveAssetsToIndexedDB() {
                const request = indexedDB.open('lupiforge_db', 1);
                request.onupgradeneeded = (e) => {
                    const db = e.target.result;
                    if (!db.objectStoreNames.contains('assets')) {
                        db.createObjectStore('assets', { keyPath: 'id' });
                    }
                };
                request.onsuccess = (e) => {
                    const db = e.target.result;
                    const store = db.transaction('assets', 'readwrite').objectStore('assets');
                    store.put({ id: 'all', data: this.assets });
                };
            },
            
            saveSpriteSheetsToDB() {
                const request = indexedDB.open('lupiforge_db', 1);
                request.onupgradeneeded = (e) => {
                    const db = e.target.result;
                    if (!db.objectStoreNames.contains('spriteSheets')) {
                        db.createObjectStore('spriteSheets', { keyPath: 'id' });
                    }
                };
                request.onsuccess = (e) => {
                    const db = e.target.result;
                    const store = db.transaction('spriteSheets', 'readwrite').objectStore('spriteSheets');
                    this.assets.animations.forEach(anim => {
                        store.put({ id: anim.id, spriteSheet: anim.spriteSheet });
                    });
                };
            },
            
            loadSpriteSheetFromDB(animationId) {
                return new Promise((resolve) => {
                    const request = indexedDB.open('lupiforge_db', 1);
                    request.onsuccess = (e) => {
                        const db = e.target.result;
                        const store = db.transaction('spriteSheets', 'readonly').objectStore('spriteSheets');
                        const getRequest = store.get(animationId);
                        getRequest.onsuccess = () => {
                            resolve(getRequest.result ? getRequest.result.spriteSheet : null);
                        };
                    };
                });
            },

            attachAnimationUpload() {
                const input = document.getElementById('animationUpload');
                if (input) {
                    input.addEventListener('change', (e) => {
                        this.handleAnimationUpload(e.target.files[0]);
                        e.target.value = '';
                    });
                }
            },

            handleAnimationUpload(file) {
                if (!file) return;
                
                const reader = new FileReader();
                reader.onload = (e) => {
                    const img = new Image();
                    img.onload = () => {
                        this.showSpriteSheetConfig(file.name, e.target.result, img.width, img.height);
                    };
                    img.src = e.target.result;
                };
                reader.readAsDataURL(file);
            },

            showSpriteSheetConfig(filename, dataUrl, imgWidth, imgHeight) {
                const modal = document.createElement('div');
                modal.className = 'modal show';
                modal.style.zIndex = '10000';
                
                const scale = Math.min(400 / imgWidth, 400 / imgHeight);
                const displayWidth = imgWidth * scale;
                const displayHeight = imgHeight * scale;
                
                modal.innerHTML = `
                    <div class="modal-content" style="max-width: 900px; max-height: 90vh; overflow-y: auto;">
                        <h2>üé¨ Configure Sprite Sheet: ${filename}</h2>
                        
                        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin: 20px 0;">
                            <div>
                                <h4 style="color: #ccc; margin-bottom: 10px;">üìç Crop Animation Region</h4>
                                <p style="color: #aaa; font-size: 11px; margin-bottom: 10px;">Click and drag on the image to select crop area</p>
                                
                                <div style="position: relative; display: inline-block; background: #0f3460; padding: 5px; border-radius: 4px;">
                                    <canvas id="cropCanvas" style="border: 2px solid #533483; cursor: crosshair; display: block; background: white;"></canvas>
                                </div>
                                
                                <div style="margin-top: 10px; color: #ccc; font-size: 12px;">
                                    <p>Crop: <span id="cropInfo" style="color: #27ae60;">Select area</span></p>
                                </div>
                                
                                <div style="margin-top: 10px; display: flex; gap: 8px;">
                                    <button id="resetCropBtn" style="flex: 1; padding: 8px; background: #533483; color: white; border: none; border-radius: 4px; cursor: pointer;">Reset</button>
                                    <button id="useCropBtn" style="flex: 1; padding: 8px; background: #27ae60; color: white; border: none; border-radius: 4px; cursor: pointer;">Use Crop</button>
                                </div>
                                
                                <div id="cropPreview" style="margin-top: 10px; display: none;">
                                    <p style="color: #ccc; font-size: 11px; margin-bottom: 5px;">Preview:</p>
                                    <canvas id="previewCanvas" style="border: 1px solid #533483; border-radius: 4px; max-width: 100%; display: block; background: white;"></canvas>
                                </div>
                            </div>
                            
                            <div>
                                <h4 style="color: #ccc; margin-bottom: 10px;">‚öôÔ∏è Frame Configuration</h4>
                                
                                <label style="display: block; margin-bottom: 15px; color: #ccc;">
                                    <div style="font-size: 12px; margin-bottom: 5px;">Animation Name</div>
                                    <input type="text" id="animName" placeholder="e.g., walk, jump, idle" style="width: 100%; padding: 8px; border: 1px solid #533483; border-radius: 4px; background: #0f3460; color: white; box-sizing: border-box;" autocomplete="off">
                                    <small style="color: #aaa; font-size: 10px; margin-top: 3px; display: block;">Letters, numbers, spaces, and underscores</small>
                                </label>
                                
                                <label style="display: block; margin-bottom: 15px; color: #ccc;">
                                    <div style="font-size: 12px; margin-bottom: 5px;">Frames Per Row</div>
                                    <input type="number" id="framesPerRow" value="4" min="1" style="width: 100%; padding: 8px; border: 1px solid #533483; border-radius: 4px; background: #0f3460; color: white; box-sizing: border-box;">
                                </label>
                                
                                <label style="display: block; margin-bottom: 15px; color: #ccc;">
                                    <div style="font-size: 12px; margin-bottom: 5px;">Total Frames</div>
                                    <input type="number" id="totalFrames" value="8" min="1" style="width: 100%; padding: 8px; border: 1px solid #533483; border-radius: 4px; background: #0f3460; color: white; box-sizing: border-box;">
                                </label>
                                
                                <label style="display: block; margin-bottom: 15px; color: #ccc;">
                                    <div style="font-size: 12px; margin-bottom: 5px;">Frame Duration (ms)</div>
                                    <input type="number" id="frameDuration" value="100" min="10" step="10" style="width: 100%; padding: 8px; border: 1px solid #533483; border-radius: 4px; background: #0f3460; color: white; box-sizing: border-box;">
                                </label>
                                
                                <label style="display: flex; align-items: center; gap: 10px; color: #ccc; margin-bottom: 15px;">
                                    <input type="checkbox" id="autoTag">
                                    <span style="font-size: 12px;">Tag entities with animation name</span>
                                </label>
                                
                                <div style="padding: 10px; background: #0f3460; border-radius: 4px; border-left: 3px solid #533483;">
                                    <p style="color: #aaa; font-size: 11px; margin: 0;">üí° Tip: Use the crop tool to select just the animation row you want (e.g., WALK row).</p>
                                </div>
                            </div>
                        </div>
                        
                        <div class="modal-buttons">
                            <button onclick="this.closest('.modal').remove()" style="background: #95a5a6;">Cancel</button>
                            <button id="createAnimBtn" style="background: #27ae60; cursor: pointer;">Create Animation</button>
                        </div>
                    </div>
                `;
                
                document.body.appendChild(modal);
                
                const cropCanvas = modal.querySelector('#cropCanvas');
                const previewCanvas = modal.querySelector('#previewCanvas');
                const ctx = cropCanvas.getContext('2d');
                const previewCtx = previewCanvas.getContext('2d');
                
                let img = new Image();
                img.onload = () => {
                    cropCanvas.width = displayWidth;
                    cropCanvas.height = displayHeight;
                    ctx.drawImage(img, 0, 0, displayWidth, displayHeight);
                };
                img.src = dataUrl;
                
                let cropRect = { x: 0, y: 0, w: displayWidth, h: displayHeight / 4, isDragging: false, resizeHandle: null };
                
                const drawCropOverlay = () => {
                    ctx.drawImage(img, 0, 0, displayWidth, displayHeight);
                    ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
                    ctx.fillRect(0, 0, displayWidth, cropRect.y);
                    ctx.fillRect(0, cropRect.y + cropRect.h, displayWidth, displayHeight - (cropRect.y + cropRect.h));
                    ctx.fillRect(0, cropRect.y, cropRect.x, cropRect.h);
                    ctx.fillRect(cropRect.x + cropRect.w, cropRect.y, displayWidth - (cropRect.x + cropRect.w), cropRect.h);
                    
                    ctx.strokeStyle = '#27ae60';
                    ctx.lineWidth = 2;
                    ctx.strokeRect(cropRect.x, cropRect.y, cropRect.w, cropRect.h);
                    
                    ctx.fillStyle = '#27ae60';
                    const handles = [
                        {x: cropRect.x - 5, y: cropRect.y - 5, id: 'tl'},
                        {x: cropRect.x + cropRect.w - 5, y: cropRect.y - 5, id: 'tr'},
                        {x: cropRect.x - 5, y: cropRect.y + cropRect.h - 5, id: 'bl'},
                        {x: cropRect.x + cropRect.w - 5, y: cropRect.y + cropRect.h - 5, id: 'br'}
                    ];
                    handles.forEach(h => ctx.fillRect(h.x, h.y, 10, 10));
                    
                    const cropW = (cropRect.w / displayWidth) * imgWidth;
                    const cropH = (cropRect.h / displayHeight) * imgHeight;
                    modal.querySelector('#cropInfo').textContent = `${Math.round(cropW)} √ó ${Math.round(cropH)}px`;
                };
                
                cropCanvas.addEventListener('mousedown', (e) => {
                    const rect = cropCanvas.getBoundingClientRect();
                    const x = e.clientX - rect.left;
                    const y = e.clientY - rect.top;
                    
                    cropRect.isDragging = true;
                    cropRect.startX = x;
                    cropRect.startY = y;
                });
                
                cropCanvas.addEventListener('mousemove', (e) => {
                    if (!cropRect.isDragging) return;
                    
                    const rect = cropCanvas.getBoundingClientRect();
                    const x = e.clientX - rect.left;
                    const y = e.clientY - rect.top;
                    
                    cropRect.x = Math.max(0, Math.min(x, cropRect.startX));
                    cropRect.y = Math.max(0, Math.min(y, cropRect.startY));
                    cropRect.w = Math.abs(x - cropRect.startX);
                    cropRect.h = Math.abs(y - cropRect.startY);
                    
                    drawCropOverlay();
                });
                
                cropCanvas.addEventListener('mouseup', () => {
                    cropRect.isDragging = false;
                });
                
                drawCropOverlay();
                
                let croppedDataUrl = null;
                let croppedWidth = imgWidth;
                let croppedHeight = imgHeight;
                
                modal.querySelector('#resetCropBtn').addEventListener('click', () => {
                    cropRect = { x: 0, y: 0, w: displayWidth, h: displayHeight / 4, isDragging: false };
                    croppedDataUrl = null;
                    modal.querySelector('#cropPreview').style.display = 'none';
                    drawCropOverlay();
                });
                
                modal.querySelector('#useCropBtn').addEventListener('click', () => {
                    const scaleX = imgWidth / displayWidth;
                    const scaleY = imgHeight / displayHeight;
                    
                    const origX = cropRect.x * scaleX;
                    const origY = cropRect.y * scaleY;
                    const origW = cropRect.w * scaleX;
                    const origH = cropRect.h * scaleY;
                    
                    const tempCanvas = document.createElement('canvas');
                    tempCanvas.width = origW;
                    tempCanvas.height = origH;
                    const tempCtx = tempCanvas.getContext('2d');
                    
                    const tempImg = new Image();
                    tempImg.onload = () => {
                        tempCtx.drawImage(tempImg, -origX, -origY);
                        croppedDataUrl = tempCanvas.toDataURL();
                        croppedWidth = origW;
                        croppedHeight = origH;
                        
                        previewCanvas.width = origW;
                        previewCanvas.height = origH;
                        previewCtx.drawImage(tempImg, -origX, -origY);
                        
                        modal.querySelector('#cropPreview').style.display = 'block';
                        
                        modal.querySelector('#framesPerRow').addEventListener('change', updateFramePreview);
                        modal.querySelector('#totalFrames').addEventListener('change', updateFramePreview);
                        
                        const updateFramePreview = () => {
                            const fpr = parseInt(modal.querySelector('#framesPerRow').value) || 1;
                            const tf = parseInt(modal.querySelector('#totalFrames').value) || 1;
                            const frameW = origW / fpr;
                            const frameH = origH / Math.ceil(tf / fpr);
                            
                            previewCanvas.width = frameW;
                            previewCanvas.height = frameH;
                            previewCtx.drawImage(tempImg, -origX, -origY);
                        };
                    };
                    tempImg.src = dataUrl;
                });
                
                modal.querySelector('#animName').addEventListener('input', (e) => {
                    e.target.value = e.target.value.replace(/[^a-zA-Z0-9\s_]/g, '');
                });
                
                const self = this;
                modal.querySelector('#createAnimBtn').addEventListener('click', () => {
                    try {
                        const inputName = modal.querySelector('#animName').value.trim();
                        const name = inputName || filename.split('.')[0];
                        const framesPerRow = parseInt(modal.querySelector('#framesPerRow').value);
                        const totalFrames = parseInt(modal.querySelector('#totalFrames').value);
                        const frameDuration = parseInt(modal.querySelector('#frameDuration').value);
                        const autoTag = modal.querySelector('#autoTag').checked;
                        
                        if (inputName && !/^[a-zA-Z0-9\s_]+$/.test(name)) {
                            alert('Animation name can only contain letters, numbers, spaces, and underscores');
                            return;
                        }
                        
                        if (framesPerRow < 1 || totalFrames < 1 || frameDuration < 10) {
                            alert('Invalid frame settings. Check values are within allowed ranges.');
                            return;
                        }
                        
                        const finalDataUrl = croppedDataUrl || dataUrl;
                        const finalWidth = croppedDataUrl ? croppedWidth : imgWidth;
                        const finalHeight = croppedDataUrl ? croppedHeight : imgHeight;
                        
                        const frameW = Math.round(finalWidth / framesPerRow);
                        const frameH = Math.round(finalHeight / Math.ceil(totalFrames / framesPerRow));
                        
                        const detectFrameOffsets = (spriteDataUrl, fpr, tf, fw, fh) => {
                            return new Promise((resolve) => {
                                const img = new Image();
                                img.onload = () => {
                                    const canvas = document.createElement('canvas');
                                    const ctx = canvas.getContext('2d');
                                    canvas.width = fw;
                                    canvas.height = fh;
                                    
                                    const offsets = [];
                                    
                                    for (let frameIdx = 0; frameIdx < tf; frameIdx++) {
                                        const col = frameIdx % fpr;
                                        const row = Math.floor(frameIdx / fpr);
                                        const srcX = col * fw;
                                        const srcY = row * fh;
                                        
                                        ctx.clearRect(0, 0, fw, fh);
                                        ctx.drawImage(img, -srcX, -srcY);
                                        
                                        const imageData = ctx.getImageData(0, 0, fw, fh);
                                        const data = imageData.data;
                                        
                                        let minX = fw, maxX = 0, minY = fh, maxY = 0;
                                        let hasPixels = false;
                                        
                                        for (let i = 3; i < data.length; i += 4) {
                                            if (data[i] > 128) {
                                                hasPixels = true;
                                                const pixelIndex = (i - 3) / 4;
                                                const x = pixelIndex % fw;
                                                const y = Math.floor(pixelIndex / fw);
                                                minX = Math.min(minX, x);
                                                maxX = Math.max(maxX, x);
                                                minY = Math.min(minY, y);
                                                maxY = Math.max(maxY, y);
                                            }
                                        }
                                        
                                        if (hasPixels) {
                                            const centerX = (minX + maxX) / 2;
                                            const bottomY = maxY;
                                            offsets.push({ 
                                                centerX: Math.round(centerX), 
                                                bottomY: Math.round(bottomY) 
                                            });
                                        } else {
                                            offsets.push({ centerX: fw / 2, bottomY: fh });
                                        }
                                    }
                                    
                                    resolve(offsets);
                                };
                                img.src = spriteDataUrl;
                            });
                        };
                        
                        detectFrameOffsets(finalDataUrl, framesPerRow, totalFrames, frameW, frameH).then(offsets => {
                            const animation = {
                                id: Date.now() + Math.random(),
                                name: name,
                                filename: filename,
                                spriteSheet: finalDataUrl,
                                width: Math.round(finalWidth),
                                height: Math.round(finalHeight),
                                framesPerRow: framesPerRow,
                                totalFrames: totalFrames,
                                frameDuration: frameDuration,
                                frameWidth: frameW,
                                frameHeight: frameH,
                                frameOffsets: offsets,
                                tags: autoTag ? [name.toLowerCase()] : [],
                                createdAt: new Date().toISOString()
                            };
                            
                            self.assets.animations.push(animation);
                            self.saveAssets();
                            self.currentType = 'animations';
                            self.render();
                            modal.remove();
                            
                            showToast(`üé¨ Animation "${name}" created with anchor points!`);
                            
                            if (window.AnimationManager) {
                                AnimationManager.addAnimation(animation);
                            }
                            
                            if (window.AssetTagSystem) {
                                AssetTagSystem.updateBlocklyDropdowns();
                            }
                            
                            setTimeout(() => self.showFirstFrameTagging(animation, finalDataUrl, frameW, frameH), 500);
                        });
                    } catch (error) {
                        console.error('Error creating animation:', error);
                        alert('Error creating animation: ' + error.message);
                    }
                });
            },

            showFirstFrameTagging(animation, spriteDataUrl, frameW, frameH) {
                const self = this;
                const modal = document.createElement('div');
                modal.className = 'modal show';
                modal.style.zIndex = '10000';
                modal.innerHTML = `
                    <div class="modal-content" style="max-width: 600px;">
                        <h2>üé¨ ${animation.name} - Tag Preview Frame</h2>
                        <p style="color: #bbb; font-size: 12px; margin-bottom: 15px;">Your first frame has been extracted. Tag it to use as a sprite in your game.</p>
                        
                        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin: 20px 0;">
                            <div style="text-align: center;">
                                <h4 style="color: #ccc; margin-bottom: 10px;">Preview</h4>
                                <canvas id="framePreviewCanvas" width="200" height="200" style="background: #0f3460; border: 1px solid #533483; border-radius: 4px; display: block; margin: 0 auto;"></canvas>
                            </div>
                            
                            <div>
                                <h4 style="color: #ccc; margin-bottom: 10px;">Add Tag</h4>
                                <div style="display: flex; flex-direction: column; gap: 10px;">
                                    <input type="text" id="frameTag" placeholder="e.g., walk_idle" style="width: 100%; padding: 8px; border: 1px solid #533483; border-radius: 4px; background: #0f3460; color: white; box-sizing: border-box;" autocomplete="off">
                                    <div id="suggestedTags" style="display: flex; flex-wrap: wrap; gap: 6px;"></div>
                                    <small style="color: #aaa; font-size: 11px;">Letters, numbers, spaces, hyphens, and underscores allowed</small>
                                </div>
                            </div>
                        </div>
                        
                        <div class="modal-buttons">
                            <button onclick="this.closest('.modal').remove()" style="background: #95a5a6;">Skip</button>
                            <button id="createSpriteBtn" style="background: #27ae60; cursor: pointer;">‚úì Create Sprite</button>
                        </div>
                    </div>
                `;
                
                document.body.appendChild(modal);
                
                const previewCanvas = modal.querySelector('#framePreviewCanvas');
                const previewCtx = previewCanvas.getContext('2d');
                
                const img = new Image();
                img.onload = () => {
                    previewCtx.drawImage(img, 0, 0, frameW, frameH, 0, 0, previewCanvas.width, previewCanvas.height);
                };
                img.src = spriteDataUrl;
                
                const suggestedTags = [animation.name, animation.name + '_idle', 'player', 'enemy', 'sprite'];
                modal.querySelector('#suggestedTags').innerHTML = suggestedTags.map(tag => 
                    `<button class="tag-suggestion" data-tag="${tag}" style="background: #533483; padding: 4px 10px; border: 1px solid #7d4fa1; border-radius: 3px; color: white; cursor: pointer; font-size: 11px;">${tag}</button>`
                ).join('');
                
                modal.querySelectorAll('.tag-suggestion').forEach(btn => {
                    btn.addEventListener('click', () => {
                        modal.querySelector('#frameTag').value = btn.dataset.tag;
                    });
                });
                
                modal.querySelector('#frameTag').addEventListener('input', (e) => {
                    e.target.value = e.target.value.replace(/[^a-zA-Z0-9\s\-_]/g, '');
                });
                
                modal.querySelector('#createSpriteBtn').addEventListener('click', () => {
                    const tag = modal.querySelector('#frameTag').value.trim();
                    if (!tag) {
                        alert('Please enter or select a tag');
                        return;
                    }
                    
                    if (!/^[a-zA-Z0-9\s\-_]+$/.test(tag)) {
                        alert('Tag can only contain letters, numbers, spaces, hyphens, and underscores');
                        return;
                    }
                    
                    const tempCanvas = document.createElement('canvas');
                    tempCanvas.width = frameW;
                    tempCanvas.height = frameH;
                    const tempCtx = tempCanvas.getContext('2d');
                    
                    const tempImg = new Image();
                    tempImg.onload = () => {
                        tempCtx.drawImage(tempImg, 0, 0, frameW, frameH, 0, 0, frameW, frameH);
                        const firstFrameDataUrl = tempCanvas.toDataURL();
                        
                        const sprite = {
                            id: Date.now() + Math.random(),
                            name: animation.name + '_sprite',
                            type: 'sprites',
                            data: firstFrameDataUrl,
                            size: firstFrameDataUrl.length,
                            uploadedAt: new Date().toISOString(),
                            isBackground: false,
                            tags: [tag],
                            keyframes: []
                        };
                        
                        self.assets.sprites.push(sprite);
                        self.saveAssets();
                        self.render();
                        modal.remove();
                        
                        showToast(`‚ú® Sprite "${animation.name}_sprite" created with tag "${tag}"`);
                        AssetTagSystem.updateBlocklyDropdowns();
                    };
                    tempImg.src = spriteDataUrl;
                });
            },

            attachEvents() {
                document.getElementById('toggleAssets').addEventListener('click', () => {
                    const panel = document.getElementById('assetPanel');
                    const isCollapsed = panel.classList.toggle('collapsed');
                    document.getElementById('toggleAssets').textContent = isCollapsed ? '‚óÄ' : '‚ñº';
                });

                document.querySelectorAll('.asset-tab').forEach(tab => {
                    tab.addEventListener('click', (e) => {
                        document.querySelectorAll('.asset-tab').forEach(t => t.classList.remove('active'));
                        e.target.classList.add('active');
                        this.currentType = e.target.dataset.type;
                        this.render();
                    });
                });

                document.getElementById('assetUpload').addEventListener('change', (e) => {
                    this.handleUpload(e.target.files);
                });
            },

            handleUpload(files) {
                Array.from(files).forEach(file => {
                    const isImage = file.type.startsWith('image/');
                    const isAudio = file.type.startsWith('audio/');
                    
                    const showTypeSelector = (callback) => {
                        const modal = document.createElement('div');
                        modal.className = 'modal show';
                        modal.style.zIndex = '10001';
                        modal.innerHTML = `
                            <div class="modal-content" style="max-width: 400px;">
                                <h2>üì¶ Asset Type</h2>
                                <p style="color: #bbb; font-size: 12px; margin-bottom: 20px;">Choose where to organize this asset</p>
                                <div style="display: flex; flex-direction: column; gap: 10px;">
                                    ${isImage ? `
                                        <button class="asset-type-btn" data-type="backgrounds" style="padding: 15px; background: #533483; border: 1px solid #7d4fa1; border-radius: 4px; color: white; cursor: pointer; font-weight: bold;">üèûÔ∏è Background/Scene Image</button>
                                    ` : ''}
                                    ${isAudio ? `
                                        <button class="asset-type-btn" data-type="sounds" style="padding: 15px; background: #533483; border: 1px solid #7d4fa1; border-radius: 4px; color: white; cursor: pointer; font-weight: bold;">üîä Sound Effect/Music</button>
                                    ` : ''}
                                </div>
                                <button onclick="this.closest('.modal').remove()" style="width: 100%; margin-top: 15px; padding: 10px; background: #95a5a6; border: none; border-radius: 4px; color: white; cursor: pointer;">Cancel</button>
                            </div>
                        `;
                        document.body.appendChild(modal);
                        
                        modal.querySelectorAll('.asset-type-btn').forEach(btn => {
                            btn.addEventListener('click', () => {
                                const type = btn.dataset.type;
                                modal.remove();
                                callback(type);
                            });
                        });
                    };
                    
                    const reader = new FileReader();
                    reader.onload = (e) => {
                        const determineType = (selectedType) => {
                            const asset = {
                                id: Date.now() + Math.random(),
                                name: file.name,
                                type: selectedType,
                                data: e.target.result,
                                size: file.size,
                                uploadedAt: new Date().toISOString(),
                                isBackground: selectedType === 'backgrounds',
                                tags: [],
                                keyframes: []
                            };

                            if (asset.type === 'sprites' || asset.type === 'sounds') {
                                this.showTaggingModal(asset, () => {
                                    this.assets[asset.type].push(asset);
                                    this.saveAssets();
                                    this.render();
                                    showToast(`‚úÖ ${asset.name} added to ${asset.type}`);
                                    AchievementManager.check('asset_upload');
                                    AssetTagSystem.updateBlocklyDropdowns();
                                });
                            } else {
                                this.assets[asset.type].push(asset);
                                this.saveAssets();
                                this.render();
                                showToast(`‚úÖ ${file.name} added to backgrounds`);
                                AchievementManager.check('asset_upload');
                            }
                        };
                        
                        showTypeSelector(determineType);
                    };
                    reader.readAsDataURL(file);
                });
            },

            showTaggingModal(asset, onConfirm) {
                const PREDEFINED_TAGS = ['enemy', 'player', 'projectile', 'obstacle', 'collectible', 'hazard', 'npc', 'boss'];
                
                const modal = document.createElement('div');
                modal.className = 'modal show';
                modal.style.zIndex = '10000';
                
                const tagButtonsHtml = PREDEFINED_TAGS.map(tag => 
                    `<button class="tag-button" data-tag="${tag}">${tag}</button>`
                ).join('');
                
                modal.innerHTML = `
                    <div class="modal-content" style="max-width: 600px;">
                        <h2>üè∑Ô∏è Tag: ${asset.name}</h2>
                        <p style="color: #bbb; font-size: 12px;">Select predefined tags or create custom ones</p>
                        
                        <div style="margin: 20px 0;">
                            <h4 style="color: #ccc; margin-bottom: 10px;">Suggested Tags</h4>
                            <div style="display: flex; flex-wrap: wrap; gap: 8px; margin-bottom: 20px;">
                                ${tagButtonsHtml}
                            </div>
                            
                            <h4 style="color: #ccc; margin-bottom: 10px;">Custom Tag Input</h4>
                            <div style="display: flex; gap: 8px;">
                                <input type="text" id="customTagInput" placeholder="Enter custom tag..." 
                                    style="flex: 1; padding: 8px; border: 1px solid #533483; border-radius: 4px; background: #0f3460; color: white;">
                                <button id="addCustomTagBtn" style="padding: 8px 15px; background: #533483; color: white; border: none; border-radius: 4px; cursor: pointer;">Add</button>
                            </div>
                        </div>
                        
                        <div style="margin: 20px 0;">
                            <h4 style="color: #ccc; margin-bottom: 10px;">Selected Tags</h4>
                            <div id="selectedTagsContainer" style="display: flex; flex-wrap: wrap; gap: 8px; min-height: 32px; padding: 10px; background: #0f3460; border-radius: 4px;">
                                <span style="color: #888; font-style: italic;">No tags selected</span>
                            </div>
                        </div>
                        
                        <div class="modal-buttons">
                            <button onclick="this.closest('.modal').remove()" style="background: #95a5a6;">Cancel</button>
                            <button id="confirmTagsBtn" style="background: #27ae60; cursor: pointer;">Confirm Tags</button>
                        </div>
                    </div>
                `;
                
                document.body.appendChild(modal);
                
                const selectedTags = [];
                const selectedTagsContainer = modal.querySelector('#selectedTagsContainer');
                const customTagInput = modal.querySelector('#customTagInput');
                
                const updateTagsDisplay = () => {
                    if (selectedTags.length === 0) {
                        selectedTagsContainer.innerHTML = '<span style="color: #888; font-style: italic;">No tags selected</span>';
                    } else {
                        selectedTagsContainer.innerHTML = selectedTags.map(tag => 
                            `<span style="background: #533483; padding: 4px 10px; border-radius: 12px; font-size: 12px; display: flex; align-items: center; gap: 6px;">
                                ${tag}
                                <button data-remove-tag="${tag}" style="background: none; border: none; color: #ff6b6b; cursor: pointer; font-weight: bold; padding: 0;">√ó</button>
                            </span>`
                        ).join('');
                        
                        modal.querySelectorAll('[data-remove-tag]').forEach(btn => {
                            btn.addEventListener('click', (e) => {
                                e.stopPropagation();
                                const tag = btn.dataset.removeTag;
                                selectedTags.splice(selectedTags.indexOf(tag), 1);
                                updateTagsDisplay();
                            });
                        });
                    }
                };
                
                modal.querySelectorAll('.tag-button').forEach(btn => {
                    btn.addEventListener('click', () => {
                        const tag = btn.dataset.tag;
                        if (!selectedTags.includes(tag)) {
                            selectedTags.push(tag);
                            updateTagsDisplay();
                        }
                    });
                });
                
                modal.querySelector('#addCustomTagBtn').addEventListener('click', () => {
                    const tag = customTagInput.value.trim().toLowerCase();
                    if (tag && !selectedTags.includes(tag)) {
                        selectedTags.push(tag);
                        customTagInput.value = '';
                        updateTagsDisplay();
                    }
                });
                
                customTagInput.addEventListener('keypress', (e) => {
                    if (e.key === 'Enter') {
                        modal.querySelector('#addCustomTagBtn').click();
                    }
                });
                
                modal.querySelector('#confirmTagsBtn').addEventListener('click', () => {
                    asset.tags = selectedTags;
                    modal.remove();
                    onConfirm();
                });
            },

            setAsBackground(assetId) {
                let asset = null;
                for (let type in this.assets) {
                    asset = this.assets[type].find(a => a.id === assetId);
                    if (asset) break;
                }

                if (asset && asset.type !== 'sounds') {
                    if (this.backgroundAsset) {
                        this.backgroundAsset.isBackground = false;
                    }
                    
                    asset.isBackground = true;
                    this.backgroundAsset = asset;
                    this.saveAssets();
                    this.render();
                    showToast(`üñºÔ∏è Set ${asset.name} as background`);
                    this.applyBackgroundToPreview();
                }
            },

            applyBackgroundToPreview() {
                if (this.backgroundAsset && this.backgroundAsset.data) {
                    const canvas = document.getElementById('gameCanvas');
                    const ctx = canvas.getContext('2d');
                    const img = new Image();
                    img.onload = () => {
                        window.gameBackgroundImage = img;
                    };
                    img.src = this.backgroundAsset.data;
                }
            },

            deleteAsset(id, type) {
                if (confirm('Delete this asset?')) {
                    const asset = this.assets[type].find(a => a.id === id);
                    if (asset && asset.isBackground) {
                        this.backgroundAsset = null;
                    }
                    this.assets[type] = this.assets[type].filter(a => a.id !== id);
                    this.saveAssets();
                    this.render();
                    showToast('üóëÔ∏è Asset deleted');
                }
            },

            showPreview(asset) {
                const modal = document.createElement('div');
                modal.className = 'modal show';
                modal.innerHTML = `
                    <div class="modal-content">
                        <h2>Preview: ${asset.name}</h2>
                        <div style="text-align: center; padding: 20px;">
                            ${asset.type !== 'sounds' ? 
                                `<img src="${asset.data}" style="max-width: 100%; max-height: 400px; border-radius: 5px;">` :
                                `<audio controls src="${asset.data}" style="width: 100%;"></audio>`
                            }
                        </div>
                        <div class="modal-buttons">
                            <button onclick="this.closest('.modal').remove()" style="background: #95a5a6;">Close</button>
                            ${asset.type !== 'sounds' ? 
                                `<button onclick="AssetManager.setAsBackground(${asset.id}); this.closest('.modal').remove();" style="background: #3498db;">Set as Background</button>` :
                                ''
                            }
                        </div>
                    </div>
                `;
                document.body.appendChild(modal);
            },

            render() {
                const grid = document.getElementById('assetGrid');
                const assets = this.assets[this.currentType];

                if (assets.length === 0) {
                    grid.innerHTML = '<p style="color: #95a5a6; text-align: center; padding: 20px; grid-column: 1/-1;">No assets yet. Upload some!</p>';
                    return;
                }

                grid.innerHTML = assets.map(asset => {
                    const tagsHtml = asset.tags && asset.tags.length > 0 
                        ? `<div style="font-size: 10px; color: #bbb; margin-top: 4px; display: flex; flex-wrap: wrap; gap: 2px;">
                            ${asset.tags.map(tag => `<span style="background: #533483; padding: 2px 6px; border-radius: 3px; font-weight: 500;">üè∑Ô∏è${tag}</span>`).join('')}
                           </div>`
                        : '';
                    
                    if (this.currentType === 'animations') {
                        return `
                            <div class="asset-item" data-id="${asset.id}" style="cursor: pointer; position: relative;">
                                <canvas id="preview-${asset.id}" class="asset-preview" width="64" height="64" style="background: #0f3460; border-radius: 4px;"></canvas>
                                <div class="asset-name">${asset.name}</div>
                                <div style="font-size: 9px; color: #888;">${asset.totalFrames} frames @ ${asset.frameDuration}ms</div>
                                ${tagsHtml}
                                <button class="asset-delete" onclick="AssetManager.deleteAsset(${asset.id}, '${this.currentType}')">√ó</button>
                            </div>
                        `;
                    }
                    
                    return `
                        <div class="asset-item" data-id="${asset.id}" style="${asset.isBackground ? 'border: 2px solid #3498db;' : ''}">
                            ${asset.type !== 'sounds' ? 
                                `<img src="${asset.data}" class="asset-preview" alt="${asset.name}">` :
                                `<div class="asset-preview" style="display: flex; align-items: center; justify-content: center; color: white; font-size: 24px;">üîä</div>`
                            }
                            <div class="asset-name">${asset.name}${asset.isBackground ? ' üñºÔ∏è' : ''}</div>
                            ${tagsHtml}
                            <button class="asset-delete" onclick="AssetManager.deleteAsset(${asset.id}, '${this.currentType}')">√ó</button>
                        </div>
                    `;
                }).join('');

                if (this.currentType === 'animations') {
                    assets.forEach(animation => {
                        const canvas = document.getElementById(`preview-${animation.id}`);
                        if (canvas && window.AnimationPreviewRenderer) {
                            try {
                                AnimationPreviewRenderer.renderFrame(canvas, animation, 0);
                            } catch (e) {
                                console.warn('Could not render animation preview:', e);
                            }
                        }
                    });
                }

                grid.querySelectorAll('.asset-item').forEach(item => {
                    item.addEventListener('click', (e) => {
                        if (!e.target.classList.contains('asset-delete')) {
                            const id = parseFloat(item.dataset.id);
                            const asset = assets.find(a => a.id === id);
                            if (this.currentType === 'animations') {
                                AnimationManager.showAnimationEditor(asset);
                            } else {
                                this.showPreview(asset);
                            }
                        }
                    });
                });
            }
        };

        // === SNIPPET 7: Dynamic Asset Tag System ===
        class AssetTaggingSystem {
            constructor(workspace, assetManager) {
                this.workspace = workspace;
                this.assetManager = assetManager;
                this.tagMap = {};
                this.tagSuggestions = ['player', 'enemy', 'obstacle', 'collectible', 'projectile', 'npc', 'boss', 'interactive', 'background'];
                this.tagColorMap = {
                    player: '#3498db',
                    enemy: '#e74c3c',
                    obstacle: '#95a5a6',
                    collectible: '#2ecc71',
                    projectile: '#f39c12',
                    npc: '#9b59b6',
                    boss: '#8e44ad',
                    interactive: '#1abc9c',
                    background: '#34495e'
                };
                this.eventListeners = {};
                this.loadTagData();
                this.setupEventListeners();
                this.registerTagBlocks();
                this.updateAllBlockDropdowns();
            }

            loadTagData() {
                try {
                    const savedTags = localStorage.getItem('lupiforge_asset_tags');
                    if (savedTags) {
                        this.tagMap = JSON.parse(savedTags);
                    }
                } catch (error) {
                    console.warn('Failed to load asset tags:', error);
                    this.tagMap = {};
                }
            }

            saveTagData() {
                try {
                    localStorage.setItem('lupiforge_asset_tags', JSON.stringify(this.tagMap));
                } catch (error) {
                    console.error('Failed to save asset tags:', error);
                }
            }

            setupEventListeners() {
                if (this.assetManager && this.assetManager.on) {
                    this.assetManager.on('assetUploaded', (asset) => {
                        this.showTaggingDialog(asset);
                    });
                }
                
                if (this.workspace && this.workspace.addChangeListener) {
                    this.workspace.addChangeListener((event) => {
                        if (event && (event.type === Blockly.Events.CREATE || event.type === Blockly.Events.DELETE)) {
                            this.updateAllBlockDropdowns();
                        }
                    });
                }
            }

            registerTagBlocks() {
                if (typeof registerBlock === 'undefined') {
                    console.warn('registerBlock not available');
                    return;
                }

                registerBlock({
                    id: "tag_asset",
                    category: "Assets",
                    label: "Tag Asset [ASSET] with [TAG]",
                    inputs: {
                        ASSET: { type: "asset", options: this.getAssetOptions() },
                        TAG: { type: "string", suggestions: this.tagSuggestions }
                    },
                    output: null,
                    compile: (node) => {
                        return { 
                            type: "TagAsset", 
                            properties: {
                                assetId: node.inputs.ASSET,
                                tag: node.inputs.TAG
                            }
                        };
                    }
                });

                registerBlock({
                    id: "get_assets_by_tag",
                    category: "Assets",
                    label: "Get Assets with Tag [TAG]",
                    inputs: {
                        TAG: { type: "string", suggestions: this.tagSuggestions }
                    },
                    output: "array",
                    compile: (node) => {
                        return { 
                            type: "GetAssetsByTag", 
                            properties: {
                                tag: node.inputs.TAG
                            }
                        };
                    }
                });

                registerBlock({
                    id: "asset_has_tag",
                    category: "Assets",
                    label: "Asset [ASSET] has Tag [TAG]?",
                    inputs: {
                        ASSET: { type: "asset", options: this.getAssetOptions() },
                        TAG: { type: "string", suggestions: this.tagSuggestions }
                    },
                    output: "boolean",
                    compile: (node) => {
                        return { 
                            type: "AssetHasTag", 
                            properties: {
                                assetId: node.inputs.ASSET,
                                tag: node.inputs.TAG
                            }
                        };
                    }
                });
            }

            tagAsset(assetId, tag) {
                if (!this.tagMap[assetId]) {
                    this.tagMap[assetId] = [];
                }
                
                if (!this.tagMap[assetId].includes(tag)) {
                    this.tagMap[assetId].push(tag);
                    this.saveTagData();
                    
                    if (!this.tagSuggestions.includes(tag)) {
                        this.tagSuggestions.push(tag);
                    }
                    
                    this.updateAllBlockDropdowns();
                    this.emitTagEvent('assetTagged', { assetId, tag });
                }
            }

            untagAsset(assetId, tag) {
                if (this.tagMap[assetId]) {
                    this.tagMap[assetId] = this.tagMap[assetId].filter(t => t !== tag);
                    this.saveTagData();
                    this.updateAllBlockDropdowns();
                    this.emitTagEvent('assetUntagged', { assetId, tag });
                }
            }

            getAssetsByTag(tag) {
                const results = [];
                Object.values(this.tagMap).forEach(tags => {
                    if (tags.includes(tag)) {
                        // Return asset references from AssetManager
                        const assetId = Object.keys(this.tagMap).find(id => this.tagMap[id] === tags);
                        if (assetId && this.assetManager && typeof this.assetManager.getAssetById === 'function') {
                            const asset = this.assetManager.getAssetById(assetId);
                            if (asset) results.push(asset);
                        }
                    }
                });
                return results;
            }

            getAssetTags(assetId) {
                return this.tagMap[assetId] || [];
            }

            getAllTags() {
                const allTags = new Set();
                Object.values(this.tagMap).forEach(tags => {
                    tags.forEach(tag => allTags.add(tag));
                });
                return Array.from(allTags);
            }

            getAssetNames() {
                return this.assetManager?.assets?.sprites?.map(s => s.name) || [];
            }

            getAssetOptions() {
                const tags = this.getAllTags();
                const options = [["-- Select --", ""]];
                
                // Tags (no HEADER)
                tags.forEach(tag => {
                    options.push([`üè∑Ô∏è ${tag}`, `tag:${tag}`]);
                });
                
                return options;
            }
            
            getAssetDropdownOptions() {
                const tags = this.getAllTags();
                const names = this.getAssetNames();
                const options = [["-- Select Asset --", ""]];
                
                // Add tags as real options (not headers)
                if (tags.length > 0) {
                    tags.forEach(tag => {
                        options.push([`üè∑Ô∏è ${tag}`, `tag:${tag}`]);
                    });
                }
                
                // Add names as real options (not headers)
                if (names.length > 0) {
                    names.forEach(name => {
                        options.push([`üì¶ ${name}`, name.toLowerCase()]);
                    });
                }
                
                return options;
            }

            showTaggingDialog(asset) {
                const modal = document.createElement('div');
                modal.className = 'asset-tagging-modal';
                modal.style.cssText = `
                    position: fixed;
                    top: 50%;
                    left: 50%;
                    transform: translate(-50%, -50%);
                    background: #16213e;
                    padding: 25px;
                    border-radius: 10px;
                    box-shadow: 0 5px 30px rgba(0,0,0,0.5);
                    z-index: 1000;
                    min-width: 400px;
                `;
                
                modal.innerHTML = `
                    <h3 style="color: white; margin-bottom: 20px;">üè∑Ô∏è Tag Asset: ${asset.name}</h3>
                    <div style="margin-bottom: 15px;">
                        <label style="color: #95a5a6; font-size: 14px; display: block; margin-bottom: 5px;">Select Tags:</label>
                        <div id="tag-suggestions" style="display: flex; flex-wrap: wrap; gap: 8px; margin-bottom: 15px;"></div>
                        <div style="display: flex; gap: 10px; margin-bottom: 15px;">
                            <input type="text" id="new-tag-input" placeholder="Add custom tag..." 
                                style="flex: 1; padding: 8px; border: 1px solid #533483; border-radius: 5px; background: #0f3460; color: white;">
                            <button id="add-tag-btn" style="padding: 8px 15px; background: #3498db; color: white; border: none; border-radius: 5px; cursor: pointer;">Add</button>
                        </div>
                        <div id="selected-tags" style="display: flex; flex-wrap: wrap; gap: 8px; min-height: 40px; padding: 10px; background: #0f3460; border-radius: 5px;"></div>
                    </div>
                    <div style="display: flex; justify-content: flex-end; gap: 10px;">
                        <button id="skip-tagging" style="padding: 10px 20px; background: #95a5a6; color: white; border: none; border-radius: 5px; cursor: pointer;">Skip</button>
                        <button id="confirm-tagging" style="padding: 10px 20px; background: #27ae60; color: white; border: none; border-radius: 5px; cursor: pointer;">Confirm Tags</button>
                    </div>
                `;
                
                document.body.appendChild(modal);
                this.renderTagSuggestions(modal, asset);
                this.setupTaggingDialogEvents(modal, asset);
            }

            renderTagSuggestions(modal, asset) {
                const suggestionsContainer = modal.querySelector('#tag-suggestions');
                const selectedTagsContainer = modal.querySelector('#selected-tags');
                
                this.tagSuggestions.forEach(tag => {
                    const tagElement = document.createElement('button');
                    tagElement.textContent = tag;
                    tagElement.style.cssText = `
                        background: ${this.getTagColor(tag)};
                        color: white;
                        border: none;
                        padding: 5px 12px;
                        border-radius: 15px;
                        font-size: 12px;
                        cursor: pointer;
                        transition: all 0.2s;
                    `;
                    
                    tagElement.addEventListener('click', () => {
                        this.toggleTagSelection(tag, selectedTagsContainer);
                        tagElement.style.background = this.getTagColor(tag, 0.7);
                    });
                    
                    suggestionsContainer.appendChild(tagElement);
                });
                
                const assetName = asset.name.toLowerCase();
                const autoTags = this.suggestTagsFromName(assetName);
                autoTags.forEach(tag => {
                    const tagElements = suggestionsContainer.querySelectorAll('button');
                    tagElements.forEach(el => {
                        if (el.textContent === tag) {
                            el.style.background = this.getTagColor(tag, 0.7);
                            this.toggleTagSelection(tag, selectedTagsContainer, true);
                        }
                    });
                });
            }

            suggestTagsFromName(assetName) {
                const suggestions = [];
                
                if (assetName.includes('player') || assetName.includes('hero') || assetName.includes('character')) {
                    suggestions.push('player');
                }
                
                if (assetName.includes('enemy') || assetName.includes('monster') || assetName.includes('bad') || assetName.includes('villain')) {
                    suggestions.push('enemy');
                }
                
                if (assetName.includes('coin') || assetName.includes('gem') || assetName.includes('star') || assetName.includes('collect')) {
                    suggestions.push('collectible');
                }
                
                if (assetName.includes('wall') || assetName.includes('block') || assetName.includes('platform') || assetName.includes('ground')) {
                    suggestions.push('obstacle');
                }
                
                if (assetName.includes('bullet') || assetName.includes('laser') || assetName.includes('fireball') || assetName.includes('projectile')) {
                    suggestions.push('projectile');
                }
                
                return suggestions;
            }

            toggleTagSelection(tag, container, forceAdd = false) {
                const existingTags = Array.from(container.children)
                    .map(el => el.dataset.tag)
                    .filter(Boolean);
                    
                if (forceAdd || !existingTags.includes(tag)) {
                    const tagElement = document.createElement('span');
                    tagElement.textContent = `üè∑Ô∏è ${tag}`;
                    tagElement.dataset.tag = tag;
                    tagElement.style.cssText = `
                        background: ${this.getTagColor(tag)};
                        color: white;
                        padding: 4px 10px;
                        border-radius: 15px;
                        font-size: 12px;
                        display: flex;
                        align-items: center;
                        gap: 5px;
                    `;
                    
                    const removeBtn = document.createElement('button');
                    removeBtn.innerHTML = '√ó';
                    removeBtn.style.cssText = `
                        background: none;
                        border: none;
                        color: white;
                        cursor: pointer;
                        margin-left: 5px;
                        font-weight: bold;
                    `;
                    
                    removeBtn.addEventListener('click', (e) => {
                        e.stopPropagation();
                        container.removeChild(tagElement);
                    });
                    
                    tagElement.appendChild(removeBtn);
                    container.appendChild(tagElement);
                } else {
                    const tagElement = container.querySelector(`[data-tag="${tag}"]`);
                    if (tagElement) {
                        container.removeChild(tagElement);
                    }
                }
            }

            setupTaggingDialogEvents(modal, asset) {
                const newTagInput = modal.querySelector('#new-tag-input');
                const addTagBtn = modal.querySelector('#add-tag-btn');
                const skipBtn = modal.querySelector('#skip-tagging');
                const confirmBtn = modal.querySelector('#confirm-tagging');
                const selectedTagsContainer = modal.querySelector('#selected-tags');
                
                addTagBtn.addEventListener('click', () => {
                    const tag = newTagInput.value.trim().toLowerCase();
                    if (tag && !this.tagSuggestions.includes(tag)) {
                        this.tagSuggestions.push(tag);
                    }
                    
                    if (tag) {
                        this.toggleTagSelection(tag, selectedTagsContainer, true);
                        newTagInput.value = '';
                        
                        const suggestionsContainer = modal.querySelector('#tag-suggestions');
                        suggestionsContainer.innerHTML = '';
                        this.renderTagSuggestions(modal, asset);
                    }
                });
                
                skipBtn.addEventListener('click', () => {
                    document.body.removeChild(modal);
                });
                
                confirmBtn.addEventListener('click', () => {
                    const selectedTags = Array.from(selectedTagsContainer.children)
                        .map(el => el.dataset.tag)
                        .filter(Boolean);
                        
                    selectedTags.forEach(tag => {
                        this.tagAsset(asset.id, tag);
                    });
                    
                    document.body.removeChild(modal);
                    showToast(`‚úÖ ${selectedTags.length} tags added to ${asset.name}`);
                });
            }

            getTagColor(tag, opacity = 1) {
                const baseColor = this.tagColorMap[tag] || '#533483';
                if (opacity < 1) {
                    const r = parseInt(baseColor.slice(1, 3), 16);
                    const g = parseInt(baseColor.slice(3, 5), 16);
                    const b = parseInt(baseColor.slice(5, 7), 16);
                    return `rgba(${r}, ${g}, ${b}, ${opacity})`;
                }
                return baseColor;
            }

            updateAllBlockDropdowns() {
                if (!this.workspace) return;
                const allBlocks = this.workspace.getAllBlocks(false);
                
                allBlocks.forEach(block => {
                    if (block.type.includes('tag') || block.type.includes('asset') || block.type.includes('spawn')) {
                        this.updateBlockTagDropdowns(block);
                    }
                });
            }

            updateBlockTagDropdowns(block) {
                const options = this.getAssetDropdownOptions();
                const field = block.getField('ASSET') || block.getField('TAG') || block.getField('SPRITE');
                
                if (field && field.setOptions) {
                    field.setOptions(options);
                }
            }

            emitTagEvent(eventName, data) {
                if (this.eventListeners[eventName]) {
                    this.eventListeners[eventName].forEach(callback => {
                        callback(data);
                    });
                }
            }

            on(eventName, callback) {
                if (!this.eventListeners[eventName]) {
                    this.eventListeners[eventName] = [];
                }
                this.eventListeners[eventName].push(callback);
            }
        }

        const AssetTagSystem = {
            instance: null,

            getAssetsByTag(tag) {
                if (this.instance) return this.instance.getAssetsByTag(tag);
                
                const results = [];
                Object.values(AssetManager.assets).forEach(assetList => {
                    assetList.forEach(asset => {
                        if (asset.tags && asset.tags.includes(tag)) {
                            results.push(asset);
                        }
                    });
                });
                return results;
            },

            getAllTags() {
                if (this.instance) return this.instance.getAllTags();
                
                const tags = new Set();
                Object.values(AssetManager.assets).forEach(assetList => {
                    assetList.forEach(asset => {
                        if (asset.tags && Array.isArray(asset.tags)) {
                            asset.tags.forEach(tag => tags.add(tag));
                        }
                    });
                });
                return Array.from(tags).sort();
            },

            getAssetNames() {
                const names = new Set();
                Object.values(AssetManager.assets).forEach(assetList => {
                    assetList.forEach(asset => {
                        const name = asset.name.split('.')[0];
                        names.add(name);
                    });
                });
                return Array.from(names).sort();
            },

            getAssetDropdownOptions() {
                const tags = this.getAllTags();
                const names = this.getAssetNames();
                const options = [["-- Select Asset --", ""]];
                
                // Add tags as real options (not headers)
                if (tags.length > 0) {
                    tags.forEach(tag => {
                        options.push([`üè∑Ô∏è ${tag}`, `tag:${tag}`]);
                    });
                }
                
                // Add names as real options (not headers)
                if (names.length > 0) {
                    names.forEach(name => {
                        options.push([`üì¶ ${name}`, name.toLowerCase()]);
                    });
                }
                
                return options;
            },

            updateBlocklyDropdowns() {
                const options = this.getAssetDropdownOptions();
                const workspace = Blockly.getMainWorkspace();
                if (workspace) {
                    const blocks = workspace.getAllBlocks(false);
                    blocks.forEach(block => {
                        if (block.type === 'spawn_sprite' || block.type === 'spawn_tag_entity') {
                            const field = block.getField('SPRITE') || block.getField('TAG');
                            if (field && field.setOptions) {
                                field.setOptions(options);
                            }
                        }
                    });
                }
            },

            init() {
                const workspace = Blockly.getMainWorkspace();
                this.instance = new AssetTaggingSystem(workspace, AssetManager);
                this.updateBlocklyDropdowns();
            }
        };

        // === STATE STORE: SAVE/SETTINGS PERSISTENCE SYSTEM ===
        class StateStore {
            constructor() {
                this.state = {};
                this.settings = {};
                this.saveSlots = {};
                this.autosaveInterval = null;
                this.lastSaveTime = 0;
                this.SAVE_VERSION = '1.2';
                this.MAX_SAVE_SLOTS = 5;
                this.AUTOSAVE_INTERVAL = 60000;
                this.cloudSyncEnabled = false;
                this.syncQueue = [];
                this.eventListeners = {
                    stateChange: [],
                    settingChange: [],
                    saveEvent: [],
                    achievement: [],
                    syncEvent: []
                };
                this.settingsSchema = {
                    audio: {
                        masterVolume: { default: 1.0, min: 0, max: 1, type: 'number' },
                        musicVolume: { default: 0.7, min: 0, max: 1, type: 'number' },
                        effectsVolume: { default: 0.9, min: 0, max: 1, type: 'number' },
                        muteAll: { default: false, type: 'boolean' }
                    },
                    video: {
                        fullscreen: { default: false, type: 'boolean' },
                        resolution: { default: '1280x720', options: ['800x600', '1280x720', '1920x1080'], type: 'string' },
                        vsync: { default: true, type: 'boolean' },
                        fpsLimit: { default: 60, min: 30, max: 144, type: 'number' }
                    },
                    controls: {
                        invertY: { default: false, type: 'boolean' },
                        sensitivity: { default: 1.0, min: 0.1, max: 5.0, type: 'number' },
                        touchControls: { default: true, type: 'boolean' },
                        vibration: { default: true, type: 'boolean' }
                    },
                    accessibility: {
                        colorBlindMode: { default: false, type: 'boolean' },
                        highContrast: { default: false, type: 'boolean' },
                        subtitles: { default: true, type: 'boolean' },
                        uiScale: { default: 1.0, min: 0.5, max: 2.0, type: 'number' }
                    },
                    privacy: {
                        shareData: { default: true, type: 'boolean' },
                        allowAnalytics: { default: true, type: 'boolean' },
                        saveGameProgress: { default: true, type: 'boolean' }
                    }
                };
                this.loadState();
                this.loadSettings();
                this.initAutosave();
                this.setupEventListeners();
                this.initCloudSync();
            }

            setState(key, value) {
                this.state[key] = value;
                if (key === 'achievements') {
                    this.handleAchievementUnlock(value);
                }
                this.emitStateChange(key, value);
            }

            getState(key, defaultValue = null) {
                return this.state[key] !== undefined ? this.state[key] : defaultValue;
            }

            getStateSnapshot() {
                return { ...this.state };
            }

            clearState() {
                this.state = {};
                this.emitStateChange('all', null);
            }

            getSettingCategory(category) {
                return this.settings[category] || {};
            }

            getSettingValue(category, key, defaultValue = null) {
                return this.settings[category]?.[key] !== undefined ? this.settings[category][key] : defaultValue;
            }

            setSettingValue(category, key, value) {
                if (!this.settings[category]) {
                    this.settings[category] = {};
                }
                
                if (this.settingsSchema[category]?.[key]) {
                    const schema = this.settingsSchema[category][key];
                    
                    if (schema.type === 'number') {
                        value = parseFloat(value);
                        if (schema.min !== undefined) value = Math.max(schema.min, value);
                        if (schema.max !== undefined) value = Math.min(schema.max, value);
                    }
                    
                    if (schema.type === 'boolean') {
                        value = Boolean(value);
                    }
                    
                    if (schema.options && !schema.options.includes(value)) {
                        value = schema.default;
                    }
                }
                
                this.settings[category][key] = value;
                this.handleSpecialSetting(category, key, value);
                this.saveSettings();
                this.emitSettingChange(category, key, value);
                
                if (this.cloudSyncEnabled) {
                    this.queueCloudSync('settings', { category, key, value });
                }
            }

            resetSettingsCategory(category) {
                if (this.settingsSchema[category]) {
                    this.settings[category] = {};
                    Object.entries(this.settingsSchema[category]).forEach(([key, schema]) => {
                        this.settings[category][key] = schema.default;
                    });
                    this.saveSettings();
                    this.emitSettingChange(category, 'all', this.settings[category]);
                }
            }

            resetAllSettings() {
                this.settings = {};
                Object.keys(this.settingsSchema).forEach(category => {
                    this.resetSettingsCategory(category);
                });
                this.saveSettings();
                this.emitSettingChange('all', 'all', this.settings);
            }

            initCloudSync() {
                const storedSync = localStorage.getItem('lupiforge_cloud_sync');
                this.cloudSyncEnabled = storedSync ? JSON.parse(storedSync).enabled : false;
                
                if (window.LUPIFORGE_CURRENT_USER?.is_authenticated) {
                    this.cloudSyncEnabled = true;
                }
            }

            enableCloudSync() {
                this.cloudSyncEnabled = true;
                localStorage.setItem('lupiforge_cloud_sync', JSON.stringify({ enabled: true }));
                this.processSyncQueue();
            }

            disableCloudSync() {
                this.cloudSyncEnabled = false;
                localStorage.setItem('lupiforge_cloud_sync', JSON.stringify({ enabled: false }));
            }

            queueCloudSync(type, data) {
                if (!this.cloudSyncEnabled || !navigator.onLine) return;
                
                this.syncQueue.push({
                    id: Date.now() + Math.random(),
                    type,
                    data,
                    timestamp: Date.now()
                });
                
                if (this.syncQueue.length < 5) {
                    this.processSyncQueue();
                }
            }

            async processSyncQueue() {
                if (!this.cloudSyncEnabled || this.syncQueue.length === 0) return;
                
                try {
                    const response = await fetch('/games/api/cloud-sync/', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'X-CSRFToken': this.getCSRFToken()
                        },
                        body: JSON.stringify({
                            syncData: this.syncQueue.slice(0, 10)
                        })
                    });
                    
                    if (response.ok) {
                        this.syncQueue = this.syncQueue.slice(10);
                    }
                } catch (error) {
                    console.warn('Cloud sync failed:', error);
                    setTimeout(() => this.processSyncQueue(), 30000);
                }
            }

            getCSRFToken() {
                return (document.cookie.match(/csrftoken=([^;]+)/) || [])[1] || '';
            }

            saveGame(slot = 1, metadata = {}) {
                if (slot < 1 || slot > this.MAX_SAVE_SLOTS) {
                    console.error(`Invalid save slot: ${slot}. Must be between 1 and ${this.MAX_SAVE_SLOTS}`);
                    return false;
                }

                try {
                    const saveData = {
                        version: this.SAVE_VERSION,
                        timestamp: Date.now(),
                        state: this.getStateSnapshot(),
                        settings: {
                            audio: this.getSettingCategory('audio'),
                            video: this.getSettingCategory('video'),
                            controls: this.getSettingCategory('controls')
                        },
                        metadata: {
                            ...metadata,
                            playTime: (metadata.playTime || 0) + this.getPlayTimeSinceLastSave()
                        }
                    };
                    
                    this.saveSlots[slot] = saveData;
                    this.lastSaveTime = Date.now();
                    
                    this.saveToStorage();
                    this.emitSaveEvent(slot, 'saved');
                    
                    if (this.cloudSyncEnabled) {
                        this.queueCloudSync('save', { slot, data: saveData });
                    }
                    
                    return true;
                } catch (error) {
                    console.error('Failed to save game:', error);
                    this.emitSaveEvent(slot, 'error', error.message);
                    return false;
                }
            }

            loadGame(slot = 1) {
                if (slot < 1 || slot > this.MAX_SAVE_SLOTS) {
                    console.error(`Invalid load slot: ${slot}. Must be between 1 and ${this.MAX_SAVE_SLOTS}`);
                    return false;
                }

                if (!this.saveSlots[slot]) {
                    console.warn(`No save data found in slot ${slot}`);
                    return false;
                }

                try {
                    const saveData = this.saveSlots[slot];
                    
                    if (saveData.version !== this.SAVE_VERSION) {
                        console.warn(`Save version mismatch: ${saveData.version} vs ${this.SAVE_VERSION}`);
                    }
                    
                    this.state = { ...saveData.state };
                    
                    if (saveData.settings) {
                        Object.entries(saveData.settings).forEach(([category, values]) => {
                            if (this.settingsSchema[category]) {
                                Object.entries(values).forEach(([key, value]) => {
                                    this.setSettingValue(category, key, value);
                                });
                            }
                        });
                    }
                    
                    this.emitSaveEvent(slot, 'loaded');
                    this.emitStateChange('all', this.state);
                    
                    return true;
                } catch (error) {
                    console.error('Failed to load game:', error);
                    this.emitSaveEvent(slot, 'error', error.message);
                    return false;
                }
            }

            getSaveInfo(slot = 1) {
                return this.saveSlots[slot] || null;
            }

            deleteSave(slot = 1) {
                if (slot < 1 || slot > this.MAX_SAVE_SLOTS) {
                    console.error(`Invalid save slot: ${slot}`);
                    return false;
                }
                delete this.saveSlots[slot];
                this.saveToStorage();
                this.emitSaveEvent(slot, 'deleted');
                return true;
            }

            persistState(key, value, persistAcrossScenes = true) {
                this.setState(key, value);
                
                if (persistAcrossScenes) {
                    if (!this.state.__persistent__) {
                        this.state.__persistent__ = {};
                    }
                    this.state.__persistent__[key] = value;
                }
            }

            getStateForScene(sceneName) {
                const sceneState = { ...this.state };
                
                if (sceneState.__persistent__) {
                    Object.keys(sceneState).forEach(key => {
                        if (key !== '__persistent__' && !sceneState.__persistent__[key]) {
                            delete sceneState[key];
                        }
                    });
                    
                    Object.assign(sceneState, sceneState.__persistent__);
                    delete sceneState.__persistent__;
                }
                
                return sceneState;
            }

            on(eventType, callback) {
                if (!this.eventListeners[eventType]) {
                    this.eventListeners[eventType] = [];
                }
                this.eventListeners[eventType].push(callback);
            }

            off(eventType, callback) {
                if (this.eventListeners[eventType]) {
                    this.eventListeners[eventType] = this.eventListeners[eventType].filter(cb => cb !== callback);
                }
            }

            emitStateChange(key, value) {
                this.eventListeners.stateChange.forEach(callback => {
                    callback({ key, value, state: this.state });
                });
            }

            emitSettingChange(category, key, value) {
                this.eventListeners.settingChange.forEach(callback => {
                    callback({ category, key, value, settings: this.settings });
                });
            }

            emitSaveEvent(slot, type, error) {
                this.eventListeners.saveEvent.forEach(callback => {
                    callback({ slot, type, error, saveSlots: this.saveSlots });
                });
            }

            emitSyncEvent(status, data) {
                this.eventListeners.syncEvent.forEach(callback => {
                    callback({ status, data });
                });
            }

            handleSpecialSetting(category, key, value) {
                const settingKey = `${category}.${key}`;
                if (settingKey === 'audio.masterVolume') {
                    console.log('Master volume changed to:', value);
                } else if (settingKey === 'audio.muteAll') {
                    console.log('Master mute:', value);
                } else if (settingKey === 'video.fullscreen') {
                    console.log('Fullscreen mode:', value ? 'enabled' : 'disabled');
                } else if (settingKey === 'video.resolution') {
                    console.log('Resolution changed to:', value);
                } else if (settingKey === 'controls.vibration') {
                    console.log('Vibration:', value ? 'enabled' : 'disabled');
                }
            }

            exportSettings() {
                return JSON.stringify({
                    version: this.SAVE_VERSION,
                    timestamp: Date.now(),
                    settings: this.settings
                });
            }

            importSettings(data) {
                try {
                    const parsed = JSON.parse(data);
                    
                    if (parsed.version !== this.SAVE_VERSION) {
                        console.warn('Settings version mismatch, importing anyway');
                    }
                    
                    this.settings = parsed.settings || {};
                    this.saveSettings();
                    
                    this.emitSettingChange('all', 'imported', this.settings);
                    return true;
                } catch (error) {
                    console.error('Failed to import settings:', error);
                    return false;
                }
            }

            saveToStorage() {
                try {
                    localStorage.setItem('lupiforge_game_saves', JSON.stringify({
                        version: this.SAVE_VERSION,
                        timestamp: Date.now(),
                        saveSlots: this.saveSlots
                    }));
                    return true;
                } catch (error) {
                    console.error('Failed to save to storage:', error);
                    return false;
                }
            }

            loadFromStorage() {
                try {
                    const saved = localStorage.getItem('lupiforge_game_saves');
                    if (saved) {
                        const parsed = JSON.parse(saved);
                        
                        if (parsed.version === this.SAVE_VERSION) {
                            this.saveSlots = parsed.saveSlots || {};
                        } else {
                            console.warn('Save data version mismatch');
                            this.saveSlots = {};
                        }
                    }
                    return true;
                } catch (error) {
                    console.error('Failed to load from storage:', error);
                    this.saveSlots = {};
                    return false;
                }
            }

            saveState() {
                try {
                    localStorage.setItem('lupiforge_game_state', JSON.stringify(this.state));
                } catch (error) {
                    console.error('Failed to save state:', error);
                }
            }

            loadState() {
                try {
                    const saved = localStorage.getItem('lupiforge_game_state');
                    if (saved) {
                        this.state = JSON.parse(saved);
                    }
                } catch (error) {
                    console.error('Failed to load state:', error);
                    this.state = {};
                }
            }

            saveSettings() {
                try {
                    localStorage.setItem('lupiforge_game_settings', JSON.stringify(this.settings));
                } catch (error) {
                    console.error('Failed to save settings:', error);
                }
            }

            loadSettings() {
                try {
                    const saved = localStorage.getItem('lupiforge_game_settings');
                    if (saved) {
                        this.settings = JSON.parse(saved);
                    }
                } catch (error) {
                    console.error('Failed to load settings:', error);
                    this.settings = {};
                }
            }

            initAutosave() {
                this.autosaveInterval = setInterval(() => {
                    this.saveState();
                    this.saveSettings();
                }, this.AUTOSAVE_INTERVAL);
            }

            getPlayTimeSinceLastSave() {
                return Math.floor((Date.now() - this.lastSaveTime) / 1000);
            }

            handleAchievementUnlock(achievement) {
                console.log('Achievement unlocked:', achievement);
            }

            setupEventListeners() {
                window.addEventListener('beforeunload', () => {
                    this.saveState();
                    this.saveSettings();
                });
                
                window.addEventListener('online', () => {
                    console.log('Connection restored, syncing saves');
                    this.processSyncQueue();
                });
                
                window.addEventListener('offline', () => {
                    console.log('Offline mode, using local saves only');
                });
                
                document.addEventListener('visibilitychange', () => {
                    if (document.hidden) {
                        this.saveState();
                    }
                });
                
                this.loadFromStorage();
                
                setInterval(() => {
                    if (navigator.onLine && this.cloudSyncEnabled && this.syncQueue.length > 0) {
                        this.processSyncQueue();
                    }
                }, 60000);
            }

            destroy() {
                if (this.autosaveInterval) {
                    clearInterval(this.autosaveInterval);
                }
                
                this.saveState();
                this.saveSettings();
                
                this.eventListeners = {};
            }
        }

        // === DEBUG OVERLAY SYSTEM ===
        if (typeof DebugOverlaySystem === 'undefined') {
        window.DebugOverlaySystem = class DebugOverlaySystem {
            constructor(renderSystem, entityManager, canvas) {
                this.enabled = false;
                this.showHitboxes = true;
                this.showPerformance = true;
                this.showEntityInfo = true;
                this.renderSystem = renderSystem;
                this.entityManager = entityManager;
                this.lastFrameTime = 0;
                this.frameCount = 0;
                this.fps = 60;
                this.canvas = canvas;
                this.ctx = canvas ? canvas.getContext('2d') : null;
                this.debugText = [];
                this.debugRects = [];
                this.debugCircles = [];
                this.debugLines = [];
                this.logs = [];
                this.maxLogs = 100;
                this.setupEventListeners();
                this.init();
            }

            init() {
                const debugOverlay = document.createElement('div');
                debugOverlay.id = 'debug-overlay';
                debugOverlay.style.cssText = `
                    position: fixed;
                    top: 10px;
                    right: 10px;
                    background: rgba(22, 33, 62, 0.85);
                    color: white;
                    padding: 10px;
                    border-radius: 8px;
                    font-family: monospace;
                    font-size: 12px;
                    z-index: 1000;
                    display: none;
                    max-width: 300px;
                    max-height: 80vh;
                    overflow: auto;
                    border: 2px solid #533483;
                `;
                document.body.appendChild(debugOverlay);
                
                const debugConsole = document.createElement('div');
                debugConsole.id = 'debug-console';
                debugConsole.style.cssText = `
                    position: fixed;
                    bottom: 20px;
                    left: 20px;
                    background: rgba(22, 33, 62, 0.9);
                    color: white;
                    padding: 15px;
                    border-radius: 8px;
                    font-family: monospace;
                    font-size: 12px;
                    z-index: 1000;
                    display: none;
                    min-width: 400px;
                    max-height: 300px;
                    overflow-y: auto;
                    box-shadow: 0 4px 15px rgba(0,0,0,0.3);
                    border: 2px solid #533483;
                `;
                document.body.appendChild(debugConsole);
                
                this.log('Debug system initialized', 'info');
            }

            setupEventListeners() {
                window.addEventListener('keydown', (e) => {
                    if (e.key === 'F3') {
                        this.toggle();
                    } else if (e.key === 'F4') {
                        this.toggleHitboxes();
                    } else if (e.key === 'F5') {
                        this.togglePerformance();
                    } else if (e.key === 'F6') {
                        this.toggleEntityInfo();
                    } else if (e.key === 'F7') {
                        this.toggleConsole();
                    }
                });
            }

            toggle() {
                this.enabled = !this.enabled;
                const overlay = document.getElementById('debug-overlay');
                if (overlay) {
                    overlay.style.display = this.enabled ? 'block' : 'none';
                }
                this.log(`Debug overlay ${this.enabled ? 'enabled' : 'disabled'}`, 'info');
                return this.enabled;
            }

            toggleHitboxes() {
                this.showHitboxes = !this.showHitboxes;
                this.log(`Hitboxes ${this.showHitboxes ? 'enabled' : 'disabled'}`, 'info');
                return this.showHitboxes;
            }

            togglePerformance() {
                this.showPerformance = !this.showPerformance;
                this.log(`Performance metrics ${this.showPerformance ? 'enabled' : 'disabled'}`, 'info');
                return this.showPerformance;
            }

            toggleEntityInfo() {
                this.showEntityInfo = !this.showEntityInfo;
                this.log(`Entity info ${this.showEntityInfo ? 'enabled' : 'disabled'}`, 'info');
                return this.showEntityInfo;
            }

            toggleConsole() {
                const consoleEl = document.getElementById('debug-console');
                if (consoleEl) {
                    consoleEl.style.display = consoleEl.style.display === 'block' ? 'none' : 'block';
                    this.log(`Debug console ${consoleEl.style.display === 'block' ? 'shown' : 'hidden'}`, 'info');
                }
            }

            update(deltaTime) {
                if (!this.enabled) return;
                
                this.frameCount++;
                const now = performance.now();
                if (now - this.lastFrameTime >= 1000) {
                    this.fps = this.frameCount;
                    this.frameCount = 0;
                    this.lastFrameTime = now;
                }
                
                this.clearDebugDrawings();
            }

            render() {
                if (!this.enabled || !this.ctx) return;

                this.ctx.save();
                this.ctx.setTransform(1, 0, 0, 1, 0, 0);
                
                if (this.showHitboxes && this.renderSystem && this.entityManager) {
                    this.renderHitboxes();
                }
                
                if (this.showPerformance) {
                    this.renderPerformanceMetrics();
                }
                
                if (this.showEntityInfo && this.renderSystem && this.entityManager) {
                    this.renderEntityInfo();
                }
                
                this.renderDebugDrawings();
                
                this.ctx.restore();
            }

            renderHitboxes() {
                if (!this.entityManager.getAllEntities) return;
                
                const entities = this.entityManager.getAllEntities();
                const camera = this.renderSystem.getCameraPosition();
                const zoom = this.renderSystem.getCameraZoom ? this.renderSystem.getCameraZoom() : 1;
                
                entities.forEach(entity => {
                    if (!entity.width || !entity.height) return;
                    
                    const screenPos = this.renderSystem.worldToScreen ? 
                        this.renderSystem.worldToScreen(entity.x, entity.y) : 
                        { x: entity.x, y: entity.y };
                    
                    this.ctx.save();
                    this.ctx.setTransform(1, 0, 0, 1, 0, 0);
                    
                    this.ctx.strokeStyle = entity.tags?.includes('player') ? '#3498db' : 
                                         entity.tags?.includes('enemy') ? '#e74c3c' : 
                                         entity.tags?.includes('collectible') ? '#2ecc71' : '#f1c40f';
                    this.ctx.lineWidth = 2;
                    this.ctx.strokeRect(
                        screenPos.x - (entity.width / 2) * zoom,
                        screenPos.y - (entity.height / 2) * zoom,
                        entity.width * zoom,
                        entity.height * zoom
                    );
                    
                    this.ctx.font = '10px Arial';
                    this.ctx.fillStyle = this.ctx.strokeStyle;
                    this.ctx.textAlign = 'center';
                    this.ctx.fillText(
                        entity.id ? `ID: ${entity.id}` : entity.type || 'Entity',
                        screenPos.x,
                        screenPos.y - (entity.height / 2) * zoom - 5
                    );
                    
                    if (entity.tags && entity.tags.length > 0) {
                        this.ctx.font = '8px Arial';
                        this.ctx.fillStyle = '#ecf0f1';
                        entity.tags.forEach((tag, index) => {
                            this.ctx.fillText(
                                tag,
                                screenPos.x,
                                screenPos.y - (entity.height / 2) * zoom + (index * 10) + 10
                            );
                        });
                    }
                    
                    this.ctx.restore();
                });
            }

            renderPerformanceMetrics() {
                this.ctx.save();
                this.ctx.setTransform(1, 0, 0, 1, 0, 0);
                
                const metrics = [
                    `FPS: ${Math.round(this.fps)}`,
                    `Entities: ${this.entityManager?.getEntityCount?.() || 'N/A'}`,
                    `Memory: ${Math.round(performance.memory?.usedJSHeapSize / 1048576 || 0)}MB`
                ];
                
                if (this.renderSystem?.getCameraPosition) {
                    const pos = this.renderSystem.getCameraPosition();
                    metrics.push(`Camera: (${Math.round(pos.x)}, ${Math.round(pos.y)})`);
                }
                
                if (this.renderSystem?.getCameraZoom) {
                    metrics.push(`Zoom: ${this.renderSystem.getCameraZoom().toFixed(2)}`);
                }
                
                this.ctx.font = '12px Arial';
                this.ctx.fillStyle = '#27ae60';
                this.ctx.textAlign = 'left';
                
                metrics.forEach((metric, index) => {
                    this.ctx.fillText(metric, 10, 30 + (index * 20));
                });
                
                this.ctx.restore();
            }

            renderEntityInfo() {
                const mousePos = this.getMousePosition();
                if (!mousePos) return;
                
                const worldMouse = this.renderSystem.screenToWorld ? 
                    this.renderSystem.screenToWorld(mousePos.x, mousePos.y) : 
                    mousePos;
                
                const nearbyEntities = this.entityManager.getEntitiesNear ? 
                    this.entityManager.getEntitiesNear(worldMouse.x, worldMouse.y, 100) : [];
                
                if (nearbyEntities.length === 0) return;
                
                this.ctx.save();
                this.ctx.setTransform(1, 0, 0, 1, 0, 0);
                
                const panelX = mousePos.x + 20;
                const panelY = mousePos.y + 20;
                const panelWidth = 200;
                const lineHeight = 18;
                
                this.ctx.fillStyle = 'rgba(22, 33, 62, 0.85)';
                this.ctx.fillRect(panelX, panelY, panelWidth, (nearbyEntities.length * 80) + 20);
                this.ctx.strokeStyle = '#533483';
                this.ctx.lineWidth = 2;
                this.ctx.strokeRect(panelX, panelY, panelWidth, (nearbyEntities.length * 80) + 20);
                
                this.ctx.font = '14px Arial';
                this.ctx.fillStyle = '#ecf0f1';
                this.ctx.textAlign = 'left';
                this.ctx.fillText('Entity Inspector', panelX + 10, panelY + 20);
                
                nearbyEntities.forEach((entity, index) => {
                    const startY = panelY + 40 + (index * 80);
                    
                    this.ctx.font = '12px Arial';
                    this.ctx.fillStyle = '#3498db';
                    this.ctx.fillText(`Type: ${entity.type || 'Unknown'}`, panelX + 10, startY);
                    this.ctx.fillStyle = '#95a5a6';
                    this.ctx.fillText(`ID: ${entity.id || 'N/A'}`, panelX + 10, startY + 15);
                    
                    this.ctx.fillStyle = '#2ecc71';
                    this.ctx.fillText(`Pos: (${Math.round(entity.x)}, ${Math.round(entity.y)})`, panelX + 10, startY + 30);
                    
                    if (entity.health !== undefined) {
                        this.ctx.fillStyle = '#e74c3c';
                        this.ctx.fillText(`Health: ${Math.round(entity.health)}`, panelX + 10, startY + 45);
                    }
                    
                    if (entity.velocityX !== undefined || entity.velocityY !== undefined) {
                        this.ctx.fillStyle = '#9b59b6';
                        const velX = entity.velocityX ? Math.round(entity.velocityX) : 0;
                        const velY = entity.velocityY ? Math.round(entity.velocityY) : 0;
                        this.ctx.fillText(`Velocity: (${velX}, ${velY})`, panelX + 10, startY + 60);
                    }
                });
                
                this.ctx.restore();
            }

            getMousePosition() {
                if (typeof inputSystem !== 'undefined' && inputSystem.getMouseX) {
                    return {
                        x: inputSystem.getMouseX(),
                        y: inputSystem.getMouseY()
                    };
                }
                return null;
            }

            drawDebugText(text, x, y, color = '#ecf0f1', size = 12) {
                if (!this.enabled || !this.ctx) return;
                
                this.ctx.save();
                this.ctx.setTransform(1, 0, 0, 1, 0, 0);
                this.ctx.font = `${size}px Arial`;
                this.ctx.fillStyle = color;
                this.ctx.textAlign = 'left';
                this.ctx.fillText(text, x, y);
                this.ctx.restore();
            }

            drawDebugRect(x, y, width, height, color = '#f1c40f', lineWidth = 2) {
                if (!this.enabled || !this.ctx) return;
                
                this.ctx.save();
                this.ctx.setTransform(1, 0, 0, 1, 0, 0);
                this.ctx.strokeStyle = color;
                this.ctx.lineWidth = lineWidth;
                this.ctx.strokeRect(x, y, width, height);
                this.ctx.restore();
            }

            drawDebugCircle(x, y, radius, color = '#3498db', lineWidth = 2) {
                if (!this.enabled || !this.ctx) return;
                
                this.ctx.save();
                this.ctx.setTransform(1, 0, 0, 1, 0, 0);
                this.ctx.beginPath();
                this.ctx.arc(x, y, radius, 0, Math.PI * 2);
                this.ctx.strokeStyle = color;
                this.ctx.lineWidth = lineWidth;
                this.ctx.stroke();
                this.ctx.restore();
            }

            drawDebugLine(x1, y1, x2, y2, color = '#e74c3c', lineWidth = 2) {
                if (!this.enabled || !this.ctx) return;
                
                this.ctx.save();
                this.ctx.setTransform(1, 0, 0, 1, 0, 0);
                this.ctx.beginPath();
                this.ctx.moveTo(x1, y1);
                this.ctx.lineTo(x2, y2);
                this.ctx.strokeStyle = color;
                this.ctx.lineWidth = lineWidth;
                this.ctx.stroke();
                this.ctx.restore();
            }

            renderDebugDrawings() {
                this.debugRects.forEach(rect => {
                    this.drawDebugRect(rect.x, rect.y, rect.width, rect.height, rect.color, rect.lineWidth);
                });
                
                this.debugCircles.forEach(circle => {
                    this.drawDebugCircle(circle.x, circle.y, circle.radius, circle.color, circle.lineWidth);
                });
                
                this.debugLines.forEach(line => {
                    this.drawDebugLine(line.x1, line.y1, line.x2, line.y2, line.color, line.lineWidth);
                });
                
                this.debugText.forEach(text => {
                    this.drawDebugText(text.text, text.x, text.y, text.color, text.size);
                });
            }

            clearDebugDrawings() {
                this.debugRects = [];
                this.debugCircles = [];
                this.debugLines = [];
                this.debugText = [];
            }

            log(message, category = 'info') {
                const timestamp = new Date().toLocaleTimeString();
                const color = category === 'error' ? '#e74c3c' : 
                             category === 'warning' ? '#f39c12' : 
                             category === 'success' ? '#2ecc71' : '#3498db';
                
                console.log(`[DEBUG] [${timestamp}] [${category.toUpperCase()}] ${message}`);
                
                this.logs.push({ timestamp, category, message, color });
                if (this.logs.length > this.maxLogs) {
                    this.logs.shift();
                }
                
                const debugConsole = document.getElementById('debug-console');
                if (debugConsole && this.enabled) {
                    const logEntry = document.createElement('div');
                    logEntry.style.marginBottom = '4px';
                    logEntry.innerHTML = `[<span style="color: #95a5a6">${timestamp}</span>] [<span style="color: ${color}">${category.toUpperCase()}</span>] ${message}`;
                    debugConsole.appendChild(logEntry);
                    debugConsole.scrollTop = debugConsole.scrollHeight;
                }
                
                const overlay = document.getElementById('debug-overlay');
                if (overlay && this.enabled) {
                    overlay.innerHTML = this.logs.map(log => 
                        `[<span style="color: #95a5a6">${log.timestamp}</span>] [<span style="color: ${log.color}">${log.category.toUpperCase()}</span>] ${log.message}`
                    ).join('<br>');
                }
            }

            destroy() {
                const overlay = document.getElementById('debug-overlay');
                const console = document.getElementById('debug-console');
                if (overlay) overlay.remove();
                if (console) console.remove();
                this.logs = [];
            }
        }
        } else {
            console.warn('‚ö†Ô∏è DebugOverlaySystem already declared. Using existing instance.');
        }

        let stateStore = null;
        try {
            stateStore = new StateStore();
            console.log('‚úÖ StateStore initialized');
        } catch (error) {
            console.error('‚ùå StateStore initialization failed:', error);
        }

        if (typeof registerBlock !== 'undefined') {
            registerBlock({
                id: "save_game",
                category: "Save/Load",
                label: "Save Game to Slot [SLOT]",
                inputs: {
                    SLOT: { type: "number", default: 1, min: 1, max: 5 },
                    NAME: { type: "string", default: "Quick Save" },
                    DESCRIPTION: { type: "string", default: "Auto-saved game state" },
                    PERSIST_ACROSS_SCENES: { type: "boolean", default: true }
                },
                output: "boolean",
                compile(node) {
                    return { 
                        type: "SaveGame", 
                        properties: {
                            slot: parseInt(node.inputs.SLOT),
                            metadata: {
                                name: node.inputs.NAME,
                                description: node.inputs.DESCRIPTION,
                                manualSave: true,
                                persistAcrossScenes: node.inputs.PERSIST_ACROSS_SCENES
                            }
                        }
                    };
                }
            });

            registerBlock({
                id: "load_game",
                category: "Save/Load",
                label: "Load Game from Slot [SLOT]",
                inputs: {
                    SLOT: { type: "number", default: 1, min: 1, max: 5 }
                },
                output: "boolean",
                compile(node) {
                    return { 
                        type: "LoadGame", 
                        properties: {
                            slot: parseInt(node.inputs.SLOT)
                        }
                    };
                }
            });

            registerBlock({
                id: "get_save_info",
                category: "Save/Load",
                label: "Get Save Info for Slot [SLOT]",
                inputs: {
                    SLOT: { type: "number", default: 1, min: 1, max: 5 }
                },
                output: "object",
                compile(node) {
                    return { 
                        type: "GetSaveInfo", 
                        properties: {
                            slot: parseInt(node.inputs.SLOT)
                        }
                    };
                }
            });

            registerBlock({
                id: "delete_save",
                category: "Save/Load",
                label: "Delete Save Slot [SLOT]",
                inputs: {
                    SLOT: { type: "number", default: 1, min: 1, max: 5 },
                    CONFIRM: { type: "boolean", default: false }
                },
                output: "boolean",
                compile(node) {
                    return { 
                        type: "DeleteSave", 
                        properties: {
                            slot: parseInt(node.inputs.SLOT),
                            confirm: node.inputs.CONFIRM
                        }
                    };
                }
            });

            registerBlock({
                id: "set_setting_value",
                category: "Save/Load",
                label: "Set Setting [CATEGORY].[KEY] to [VALUE]",
                inputs: {
                    CATEGORY: { 
                        type: "dropdown", 
                        options: ["audio", "video", "controls", "accessibility", "privacy"],
                        default: "audio"
                    },
                    KEY: { 
                        type: "string",
                        default: "masterVolume"
                    },
                    VALUE: { type: "any" }
                },
                output: null,
                compile(node) {
                    return { 
                        type: "SetSettingValue", 
                        properties: {
                            category: node.inputs.CATEGORY,
                            key: node.inputs.KEY,
                            value: node.inputs.VALUE
                        }
                    };
                }
            });

            registerBlock({
                id: "get_setting_value",
                category: "Save/Load",
                label: "Get Setting [CATEGORY].[KEY]",
                inputs: {
                    CATEGORY: { 
                        type: "dropdown", 
                        options: ["audio", "video", "controls", "accessibility", "privacy"],
                        default: "audio"
                    },
                    KEY: { 
                        type: "string",
                        default: "masterVolume"
                    }
                },
                output: "any",
                compile(node) {
                    return { 
                        type: "GetSettingValue", 
                        properties: {
                            category: node.inputs.CATEGORY,
                            key: node.inputs.KEY
                        }
                    };
                }
            });

            registerBlock({
                id: "persist_state",
                category: "Save/Load",
                label: "Persist State [KEY] = [VALUE]",
                inputs: {
                    KEY: { type: "string", default: "playerScore" },
                    VALUE: { type: "any" },
                    PERSIST: { type: "boolean", default: true }
                },
                output: null,
                compile(node) {
                    return { 
                        type: "PersistState", 
                        properties: {
                            key: node.inputs.KEY,
                            value: node.inputs.VALUE,
                            persistAcrossScenes: node.inputs.PERSIST
                        }
                    };
                }
            });

            registerBlock({
                id: "enable_cloud_sync",
                category: "Save/Load",
                label: "Enable Cloud Sync",
                output: "boolean",
                compile(node) {
                    return { 
                        type: "EnableCloudSync"
                    };
                }
            });

            registerBlock({
                id: "disable_cloud_sync",
                category: "Save/Load",
                label: "Disable Cloud Sync",
                output: "boolean",
                compile(node) {
                    return { 
                        type: "DisableCloudSync"
                    };
                }
            });
        }

        // JavaScript Parser for Blockly ‚Üî Code sync
        const JavaScriptParser = {
            supportedPatterns: {
                keyEvents: /on(?:KeyPressed|KeyReleased|MouseButtonPressed|MouseButtonReleased)\(['"](.*?)['"]/gi,
                tagOperations: /(?:forEachWithTag|countWithTag|destroyAllWithTag|cloneWithTag|hasTag|getNearestWithTag|getRandomWithTag)\(['"](.*?)['"]/gi,
                stateBlocks: /(?:initStateMachine|setState|getState|isState)\(/gi,
                loops: /for\s*\(.*?\)|while\s*\(.*?\)|repeat/gi,
                functions: /function\s+\w+|const\s+\w+\s*=\s*(?:function|\()/gi
            },

            parse(code) {
                if (!code || typeof code !== 'string') {
                    return { warnings: ['Code is empty or invalid'], supportedBlocks: [], unsupported: [] };
                }

                const result = {
                    warnings: [],
                    supportedBlocks: [],
                    unsupported: [],
                    isValid: true
                };

                const lines = code.split('\n');
                let blockIndex = 0;

                for (let line of lines) {
                    line = line.trim();
                    if (!line || line.startsWith('//') || line.startsWith('*')) continue;

                    if (line.match(/onKeyPressed\s*\(/i)) {
                        const keyMatch = line.match(/["'`]([^"'`]+)["'`]/);
                        if (keyMatch) {
                            result.supportedBlocks.push({
                                type: 'when_key_pressed',
                                key: keyMatch[1],
                                id: `key_${blockIndex++}`
                            });
                        }
                    } else if (line.match(/onKeyReleased\s*\(/i)) {
                        const keyMatch = line.match(/["'`]([^"'`]+)["'`]/);
                        if (keyMatch) {
                            result.supportedBlocks.push({
                                type: 'when_key_released',
                                key: keyMatch[1],
                                id: `key_${blockIndex++}`
                            });
                        }
                    } else if (line.match(/onMouseButtonPressed\s*\(/i)) {
                        result.supportedBlocks.push({
                            type: 'when_mouse_button_pressed',
                            button: 'LEFT',
                            id: `mouse_${blockIndex++}`
                        });
                    } else if (line.match(/forEachWithTag\s*\(/i)) {
                        const tagMatch = line.match(/["'`]([^"'`]+)["'`]/);
                        if (tagMatch) {
                            result.supportedBlocks.push({
                                type: 'for_each_with_tag',
                                tag: tagMatch[1],
                                id: `loop_${blockIndex++}`
                            });
                        }
                    } else if (line.match(/countWithTag\s*\(/i)) {
                        const tagMatch = line.match(/["'`]([^"'`]+)["'`]/);
                        if (tagMatch) {
                            result.supportedBlocks.push({
                                type: 'count_with_tag',
                                tag: tagMatch[1],
                                id: `count_${blockIndex++}`
                            });
                        }
                    } else if (line.match(/destroyAllWithTag\s*\(/i)) {
                        const tagMatch = line.match(/["'`]([^"'`]+)["'`]/);
                        if (tagMatch) {
                            result.supportedBlocks.push({
                                type: 'destroy_all_with_tag',
                                tag: tagMatch[1],
                                id: `destroy_${blockIndex++}`
                            });
                        }
                    } else if (line.match(/\bif\s*\(/)) {
                        result.supportedBlocks.push({
                            type: 'controls_if',
                            id: `if_${blockIndex++}`
                        });
                    } else if (line.match(/\bfor\s*\(/)) {
                        result.supportedBlocks.push({
                            type: 'for_loop',
                            id: `for_${blockIndex++}`
                        });
                    } else if (line.match(/\bwhile\s*\(/)) {
                        result.supportedBlocks.push({
                            type: 'while_loop',
                            id: `while_${blockIndex++}`
                        });
                    }
                }

                if (result.supportedBlocks.length === 0) {
                    result.warnings.push('‚ö†Ô∏è No recognizable Lupify blocks found. Code may be custom logic.');
                }

                return result;
            }
        };

        const EnhancedTerminalManager = {
    isOpen: false,
    isCollapsed: false,
    currentTab: 'output',
    outputBuffer: [],
    editor: null,
    autocompleteIndex: 0,
    history: [],
    historyIndex: -1,
    
    lupifyAPI: {
        'onKeyPressed': 'onKeyPressed("KeyA", () => {\n  \n})',
        'onKeyReleased': 'onKeyReleased("KeyA", () => {\n  \n})',
        'onMouseButtonPressed': 'onMouseButtonPressed("LEFT", () => {\n  \n})',
        'forEachWithTag': 'forEachWithTag("enemy", (entity) => {\n  \n})',
        'countWithTag': 'countWithTag("enemy")',
        'destroyAllWithTag': 'destroyAllWithTag("enemy")',
    },
    
    init() {
        this.attachEvents();
        this.setupEditor();
        this.loadHistory();
        console.log('üñ•Ô∏è Enhanced Terminal initialized');
    },
    
    setupEditor() {
        const jsField = document.getElementById('terminalInputField');
        const cssField = document.getElementById('terminalCSSField');
        const htmlField = document.getElementById('terminalHTMLField');
        
        this.editor = jsField;
        this.cssEditor = cssField;
        this.htmlEditor = htmlField;
        this.lupiEditor = document.getElementById('lupiEditor');
        
        if (jsField) {
            jsField.addEventListener('keydown', (e) => this.handleEditorKeydown(e));
            jsField.addEventListener('input', (e) => this.handleEditorInput(e));
        }
        
        if (this.lupiEditor) {
            this.lupiEditor.addEventListener('input', (e) => this.handleLupiEditorInput(e));
        }
        
        const clearBtn = document.getElementById('terminalClearForms');
        if (clearBtn) {
            clearBtn.addEventListener('click', () => {
                if (jsField) jsField.value = '';
                if (cssField) cssField.value = '';
                if (htmlField) htmlField.value = '';
                this.log('Forms cleared', 'info');
            });
        }
        
        const previewBtn = document.getElementById('previewConvertBtn');
        if (previewBtn) {
            previewBtn.addEventListener('click', () => {
                const modal = document.getElementById('structurePreviewModal');
                if (modal) modal.style.display = 'none';
                this.submitCode();
            });
        }
    },
    
    handleEditorKeydown(e) {
        const textarea = e.target;
        
        if (e.ctrlKey && e.key === 'Enter') {
            e.preventDefault();
            this.submitCode();
            return;
        }
        
        if (e.key === 'Tab') {
            e.preventDefault();
            this.showAutocomplete(textarea);
            return;
        }
        
        if (e.key === 'ArrowUp' && e.ctrlKey) {
            e.preventDefault();
            this.navigateHistory(-1);
            return;
        }
        
        if (e.key === 'ArrowDown' && e.ctrlKey) {
            e.preventDefault();
            this.navigateHistory(1);
            return;
        }
        
        if (e.key === 'Enter') {
            const lines = textarea.value.substr(0, textarea.selectionStart).split('\n');
            const currentLine = lines[lines.length - 1];
            const indent = currentLine.match(/^\s*/)[0];
            
            if (currentLine.trim().endsWith('{') || currentLine.trim().endsWith('(')) {
                e.preventDefault();
                const extraIndent = '  ';
                textarea.setRangeText('\n' + indent + extraIndent, textarea.selectionStart, textarea.selectionStart, 'end');
            }
        }
    },
    
    handleEditorInput(e) {
        const textarea = e.target;
        const cursorPos = textarea.selectionStart;
        const textBefore = textarea.value.substr(0, cursorPos);
        const lastWord = textBefore.match(/\w+$/);
        
        if (lastWord) {
            this.showAutocompleteSuggestions(lastWord[0]);
        }
    },
    
    showAutocompleteSuggestions(partial) {
        const matches = Object.keys(this.lupifyAPI).filter(key => 
            key.toLowerCase().startsWith(partial.toLowerCase())
        );
        
        if (matches.length > 0) {
            this.log(`üí° Suggestions: ${matches.join(', ')}`, 'info');
        }
    },
    
    showAutocomplete(textarea) {
        const cursorPos = textarea.selectionStart;
        const textBefore = textarea.value.substr(0, cursorPos);
        const lastWord = textBefore.match(/\w+$/);
        
        if (lastWord) {
            const matches = Object.keys(this.lupifyAPI).filter(key => 
                key.toLowerCase().startsWith(lastWord[0].toLowerCase())
            );
            
            if (matches.length > 0) {
                const selected = matches[this.autocompleteIndex % matches.length];
                const completion = this.lupifyAPI[selected];
                
                const newValue = textBefore.replace(/\w+$/, completion) + textarea.value.substr(cursorPos);
                textarea.value = newValue;
                textarea.selectionStart = textarea.selectionEnd = cursorPos + completion.length - lastWord[0].length;
                
                this.autocompleteIndex++;
                this.log(`‚ú® Inserted: ${selected}`, 'success');
            }
        }
    },
    
    navigateHistory(direction) {
        if (this.history.length === 0) return;
        
        this.historyIndex = Math.max(-1, Math.min(this.history.length - 1, this.historyIndex + direction));
        
        if (this.historyIndex >= 0) {
            this.editor.value = this.history[this.historyIndex];
        } else {
            this.editor.value = '';
        }
    },
    
    saveHistory() {
        localStorage.setItem('lupiforge_terminal_history', JSON.stringify(this.history));
    },
    
    loadHistory() {
        const saved = localStorage.getItem('lupiforge_terminal_history');
        if (saved) {
            this.history = JSON.parse(saved);
        }
    },

    attachEvents() {
        document.getElementById('terminalBtn').addEventListener('click', () => this.toggle());
        document.getElementById('terminalToggle').addEventListener('click', (e) => {
            e.stopPropagation();
            this.toggleCollapse();
        });
        document.getElementById('terminalClear').addEventListener('click', () => this.clear());
        
        document.querySelectorAll('.terminal-tab').forEach(tab => {
            tab.addEventListener('click', () => this.switchTab(tab.dataset.tab));
        });
        
        document.getElementById('terminalSubmit').addEventListener('click', () => this.submitCode());
        document.getElementById('terminalPreview').addEventListener('click', () => this.previewCode());
    },
    
    submitCode() {
        const code = this.editor.value.trim();
        if (!code) return;
        
        this.history.push(code);
        if (this.history.length > 50) this.history.shift();
        this.historyIndex = this.history.length;
        this.saveHistory();
        
        this.log(`üìù Submitted code (${code.length} chars)`, 'info');
        
        const parsed = this.advancedParse(code);
        
        if (parsed.supportedBlocks.length > 0) {
            this.log(`‚úÖ Found ${parsed.supportedBlocks.length} Lupify blocks`, 'success');
            
            parsed.supportedBlocks.forEach((block, idx) => {
                this.log(`  ${idx + 1}. ${block.type}: ${JSON.stringify(block.params || {})}`, 'info');
            });
            
            this.reconstructBlocks(parsed.supportedBlocks);
            this.log('üéâ Blockly workspace updated!', 'success');
            
            this.showConversionSummary(code, parsed.supportedBlocks);
        } else {
            this.log('‚ö†Ô∏è No recognizable Lupify blocks found', 'warn');
            this.log('üí° Supported: onKeyPressed, forEachWithTag, if/for/while, etc.', 'info');
        }
        
        if (parsed.warnings.length > 0) {
            parsed.warnings.forEach(w => this.log(`‚ö†Ô∏è ${w}`, 'warn'));
        }
        
        this.editor.value = '';
    },
    
    advancedParse(code) {
        const result = {
            supportedBlocks: [],
            warnings: [],
            unsupported: []
        };
        
        const patterns = [
            { regex: /onKeyPressed\s*\(\s*["'](.+?)["']\s*,/gi, type: 'when_key_pressed', extract: (m) => ({ key: m[1] }) },
            { regex: /onKeyReleased\s*\(\s*["'](.+?)["']\s*,/gi, type: 'when_key_released', extract: (m) => ({ key: m[1] }) },
            { regex: /onMouseButtonPressed\s*\(\s*["'](.+?)["']\s*,/gi, type: 'when_mouse_button_pressed', extract: (m) => ({ button: m[1] }) },
            
            { regex: /forEachWithTag\s*\(\s*["'](.+?)["']\s*,/gi, type: 'for_each_with_tag', extract: (m) => ({ tag: m[1] }) },
            { regex: /countWithTag\s*\(\s*["'](.+?)["']\s*\)/gi, type: 'count_with_tag', extract: (m) => ({ tag: m[1] }) },
            { regex: /destroyAllWithTag\s*\(\s*["'](.+?)["']\s*\)/gi, type: 'destroy_all_with_tag', extract: (m) => ({ tag: m[1] }) },
            
            { regex: /if\s*\(/gi, type: 'controls_if', extract: () => ({}) },
            { regex: /for\s*\(/gi, type: 'for_loop', extract: () => ({}) },
            { regex: /while\s*\(/gi, type: 'while_loop', extract: () => ({}) }
        ];
        
        patterns.forEach(pattern => {
            let match;
            while ((match = pattern.regex.exec(code)) !== null) {
                result.supportedBlocks.push({
                    type: pattern.type,
                    params: pattern.extract(match),
                    id: `block_${Date.now()}_${Math.random()}`
                });
            }
        });
        
        return result;
    },
    
    showConversionSummary(originalCode, blocks) {
        this.log('‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ', 'info');
        this.log('üìä CONVERSION SUMMARY', 'info');
        this.log(`Original: ${originalCode.length} chars`, 'info');
        this.log(`Converted: ${blocks.length} blocks`, 'success');
        this.log('‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ', 'info');
    },
    
    reconstructBlocks(blocks) {
        if (!window.workspace) {
            this.log('‚ùå Workspace not initialized', 'error');
            return;
        }
        
        let x = 50, y = 50;
        blocks.forEach(block => {
            const xml = this.createBlockXML(block, x, y);
            try {
                const dom = Blockly.utils.xml.textToDom(xml);
                Blockly.Xml.domToWorkspace(dom, workspace);
                this.log(`‚úì Added ${block.type}`, 'success');
                y += 100;
            } catch (e) {
                this.log(`‚úó Failed to add ${block.type}: ${e.message}`, 'error');
            }
        });
    },
    
    createBlockXML(block, x, y) {
        const attrs = ` x="${x}" y="${y}"`;
        const params = block.params || {};
        
        switch (block.type) {
            case 'when_key_pressed':
            case 'when_key_released':
                return `<xml><block type="${block.type}"${attrs}><field name="KEY">${params.key || 'KeyA'}</field></block></xml>`;
            case 'when_mouse_button_pressed':
                return `<xml><block type="${block.type}"${attrs}><field name="BUTTON">${params.button || 'LEFT'}</field></block></xml>`;
            case 'for_each_with_tag':
            case 'count_with_tag':
            case 'destroy_all_with_tag':
                return `<xml><block type="${block.type}"${attrs}><field name="TAG">${params.tag || 'default'}</field></block></xml>`;
            default:
                return `<xml><block type="${block.type}"${attrs}></block></xml>`;
        }
    },
    
    toggle() {
        this.isOpen = !this.isOpen;
        const panel = document.getElementById('terminalPanel');
        const btn = document.getElementById('terminalBtn');
        
        if (this.isOpen) {
            panel.classList.add('show');
            btn.classList.add('active');
            this.editor.focus();
        } else {
            panel.classList.remove('show');
            btn.classList.remove('active');
        }
    },
    
    toggleCollapse() {
        const panel = document.getElementById('terminalPanel');
        this.isCollapsed = !this.isCollapsed;
        panel.classList.toggle('collapsed', this.isCollapsed);
        document.getElementById('terminalToggle').textContent = this.isCollapsed ? '‚ñ≤' : '‚ñº';
    },
    
    switchTab(tab) {
        this.currentTab = tab;
        document.querySelectorAll('.terminal-tab').forEach(t => t.classList.remove('active'));
        document.querySelector(`[data-tab="${tab}"]`).classList.add('active');
        
        const output = document.getElementById('terminalOutput');
        const input = document.getElementById('terminalInput');
        
        if (tab === 'output') {
            output.style.display = 'block';
            input.classList.remove('show');
        } else {
            output.style.display = 'none';
            input.classList.add('show');
            this.editor.focus();
        }
    },
    
    log(message, type = 'info') {
        const output = document.getElementById('terminalOutput');
        const time = new Date().toLocaleTimeString();
        const typeClass = `terminal-${type}`;
        const line = document.createElement('div');
        line.className = typeClass;
        line.textContent = `[${time}] ${message}`;
        output.appendChild(line);
        output.scrollTop = output.scrollHeight;
    },
    
    clear() {
        document.getElementById('terminalOutput').innerHTML = '';
        this.log('Terminal cleared', 'info');
    },
    
    previewCode() {
        const js = this.editor.value.trim();
        const css = this.cssEditor.value.trim();
        const html = this.htmlEditor.value.trim();
        
        if (!js && !css && !html) {
            this.log('‚ö†Ô∏è Please enter at least JavaScript code', 'warn');
            return;
        }
        
        const preview = document.getElementById('structurePreviewModal');
        const content = document.getElementById('previewContent');
        
        let preview_html = '';
        
        if (js) {
            preview_html += 'üìù JAVASCRIPT:\n';
            preview_html += '‚îÄ'.repeat(40) + '\n';
            preview_html += js + '\n\n';
        }
        
        if (css) {
            preview_html += 'üé® CSS:\n';
            preview_html += '‚îÄ'.repeat(40) + '\n';
            preview_html += css + '\n\n';
        }
        
        if (html) {
            preview_html += 'üìÑ HTML:\n';
            preview_html += '‚îÄ'.repeat(40) + '\n';
            preview_html += html + '\n\n';
        }
        
        const parsed = this.advancedParse(js);
        if (parsed.supportedBlocks.length > 0) {
            preview_html += 'üß© DETECTED BLOCKS:\n';
            preview_html += '‚îÄ'.repeat(40) + '\n';
            parsed.supportedBlocks.forEach((block, idx) => {
                preview_html += `${idx + 1}. ${block.type}\n`;
                preview_html += `   Params: ${JSON.stringify(block.params)}\n`;
            });
        }
        
        content.textContent = preview_html;
        preview.style.display = 'block';
        this.log('üìä Structure preview displayed', 'info');
    },

    parseLupifyCode(code) {
        const result = { supportedBlocks: [], warnings: [], errors: [] };
        let blockIndex = 0;

        const lines = code.split('\n');
        for (const line of lines) {
            if (line.match(/onKeyPressed\s*\(/i)) {
                const keyMatch = line.match(/["'`](.*?)["'`]/);
                result.supportedBlocks.push({ type: 'on_key_pressed', key: keyMatch ? keyMatch[1] : 'KeyA', id: `key_${blockIndex++}` });
            } else if (line.match(/onMouseButtonPressed\s*\(/i)) {
                const buttonMatch = line.match(/["'`](.*?)["'`]/);
                result.supportedBlocks.push({ type: 'when_mouse_button_pressed', button: buttonMatch ? buttonMatch[1].toUpperCase() : 'LEFT', id: `mouse_${blockIndex++}` });
            } else if (line.match(/forEachWithTag\s*\(/i)) {
                const tagMatch = line.match(/["'`]([^"'`]+)["'`]/);
                if (tagMatch) {
                    result.supportedBlocks.push({ type: 'for_each_with_tag', tag: tagMatch[1], id: `loop_${blockIndex++}` });
                }
            } else if (line.match(/countWithTag\s*\(/i)) {
                const tagMatch = line.match(/["'`]([^"'`]+)["'`]/);
                if (tagMatch) {
                    result.supportedBlocks.push({ type: 'count_with_tag', tag: tagMatch[1], id: `count_${blockIndex++}` });
                }
            } else if (line.match(/destroyAllWithTag\s*\(/i)) {
                const tagMatch = line.match(/["'`]([^"'`]+)["'`]/);
                if (tagMatch) {
                    result.supportedBlocks.push({ type: 'destroy_all_with_tag', tag: tagMatch[1], id: `destroy_${blockIndex++}` });
                }
            } else if (line.match(/createHitbox\s*\(/i)) {
                result.supportedBlocks.push({ type: 'create_hitbox', id: `hitbox_${blockIndex++}` });
            } else if (line.match(/dealDamage\s*\(/i)) {
                result.supportedBlocks.push({ type: 'deal_damage', id: `damage_${blockIndex++}` });
            }
        }

        if (result.supportedBlocks.length === 0) {
            result.warnings.push('‚ö†Ô∏è No recognizable Lupify blocks found. Code may be custom logic.');
        }
        return result;
    },

    executeCommand(input) {
        if (!input.trim()) return;
        this.history.unshift(input);
        if (this.history.length > 50) this.history.pop();
        this.historyIndex = -1;

        try {
            this.log(`Executing: \`${input}\``, 'info');
            
            const parserResult = this.parseLupifyCode(input);
            if (parserResult.supportedBlocks.length > 0) {
                this.log(`‚úÖ Parsed ${parserResult.supportedBlocks.length} Lupify block(s).`, 'success');
            } else if (parserResult.warnings.length > 0) {
                this.log(`${parserResult.warnings.join(', ')}`, 'warn');
            } else {
                this.log(`‚ÑπÔ∏è Executed custom JS logic (see console for details).`, 'info');
            }

        } catch (e) {
            this.log(`‚ùå Error executing command: ${e.message}`, 'error');
        }
    }
};

        // ============ RUNTIME FUNCTIONS: AUDIO, PHYSICS, VISUAL EFFECTS ============

        // === AUDIO RUNTIME FUNCTIONS ===
        function playSound(soundId, volume = 1, loop = false) {
            const sound = AssetManager.assets.sounds.find(s => s.id == soundId);
            if (!sound) {
                console.warn(`Sound not found: ${soundId}`);
                return;
            }
            
            const audio = new Audio(sound.data);
            audio.volume = Math.max(0, Math.min(1, volume));
            audio.loop = loop;
            audio.play().catch(e => console.error('Audio play failed: ' + e.message));
            
            if (!window.activeSounds) window.activeSounds = new Map();
            window.activeSounds.set(soundId, audio);
        }

        function stopSound(soundId) {
            if (!window.activeSounds) return;
            
            if (soundId === 'ALL') {
                window.activeSounds.forEach(audio => audio.pause());
                window.activeSounds.clear();
            } else {
                const audio = window.activeSounds.get(soundId);
                if (audio) {
                    audio.pause();
                    window.activeSounds.delete(soundId);
                }
            }
        }

        function playMusic(musicId, fadeTime = 0) {
            const music = AssetManager.assets.sounds.find(s => s.id == musicId);
            if (!music) {
                console.warn(`Music not found: ${musicId}`);
                return;
            }
            
            if (window.currentMusic) {
                window.currentMusic.pause();
            }
            
            const audio = new Audio(music.data);
            audio.loop = true;
            audio.volume = fadeTime > 0 ? 0 : 1;
            
            audio.play().catch(e => console.error('Music play failed: ' + e.message));
            
            if (fadeTime > 0) {
                const steps = 50;
                const increment = 1 / steps;
                const interval = (fadeTime * 1000) / steps;
                
                let currentStep = 0;
                const fadeInterval = setInterval(() => {
                    if (currentStep >= steps) {
                        clearInterval(fadeInterval);
                        audio.volume = 1;
                        return;
                    }
                    audio.volume = currentStep * increment;
                    currentStep++;
                }, interval);
            }
            
            window.currentMusic = audio;
        }

        // === PHYSICS RUNTIME FUNCTIONS ===
        function applyForce(entity, forceX, forceY) {
            if (!entity) return;
            
            entity.velocityX = (entity.velocityX || 0) + forceX;
            entity.velocityY = (entity.velocityY || 0) + forceY;
            
            console.log(`Applied force (${forceX}, ${forceY}) to entity`);
        }

        function isGrounded(entity, checkDistance = 5) {
            if (!entity || !PreviewManager.runtime) return false;
            
            const entities = PreviewManager.runtime.entities || [];
            const checkY = entity.y + entity.height;
            
            const grounded = entities.some(other => {
                if (other === entity) return false;
                if (!other.tags || !other.tags.includes('solid')) return false;
                
                const horizontalOverlap = 
                    entity.x < other.x + other.width &&
                    entity.x + entity.width > other.x;
                
                const verticalProximity = 
                    checkY >= other.y - checkDistance &&
                    checkY <= other.y + checkDistance;
                
                return horizontalOverlap && verticalProximity;
            });
            
            return grounded;
        }

        function raycast(fromX, fromY, toX, toY, tagFilter = "") {
            if (!PreviewManager.runtime) return null;
            
            const entities = PreviewManager.runtime.entities || [];
            let closestHit = null;
            let closestDistance = Infinity;
            
            entities.forEach(entity => {
                if (tagFilter && (!entity.tags || !entity.tags.includes(tagFilter))) return;
                
                const intersects = lineIntersectsRect(
                    fromX, fromY, toX, toY,
                    entity.x, entity.y, entity.width, entity.height
                );
                
                if (intersects) {
                    const dist = Math.sqrt(
                        Math.pow(entity.x - fromX, 2) + 
                        Math.pow(entity.y - fromY, 2)
                    );
                    
                    if (dist < closestDistance) {
                        closestDistance = dist;
                        closestHit = entity;
                    }
                }
            });
            
            return closestHit;
        }

        function lineIntersectsRect(x1, y1, x2, y2, rx, ry, rw, rh) {
            const left = lineIntersectsLine(x1, y1, x2, y2, rx, ry, rx, ry + rh);
            const right = lineIntersectsLine(x1, y1, x2, y2, rx + rw, ry, rx + rw, ry + rh);
            const top = lineIntersectsLine(x1, y1, x2, y2, rx, ry, rx + rw, ry);
            const bottom = lineIntersectsLine(x1, y1, x2, y2, rx, ry + rh, rx + rw, ry + rh);
            
            return left || right || top || bottom;
        }

        function lineIntersectsLine(x1, y1, x2, y2, x3, y3, x4, y4) {
            const denom = ((y4 - y3) * (x2 - x1)) - ((x4 - x3) * (y2 - y1));
            if (denom === 0) return false;
            
            const ua = (((x4 - x3) * (y1 - y3)) - ((y4 - y3) * (x1 - x3))) / denom;
            const ub = (((x2 - x1) * (y1 - y3)) - ((y2 - y1) * (x1 - x3))) / denom;
            
            return (ua >= 0 && ua <= 1) && (ub >= 0 && ub <= 1);
        }

        // === VISUAL EFFECTS RUNTIME FUNCTIONS ===
        function setOpacity(entity, opacity) {
            if (!entity) return;
            entity.opacity = Math.max(0, Math.min(1, opacity));
        }

        function flipSprite(entity, direction) {
            if (!entity) return;
            
            switch(direction) {
                case 'H':
                    entity.flipH = !entity.flipH;
                    break;
                case 'V':
                    entity.flipV = !entity.flipV;
                    break;
                case 'BOTH':
                    entity.flipH = !entity.flipH;
                    entity.flipV = !entity.flipV;
                    break;
                case 'NONE':
                    entity.flipH = false;
                    entity.flipV = false;
                    break;
            }
        }

        function cameraShake(intensity = 10, duration = 0.5) {
            if (!PreviewManager.runtime || !PreviewManager.runtime.camera) return;
            
            const camera = PreviewManager.runtime.camera;
            const startTime = Date.now();
            const totalDuration = duration * 1000;
            
            const originalX = camera.x || 0;
            const originalY = camera.y || 0;
            
            const shakeInterval = setInterval(() => {
                const elapsed = Date.now() - startTime;
                
                if (elapsed >= totalDuration) {
                    camera.x = originalX;
                    camera.y = originalY;
                    clearInterval(shakeInterval);
                    return;
                }
                
                const progress = 1 - (elapsed / totalDuration);
                camera.x = originalX + (Math.random() - 0.5) * intensity * progress;
                camera.y = originalY + (Math.random() - 0.5) * intensity * progress;
            }, 16);
        }

        // === GAME STATE RUNTIME FUNCTIONS ===
        function pauseGame() {
            if (PreviewManager.runtime) {
                PreviewManager.runtime.isPaused = true;
                console.log('‚è∏Ô∏è Game paused');
            }
        }

        function resumeGame() {
            if (PreviewManager.runtime) {
                PreviewManager.runtime.isPaused = false;
                console.log('‚ñ∂Ô∏è Game resumed');
            }
        }

        function loadScene(sceneName, preserveState = true) {
            if (!PreviewManager.runtime) return;
            
            const savedState = preserveState ? {
                score: PreviewManager.runtime.gameState.score,
                health: PreviewManager.runtime.gameState.health,
                lives: PreviewManager.runtime.gameState.lives,
                inventory: {...(PreviewManager.runtime.gameState.inventory || {})}
            } : null;
            
            PreviewManager.runtime.entities = [];
            
            if (savedState) {
                PreviewManager.runtime.gameState.score = savedState.score;
                PreviewManager.runtime.gameState.health = savedState.health;
                PreviewManager.runtime.gameState.lives = savedState.lives;
                PreviewManager.runtime.gameState.inventory = savedState.inventory;
            }
            
            const handlers = PreviewManager.runtime.eventHandlers && PreviewManager.runtime.eventHandlers.onSceneLoad && PreviewManager.runtime.eventHandlers.onSceneLoad[sceneName];
            if (handlers) {
                handlers.forEach(fn => {
                    try {
                        fn();
                    } catch (error) {
                        console.error(`Scene load error: ${error.message}`);
                    }
                });
            }
            
            console.log(`üé¨ Loaded scene: ${sceneName}`);
        }

        function gameOver(showScore = true) {
            if (!PreviewManager.runtime) return;
            
            PreviewManager.runtime.isPaused = true;
            
            if (showScore) {
                const score = PreviewManager.runtime.gameState.score || 0;
                console.log(`üíÄ Game Over - Score: ${score}`);
            } else {
                console.log('üíÄ Game Over');
            }
        }

        function restartLevel() {
            if (PreviewManager) {
                PreviewManager.restart();
            }
        }

        // === COMBAT RUNTIME FUNCTIONS ===
        function dealDamage(target, damageAmount, applyKnockback = true) {
            if (!target) return;
            
            target.health = (target.health || 100) - damageAmount;
            
            if (applyKnockback) {
                target.velocityX = (target.velocityX || 0) + (Math.random() - 0.5) * 200;
                target.velocityY = (target.velocityY || 0) - 100;
            }
            
            target.damageFlash = Date.now();
            
            console.log(`‚öîÔ∏è Dealt ${damageAmount} damage to entity`);
            
            if (target.health <= 0) {
                const tag = target.tags && target.tags[0];
                if (tag && PreviewManager.runtime && PreviewManager.runtime.eventHandlers && PreviewManager.runtime.eventHandlers.onObjectDestroyed && PreviewManager.runtime.eventHandlers.onObjectDestroyed[tag]) {
                    PreviewManager.runtime.eventHandlers.onObjectDestroyed[tag].forEach(fn => fn());
                }
            }
        }

        function createHitbox(parentEntity, width, height, duration, offsetX = 0, offsetY = 0) {
            if (!parentEntity || !PreviewManager.runtime) return;
            
            const hitbox = {
                id: Date.now() + Math.random(),
                type: 'hitbox',
                x: parentEntity.x + offsetX,
                y: parentEntity.y + offsetY,
                width: width,
                height: height,
                parent: parentEntity,
                offsetX: offsetX,
                offsetY: offsetY,
                tags: ['hitbox'],
                color: 'rgba(255, 0, 0, 0.3)',
                createdAt: Date.now(),
                duration: duration * 1000,
                isHitbox: true
            };
            
            PreviewManager.runtime.entities.push(hitbox);
            
            setTimeout(() => {
                PreviewManager.runtime.entities = PreviewManager.runtime.entities.filter(e => e !== hitbox);
            }, duration * 1000);
            
            console.log(`ü•ä Created hitbox (${width}x${height}) for ${duration}s`);
            
            return hitbox;
        }

        // === ADDITIONAL ESSENTIAL RUNTIME FUNCTIONS ===
        function setZLayer(entity, layer) {
            if (!entity) return;
            entity.zLayer = layer;
            console.log(`üìê Set Z-Layer to ${layer}`);
        }
        
        // === LUPISCRIPT V1 ENGINE ===
        const LupiScript = {
            // ‚úÖ PARSE: Convert human text ‚Üí block definition
            parse(code) {
                const lines = code.trim().split('\n').filter(l => l.trim() && !l.trim().startsWith('//'));
                if (lines.length === 0) throw new Error("Empty script");

                // Line 1: block name "Display [field]"
                const blockLine = lines[0].match(/^block\s+(\S+)\s+"(.+)"$/);
                if (!blockLine) throw new Error("Line 1: Use 'block name \"Display text\"'");
                
                const block = {
                    id: blockLine[1],
                    displayName: blockLine[2],
                    category: "üß± Custom Blocks",
                    color: "#FF6B6B",
                    fields: [],
                    inputs: [],
                    output: null,
                    codeTemplate: "",
                    icon: "",
                    tooltip: ""
                };

                // Parse remaining lines
                for (let i = 1; i < lines.length; i++) {
                    const line = lines[i].trim();
                    
                    if (line.startsWith('category ')) {
                        block.category = line.substring(9).trim().replace(/^["']|["']$/g, '');
                    } 
                    else if (line.startsWith('color ')) {
                        block.color = line.substring(6).trim();
                    } 
                    else if (line.startsWith('icon ')) {
                        block.icon = line.substring(5).trim();
                    } 
                    else if (line.startsWith('tooltip ')) {
                        block.tooltip = line.substring(8).trim();
                    } 
                    else if (line.startsWith('field ')) {
                        const fieldParts = line.substring(6).trim().split(/\s+/);
                        const id = fieldParts[0];
                        const type = fieldParts[1];
                        const defaultValue = fieldParts[2] || '';
                        
                        const field = { id, type, defaultValue, constraints: {} };
                        
                        // Parse constraints (min, max, choices)
                        for (let j = 3; j < fieldParts.length; j++) {
                            if (fieldParts[j] === 'min' && fieldParts[j + 1]) {
                                field.constraints.min = parseFloat(fieldParts[j + 1]);
                                j++;
                            } else if (fieldParts[j] === 'max' && fieldParts[j + 1]) {
                                field.constraints.max = parseFloat(fieldParts[j + 1]);
                                j++;
                            } else if (type === 'choice') {
                                // For choice fields: field name choice label1 value1 label2 value2
                                if (!field.constraints.choices) field.constraints.choices = [];
                                field.constraints.choices.push([fieldParts[j], fieldParts[j + 1] || fieldParts[j]]);
                                j++;
                            }
                        }
                        
                        block.fields.push(field);
                    } 
                    else if (line.startsWith('input ')) {
                        const match = line.match(/input\s+(\S+)\s+(\S+)(?:\s+"([^"]+)")?/);
                        if (match) {
                            block.inputs.push({ 
                                id: match[1], 
                                type: match[2], 
                                label: match[3] || match[1]
                            });
                        }
                    } 
                    else if (line.startsWith('output ')) {
                        block.output = line.substring(7).trim();
                    } 
                    else if (line.startsWith('code ')) {
                        block.codeTemplate = line.substring(5).trim();
                    }
                }

                if (!block.codeTemplate) throw new Error("Missing 'code' line");
                return block;
            },

            // ‚úÖ REGISTER: Turn parsed block into real Blockly block
            register(blockDef) {
                if (typeof Blockly === 'undefined') {
                    throw new Error('Blockly is not loaded yet');
                }

                // Block definition
                Blockly.Blocks[blockDef.id] = {
                    init: function() {
                        // Build the display text by replacing [field] placeholders
                        let displayText = blockDef.displayName;
                        const dummyInput = this.appendDummyInput();
                        
                        // Add icon if specified
                        if (blockDef.icon) {
                            dummyInput.appendField(blockDef.icon);
                        }
                        
                        // Split display text and insert fields
                        const parts = displayText.split(/(\[[^\]]+\])/);
                        parts.forEach(part => {
                            if (part.startsWith('[') && part.endsWith(']')) {
                                const fieldName = part.slice(1, -1);
                                const field = blockDef.fields.find(f => f.id === fieldName);
                                
                                if (field) {
                                    if (field.type === 'number') {
                                        const numField = new Blockly.FieldNumber(
                                            parseFloat(field.defaultValue) || 0,
                                            field.constraints.min,
                                            field.constraints.max
                                        );
                                        dummyInput.appendField(numField, fieldName);
                                    } 
                                    else if (field.type === 'checkbox') {
                                        const checkField = new Blockly.FieldCheckbox(
                                            field.defaultValue === 'true' || field.defaultValue === '1'
                                        );
                                        dummyInput.appendField(checkField, fieldName);
                                    } 
                                    else if (field.type === 'color') {
                                        const colorField = new Blockly.FieldColour(field.defaultValue || '#ff0000');
                                        dummyInput.appendField(colorField, fieldName);
                                    }
                                    else if (field.type === 'choice') {
                                        const choices = field.constraints.choices || [[field.defaultValue, field.defaultValue]];
                                        const dropdown = new Blockly.FieldDropdown(choices);
                                        dummyInput.appendField(dropdown, fieldName);
                                    }
                                    else if (field.type.startsWith('asset:')) {
                                        const assetType = field.type.split(':')[1];
                                        const assets = window.LUPIFORGE?.assets?.[assetType + 's'] || [];
                                        const options = assets.length > 0 
                                            ? assets.map(a => [a.name || a.id, a.id])
                                            : [['-- No ' + assetType + 's --', '']];
                                        const dropdown = new Blockly.FieldDropdown(options);
                                        dummyInput.appendField(dropdown, fieldName);
                                    }
                                    else if (field.type.startsWith('tags:')) {
                                        const tags = ['player', 'enemy', 'collectible', 'obstacle', 'npc'];
                                        const options = tags.map(t => [t, t]);
                                        const dropdown = new Blockly.FieldDropdown(options);
                                        dummyInput.appendField(dropdown, fieldName);
                                    }
                                    else {
                                        // Default: text input
                                        const textField = new Blockly.FieldTextInput(field.defaultValue || '');
                                        dummyInput.appendField(textField, fieldName);
                                    }
                                } else {
                                    dummyInput.appendField(part);
                                }
                            } else if (part.trim()) {
                                dummyInput.appendField(part);
                            }
                        });

                        // Add inputs (for connecting other blocks)
                        blockDef.inputs.forEach(input => {
                            if (input.type.toLowerCase() === 'statement') {
                                this.appendStatementInput(input.id)
                                    .setCheck(null)
                                    .appendField(input.label);
                            } else {
                                this.appendValueInput(input.id)
                                    .setCheck(input.type)
                                    .appendField(input.label);
                            }
                        });

                        // Set output or statement connections
                        if (blockDef.output) {
                            this.setOutput(true, blockDef.output);
                        } else {
                            this.setPreviousStatement(true);
                            this.setNextStatement(true);
                        }
                        
                        this.setColour(blockDef.color);
                        
                        if (blockDef.tooltip) {
                            this.setTooltip(blockDef.tooltip);
                        }
                    }
                };

                // Code generator
                Blockly.JavaScript.forBlock[blockDef.id] = function(block) {
                    let code = blockDef.codeTemplate;
                    
                    // Replace [field_id] with actual values
                    blockDef.fields.forEach(field => {
                        const value = block.getFieldValue(field.id);
                        if (field.type === 'number') {
                            code = code.replaceAll(`[${field.id}]`, value);
                        } else if (field.type === 'checkbox') {
                            code = code.replaceAll(`[${field.id}]`, value === 'TRUE' ? 'true' : 'false');
                        } else {
                            code = code.replaceAll(`[${field.id}]`, `"${value}"`);
                        }
                    });

                    // Replace [input_id] with connected code
                    blockDef.inputs.forEach(input => {
                        if (input.type.toLowerCase() === 'statement') {
                            const statements = Blockly.JavaScript.statementToCode(block, input.id);
                            code = code.replaceAll(`[${input.id}]`, statements || '');
                        } else {
                            const inputValue = Blockly.JavaScript.valueToCode(
                                block, 
                                input.id, 
                                Blockly.JavaScript.ORDER_NONE
                            ) || 'null';
                            code = code.replaceAll(`[${input.id}]`, inputValue);
                        }
                    });

                    return blockDef.output ? [code, Blockly.JavaScript.ORDER_FUNCTION_CALL] : code + ';\n';
                };
                
                console.log(`‚úÖ LupiScript block "${blockDef.id}" registered`);
            },

            // ‚úÖ SUBMIT: Parse + register + update toolbox
            submit() {
                try {
                    const code = document.getElementById('lupiEditor').value;
                    if (!code.trim()) {
                        throw new Error('Please enter LupiScript code');
                    }
                    
                    const blockDef = this.parse(code);
                    this.register(blockDef);
                    
                    // Add to toolbox
                    this.addToToolbox(blockDef);
                    
                    // Save to localStorage
                    this.saveBlock(blockDef);
                    
                    // Update workspace to refresh toolbox
                    if (window.workspace) {
                        window.workspace.updateToolbox(document.getElementById('toolbox'));
                    }
                    
                    document.getElementById('lupiStatus').innerHTML = 
                        `‚úÖ Block <strong>"${blockDef.id}"</strong> created in category "${blockDef.category}"`;
                    document.getElementById('lupiStatus').style.color = '#2ecc71';
                    
                    // Show preview
                    this.showPreview(blockDef);
                    
                } catch (e) {
                    document.getElementById('lupiStatus').textContent = `‚ùå ${e.message}`;
                    document.getElementById('lupiStatus').style.color = '#e74c3c';
                    console.error('LupiScript error:', e);
                }
            },
            
            // Add block to toolbox
            addToToolbox(blockDef) {
                const toolbox = document.getElementById('toolbox');
                let category = toolbox.querySelector(`category[name="${blockDef.category}"]`);
                
                // Create category if it doesn't exist
                if (!category) {
                    category = document.createElement('category');
                    category.setAttribute('name', blockDef.category);
                    category.setAttribute('colour', blockDef.color);
                    toolbox.appendChild(category);
                }
                
                // Check if block already exists
                const existing = category.querySelector(`block[type="${blockDef.id}"]`);
                if (!existing) {
                    const blockXML = document.createElement('block');
                    blockXML.setAttribute('type', blockDef.id);
                    category.appendChild(blockXML);
                }
            },
            
            // Save block definition to localStorage
            saveBlock(blockDef) {
                const savedBlocks = JSON.parse(localStorage.getItem('lupiforge_custom_blocks') || '[]');
                const existing = savedBlocks.findIndex(b => b.id === blockDef.id);
                
                if (existing >= 0) {
                    savedBlocks[existing] = blockDef;
                } else {
                    savedBlocks.push(blockDef);
                }
                
                localStorage.setItem('lupiforge_custom_blocks', JSON.stringify(savedBlocks));
            },
            
            // Load saved blocks on startup
            loadSavedBlocks() {
                try {
                    const savedBlocks = JSON.parse(localStorage.getItem('lupiforge_custom_blocks') || '[]');
                    savedBlocks.forEach(blockDef => {
                        try {
                            this.register(blockDef);
                            this.addToToolbox(blockDef);
                        } catch (e) {
                            console.error(`Failed to load block ${blockDef.id}:`, e);
                        }
                    });
                    
                    if (savedBlocks.length > 0) {
                        console.log(`‚úÖ Loaded ${savedBlocks.length} custom LupiScript blocks`);
                    }
                } catch (e) {
                    console.error('Failed to load saved blocks:', e);
                }
            },
            
            // Show block preview
            showPreview(blockDef) {
                const preview = document.getElementById('lupiPreview');
                preview.innerHTML = `
                    <div style="color:#4ec9b0; font-weight:bold; margin-bottom:8px;">üì¶ Block Preview</div>
                    <div style="background:${blockDef.color}; color:white; padding:8px; border-radius:4px; margin-bottom:8px;">
                        ${blockDef.icon} ${blockDef.displayName}
                    </div>
                    <div style="font-size:11px; color:#95a5a6;">
                        <strong>ID:</strong> ${blockDef.id}<br>
                        <strong>Category:</strong> ${blockDef.category}<br>
                        <strong>Fields:</strong> ${blockDef.fields.length}<br>
                        <strong>Inputs:</strong> ${blockDef.inputs.length}<br>
                        ${blockDef.output ? `<strong>Output:</strong> ${blockDef.output}<br>` : ''}
                        ${blockDef.tooltip ? `<strong>Tooltip:</strong> ${blockDef.tooltip}` : ''}
                    </div>
                `;
            }
        };
        
        window.LupiScript = LupiScript;

        // Game Preview Manager
        const EnhancedPreviewManager = {
    isRunning: false,
    gameLoop: null,
    runtime: null,
    performanceMonitor: {
        fps: 60,
        frameCount: 0,
        lastTime: 0,
        memory: 0,
        entities: 0,
        draws: 0
    },
    viewport: {
        zoom: 1,
        offsetX: 0,
        offsetY: 0,
        isDragging: false,
        dragStartX: 0,
        dragStartY: 0
    },
    
    init() {
        this.attachEvents();
        this.initializeRuntime();
        this.setupViewportControls();
    },
    
    attachEvents() {
        document.getElementById('playGame').addEventListener('click', () => this.play());
        document.getElementById('stopGame').addEventListener('click', () => this.stop());
        document.getElementById('restartGame').addEventListener('click', () => this.restart());
        document.getElementById('closePreview').addEventListener('click', () => this.close());
        document.getElementById('toggleDebug').addEventListener('click', () => this.toggleDebug());
        
        this.addZoomControls();
    },
    
    setupViewportControls() {
        const canvas = document.getElementById('gameCanvas');
        
        canvas.addEventListener('mousedown', (e) => {
            if (e.button === 1 || (e.ctrlKey && e.button === 0)) {
                e.preventDefault();
                this.viewport.isDragging = true;
                this.viewport.dragStartX = e.clientX - this.viewport.offsetX;
                this.viewport.dragStartY = e.clientY - this.viewport.offsetY;
                canvas.style.cursor = 'grabbing';
            }
        });
        
        canvas.addEventListener('mousemove', (e) => {
            if (this.viewport.isDragging) {
                this.viewport.offsetX = e.clientX - this.viewport.dragStartX;
                this.viewport.offsetY = e.clientY - this.viewport.dragStartY;
            }
        });
        
        canvas.addEventListener('mouseup', (e) => {
            if (e.button === 1 || e.button === 0) {
                this.viewport.isDragging = false;
                canvas.style.cursor = 'default';
            }
        });
        
        canvas.addEventListener('wheel', (e) => {
            e.preventDefault();
            const delta = e.deltaY > 0 ? 0.9 : 1.1;
            this.viewport.zoom = Math.max(0.1, Math.min(5, this.viewport.zoom * delta));
            showToast(`Zoom: ${Math.round(this.viewport.zoom * 100)}%`);
        });
    },
    
    addZoomControls() {
        const controls = document.querySelector('.preview-controls');
        if (!controls) return;
        
        const zoomIn = document.createElement('button');
        zoomIn.className = 'preview-btn';
        zoomIn.textContent = 'üîç+';
        zoomIn.title = 'Zoom In';
        zoomIn.addEventListener('click', () => {
            this.viewport.zoom = Math.min(5, this.viewport.zoom * 1.2);
            showToast(`Zoom: ${Math.round(this.viewport.zoom * 100)}%`);
        });
        
        const zoomOut = document.createElement('button');
        zoomOut.className = 'preview-btn';
        zoomOut.textContent = 'üîç-';
        zoomOut.title = 'Zoom Out';
        zoomOut.addEventListener('click', () => {
            this.viewport.zoom = Math.max(0.1, this.viewport.zoom * 0.8);
            showToast(`Zoom: ${Math.round(this.viewport.zoom * 100)}%`);
        });
        
        const resetZoom = document.createElement('button');
        resetZoom.className = 'preview-btn';
        resetZoom.textContent = 'üîç Reset';
        resetZoom.title = 'Reset Zoom';
        resetZoom.addEventListener('click', () => {
            this.viewport.zoom = 1;
            this.viewport.offsetX = 0;
            this.viewport.offsetY = 0;
            showToast('Zoom reset');
        });
        
        controls.appendChild(zoomIn);
        controls.appendChild(zoomOut);
        controls.appendChild(resetZoom);
    },
    
    initializeRuntime() {
        this.runtime = new GameRuntime();
    },
    
    play() {
        const panel = document.getElementById('previewPanel');
        panel.classList.remove('collapsed');
        
        if (!this.isRunning) {
            this.isRunning = true;
            this.startGame();
            
            document.getElementById('playGame').disabled = true;
            document.getElementById('stopGame').disabled = false;
            document.getElementById('restartGame').disabled = false;
            
            showToast('‚ñ∂Ô∏è Preview started');
            EnhancedDebugConsole.clear();
            EnhancedDebugConsole.log('Game started');
            
            this.enableRealTimeUpdates();
        }
    },
    
    stop() {
        this.isRunning = false;
        if (this.gameLoop) {
            cancelAnimationFrame(this.gameLoop);
        }
        
        this.runtime.stop();
        
        document.getElementById('playGame').disabled = false;
        document.getElementById('stopGame').disabled = true;
        document.getElementById('restartGame').disabled = true;
        
        showToast('‚èπÔ∏è Preview stopped');
        EnhancedDebugConsole.log('Game stopped');
        
        this.disableRealTimeUpdates();
    },
    
    restart() {
        EnhancedDebugConsole.log('Restarting game...');
        this.stop();
        setTimeout(() => this.play(), 100);
    },
    
    close() {
        this.stop();
        document.getElementById('previewPanel').classList.add('collapsed');
    },
    
    toggleDebug() {
        window.debugOverlays = window.debugOverlays || { enabled: false };
        window.debugOverlays.enabled = !window.debugOverlays.enabled;
        
        const btn = document.getElementById('toggleDebug');
        btn.style.background = window.debugOverlays.enabled ? '#27ae60' : '#f39c12';
        btn.textContent = window.debugOverlays.enabled ? 'üêõ Debug ‚úì' : 'üêõ Debug';
        
        const perfOverlay = document.getElementById('performanceOverlay');
        if (perfOverlay) {
            perfOverlay.style.display = window.debugOverlays.enabled ? 'block' : 'none';
        }
        
        showToast(window.debugOverlays.enabled ? 'Debug overlays ON' : 'Debug overlays OFF');
    },
    
    enableRealTimeUpdates() {
        if (!window.workspace) return;
        
        this.workspaceChangeListener = workspace.addChangeListener((event) => {
            if (event.type === Blockly.Events.UI) return;
            
            clearTimeout(this.updateTimeout);
            this.updateTimeout = setTimeout(() => {
                this.hotReloadCode();
            }, 500);
        });
    },
    
    disableRealTimeUpdates() {
        if (this.workspaceChangeListener && window.workspace) {
            workspace.removeChangeListener(this.workspaceChangeListener);
        }
    },
    
    hotReloadCode() {
        if (!this.isRunning) return;
        
        try {
            const code = Blockly.JavaScript.workspaceToCode(workspace);
            
            const savedState = {
                score: this.runtime.gameState.score,
                health: this.runtime.gameState.health,
                lives: this.runtime.gameState.lives,
                entities: [...this.runtime.entities]
            };
            
            this.runtime.compileGameCode(code);
            
            this.runtime.gameState.score = savedState.score;
            this.runtime.gameState.health = savedState.health;
            this.runtime.gameState.lives = savedState.lives;
            
            EnhancedDebugConsole.log('üîÑ Code hot-reloaded', 'success');
            showToast('üîÑ Code updated');
        } catch (error) {
            EnhancedDebugConsole.error('Hot reload failed: ' + error.message);
        }
    },
    
    startGame() {
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const code = Blockly.JavaScript.workspaceToCode(workspace);
        
        this.runtime.initialize(canvas, ctx, code);
        
        window.debugOverlaySystem = new DebugOverlaySystem(this.runtime.renderSystem || {}, this.runtime.entityManager || {}, canvas);
        
        if (EnhancedAssetManager.backgroundAsset) {
            this.runtime.setBackground(EnhancedAssetManager.backgroundAsset.data);
        }
        
        this.createPerformanceOverlay();
        
        let lastTime = performance.now();
        const loop = (currentTime) => {
            if (!this.isRunning) return;
            
            const deltaTime = (currentTime - lastTime) / 1000;
            lastTime = currentTime;
            
            try {
                this.updatePerformanceStats(deltaTime);
                
                this.runtime.update(deltaTime);
                
                if (window.debugOverlaySystem) {
                    window.debugOverlaySystem.update(deltaTime);
                }
                
                ctx.save();
                ctx.translate(this.viewport.offsetX, this.viewport.offsetY);
                ctx.scale(this.viewport.zoom, this.viewport.zoom);
                
                this.runtime.render();
                
                ctx.restore();
                
                if (window.debugOverlaySystem) {
                    window.debugOverlaySystem.render();
                }
                
                this.renderPerformanceOverlay(ctx);
                
                document.getElementById('previewScore').textContent = this.runtime.getScore();
                document.getElementById('previewFPS').textContent = Math.round(this.performanceMonitor.fps);
            } catch (error) {
                EnhancedDebugConsole.error('Runtime Error: ' + error.message);
                console.error(error);
                this.stop();
                return;
            }
            
            this.gameLoop = requestAnimationFrame(loop);
        };
        
        this.gameLoop = requestAnimationFrame(loop);
    },
    
    createPerformanceOverlay() {
        let overlay = document.getElementById('performanceOverlay');
        if (overlay) return;
        
        overlay = document.createElement('div');
        overlay.id = 'performanceOverlay';
        overlay.style.cssText = `
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 10px;
            border-radius: 5px;
            font-family: monospace;
            font-size: 11px;
            z-index: 1000;
            display: ${window.debugOverlays?.enabled ? 'block' : 'none'};
        `;
        
        const content = document.querySelector('.preview-content');
        if (content) {
            content.appendChild(overlay);
        }
    },
    
    updatePerformanceStats(deltaTime) {
        this.performanceMonitor.frameCount++;
        this.performanceMonitor.fps = 1 / deltaTime;
        this.performanceMonitor.entities = this.runtime.entities.length;
        
        if (performance.memory) {
            this.performanceMonitor.memory = performance.memory.usedJSHeapSize / 1048576;
        }
    },
    
    renderPerformanceOverlay(ctx) {
        if (!window.debugOverlays?.enabled) return;
        
        const overlay = document.getElementById('performanceOverlay');
        if (!overlay) return;
        
        const stats = this.performanceMonitor;
        
        overlay.innerHTML = `
            <div style="font-weight: bold; margin-bottom: 5px;">‚ö° PERFORMANCE</div>
            <div>FPS: <span style="color: ${stats.fps > 50 ? '#27ae60' : '#e74c3c'}">${Math.round(stats.fps)}</span></div>
            <div>Entities: <span style="color: #3498db">${stats.entities}</span></div>
            <div>Memory: <span style="color: #f39c12">${stats.memory.toFixed(1)} MB</span></div>
            <div>Zoom: <span style="color: #9b59b6">${Math.round(this.viewport.zoom * 100)}%</span></div>
            <div style="margin-top: 5px; font-size: 10px; color: #95a5a6;">
                Ctrl+Drag to pan<br>
                Scroll to zoom
            </div>
        `;
    }
};

        // MANAGER ALIASES - Point old names to Enhanced versions
        const DebugConsole = EnhancedDebugConsole;
        const TerminalManager = EnhancedTerminalManager;
        const PreviewManager = EnhancedPreviewManager;
        const AssetManager = EnhancedAssetManager;

        // Achievement System
        const AchievementManager = {
            achievements: {
                first_game: { title: 'First Blood', desc: 'Create your first game', xp: 50, unlocked: false },
                ten_blocks: { title: 'Block Master', desc: 'Use 10+ blocks in a game', xp: 100, unlocked: false },
                first_save: { title: 'Saver', desc: 'Save your first game', xp: 25, unlocked: false },
                first_publish: { title: 'Publisher', desc: 'Publish your first game', xp: 200, unlocked: false },
                asset_upload: { title: 'Artist', desc: 'Upload your first asset', xp: 75, unlocked: false }
            },

            check(achievementId) {
                const achievement = this.achievements[achievementId];
                if (achievement && !achievement.unlocked) {
                    achievement.unlocked = true;
                    this.show(achievement.title, achievement.desc, achievement.xp);
                    this.save();
                    
                    console.log('Achievement unlocked:', achievementId, achievement);
                }
            },

            show(title, desc, xp) {
                const panel = document.getElementById('achievementPanel');
                document.getElementById('achievementTitle').textContent = title;
                document.getElementById('achievementDesc').textContent = desc;
                document.querySelector('.achievement-points').textContent = `+${xp} XP`;
                
                panel.classList.add('show');
                setTimeout(() => panel.classList.remove('show'), 4000);
            },

            save() {
                localStorage.setItem('lupiforge_achievements', JSON.stringify(this.achievements));
            },

            load() {
                const saved = localStorage.getItem('lupiforge_achievements');
                if (saved) {
                    this.achievements = JSON.parse(saved);
                }
            }
        };

        // Score Submission System
        const ScoreManager = {
            currentScore: 0,

            init() {
                document.getElementById('cancelScore').addEventListener('click', () => {
                    document.getElementById('scoreModal').classList.remove('show');
                });

                document.getElementById('submitScore').addEventListener('click', () => {
                    this.submitScore();
                });
            },

            show(score) {
                this.currentScore = score;
                document.getElementById('finalScore').textContent = score;
                document.getElementById('scoreModal').classList.add('show');
            },

            submitScore() {
                const playerName = document.getElementById('playerName').value.trim();
                if (!playerName) {
                    showToast('‚ùå Please enter your name!', true);
                    return;
                }

                const scoreData = {
                    player_name: playerName,
                    score: this.currentScore,
                    game_id: 'current_game',
                    timestamp: new Date().toISOString()
                };

                console.log('Score submitted:', scoreData);
                console.log('API Endpoint: POST /games/api/submit-score/');
                
                document.getElementById('scoreModal').classList.remove('show');
                showToast(`üèÜ Score ${this.currentScore} submitted!`);

                // Check for achievement
                if (this.currentScore > 1000) {
                    AchievementManager.check('high_scorer');
                }
            }
        };



        const AnimationPreviewRenderer = {
            imageCache: new Map(),

            getImage(spriteSheet) {
                if (!this.imageCache.has(spriteSheet)) {
                    const img = new Image();
                    img.crossOrigin = 'anonymous';
                    img.src = spriteSheet;
                    this.imageCache.set(spriteSheet, img);
                }
                return this.imageCache.get(spriteSheet);
            },

            renderFrame(canvas, animation, frameIndex) {
                const ctx = canvas.getContext('2d');
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                ctx.fillStyle = '#1a1a1a';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                const img = this.getImage(animation.spriteSheet);
                
                if (img.complete && img.naturalWidth > 0) {
                    const row = Math.floor(frameIndex / animation.framesPerRow);
                    const col = frameIndex % animation.framesPerRow;
                    
                    const srcX = col * animation.frameWidth;
                    const srcY = row * animation.frameHeight;
                    
                    const scale = Math.min(
                        canvas.width / animation.frameWidth,
                        canvas.height / animation.frameHeight
                    );
                    
                    const dstWidth = animation.frameWidth * scale;
                    const dstHeight = animation.frameHeight * scale;
                    const dstX = (canvas.width - dstWidth) / 2;
                    const dstY = (canvas.height - dstHeight) / 2;
                    
                    ctx.drawImage(img, srcX, srcY, animation.frameWidth, animation.frameHeight, dstX, dstY, dstWidth, dstHeight);
                    
                    if (animation.frameOffsets && animation.frameOffsets[frameIndex]) {
                        const offset = animation.frameOffsets[frameIndex];
                        const anchorX = dstX + (offset.centerX * scale);
                        const anchorY = dstY + (offset.bottomY * scale);
                        
                        ctx.strokeStyle = '#ff4444';
                        ctx.lineWidth = 2;
                        ctx.beginPath();
                        ctx.moveTo(anchorX - 8, anchorY);
                        ctx.lineTo(anchorX + 8, anchorY);
                        ctx.moveTo(anchorX, anchorY - 8);
                        ctx.lineTo(anchorX, anchorY + 8);
                        ctx.stroke();
                        
                        ctx.fillStyle = '#ff4444';
                        ctx.beginPath();
                        ctx.arc(anchorX, anchorY, 3, 0, Math.PI * 2);
                        ctx.fill();
                    }
                }
            },

            playAnimation(canvas, animation, duration = null) {
                const totalDuration = duration || (animation.totalFrames * animation.frameDuration);
                const startTime = performance.now();
                let lastFrameIndex = -1;
                
                const animate = (currentTime) => {
                    const elapsed = currentTime - startTime;
                    const progress = (elapsed % totalDuration) / totalDuration;
                    const frameIndex = Math.floor(progress * animation.totalFrames) % animation.totalFrames;
                    
                    if (frameIndex !== lastFrameIndex) {
                        this.renderFrame(canvas, animation, frameIndex);
                        lastFrameIndex = frameIndex;
                    }
                    
                    requestAnimationFrame(animate);
                };
                
                requestAnimationFrame(animate);
            }
        };

        const AnimationManager = {
            animations: {},
            activeAnimations: new Map(),

            addAnimation(animation) {
                this.animations[animation.id] = animation;
            },

            playAnimation(entityTag, animationName, options = {}) {
                const animation = Object.values(this.animations).find(a => a.name === animationName);
                
                if (!animation) {
                    console.warn(`Animation "${animationName}" not found`);
                    return;
                }
                
                const duration = options.duration || (animation.totalFrames * animation.frameDuration);
                const loop = options.loop !== false;
                const onFrame = options.onFrame || null;
                const playbackRate = options.playbackRate || 1;
                
                const startTime = performance.now();
                const animId = `${entityTag}-${animationName}-${Date.now()}`;
                let lastFrameIndex = -1;
                
                const animate = (currentTime) => {
                    const elapsed = (currentTime - startTime) * playbackRate;
                    const progress = loop ? (elapsed % duration) / duration : Math.min(elapsed / duration, 1);
                    const frameIndex = Math.floor(progress * animation.totalFrames) % animation.totalFrames;
                    
                    if (frameIndex !== lastFrameIndex && onFrame) {
                        onFrame(frameIndex, animation);
                        lastFrameIndex = frameIndex;
                    }
                    
                    if (!loop && elapsed >= duration) {
                        if (onFrame && lastFrameIndex !== animation.totalFrames - 1) {
                            onFrame(animation.totalFrames - 1, animation);
                        }
                        this.activeAnimations.delete(animId);
                        return;
                    }
                    
                    this.activeAnimations.set(animId, requestAnimationFrame(animate));
                };
                
                animate(startTime);
                return animId;
            },

            stopAnimation(animId) {
                const rafId = this.activeAnimations.get(animId);
                if (rafId) {
                    cancelAnimationFrame(rafId);
                    this.activeAnimations.delete(animId);
                }
            },

            showAnimationEditor(animation) {
                const modal = document.createElement('div');
                modal.className = 'modal show';
                modal.style.zIndex = '10000';
                
                let currentFrame = 0;
                
                const updatePreview = () => {
                    const canvas = modal.querySelector('#animPreviewCanvas');
                    AnimationPreviewRenderer.renderFrame(canvas, animation, currentFrame);
                };
                
                modal.innerHTML = `
                    <div class="modal-content" style="max-width: 800px;">
                        <h2>üé¨ ${animation.name} Animation Editor</h2>
                        
                        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin: 20px 0;">
                            <div>
                                <h4 style="color: #ccc; margin-bottom: 10px;">Preview</h4>
                                <canvas id="animPreviewCanvas" width="200" height="200" style="background: #0f3460; border: 1px solid #533483; border-radius: 4px; margin-bottom: 10px; display: block; margin-left: auto; margin-right: auto;"></canvas>
                                
                                <div style="display: flex; gap: 10px;">
                                    <button id="prevFrameBtn" style="flex: 1; padding: 8px; background: #533483; color: white; border: none; border-radius: 4px; cursor: pointer;">‚óÄ Prev</button>
                                    <button id="playPreviewBtn" style="flex: 1; padding: 8px; background: #27ae60; color: white; border: none; border-radius: 4px; cursor: pointer;">‚ñ∂ Play</button>
                                    <button id="nextFrameBtn" style="flex: 1; padding: 8px; background: #533483; color: white; border: none; border-radius: 4px; cursor: pointer;">Next ‚ñ∂</button>
                                </div>
                                
                                <div id="frameIndicator" style="text-align: center; color: #bbb; margin-top: 10px; font-size: 12px;">Frame 0 / ${animation.totalFrames}</div>
                            </div>
                            
                            <div>
                                <h4 style="color: #ccc; margin-bottom: 10px;">Settings</h4>
                                
                                <label style="display: block; margin-bottom: 15px; color: #ccc;">
                                    <div style="font-size: 12px; margin-bottom: 5px;">Animation Name</div>
                                    <input type="text" id="animNameEdit" value="${animation.name}" style="width: 100%; padding: 8px; border: 1px solid #533483; border-radius: 4px; background: #0f3460; color: white; box-sizing: border-box;" autocomplete="off">
                                    <small style="color: #aaa; font-size: 10px; margin-top: 3px; display: block;">Letters, numbers, spaces, and underscores</small>
                                </label>
                                
                                <label style="display: block; margin-bottom: 15px; color: #ccc;">
                                    <div style="font-size: 12px; margin-bottom: 5px;">Frame Duration (ms)</div>
                                    <input type="number" id="frameDurationEdit" value="${animation.frameDuration}" min="10" step="10" style="width: 100%; padding: 8px; border: 1px solid #533483; border-radius: 4px; background: #0f3460; color: white; box-sizing: border-box;">
                                </label>
                                
                                <label style="display: block; margin-bottom: 15px; color: #ccc;">
                                    <div style="font-size: 12px; margin-bottom: 5px;">Tags</div>
                                    <div style="display: flex; flex-wrap: wrap; gap: 6px;">
                                        ${animation.tags && animation.tags.length > 0 
                                            ? animation.tags.map(tag => `<span style="background: #533483; padding: 4px 8px; border-radius: 3px; font-size: 12px;">üè∑Ô∏è${tag}</span>`).join('')
                                            : '<span style="color: #888;">No tags</span>'
                                        }
                                    </div>
                                </label>
                                
                                <div style="color: #bbb; font-size: 12px; margin-top: 15px; padding-top: 15px; border-top: 1px solid #533483;">
                                    <p><strong>Info:</strong></p>
                                    <p>Sheet Size: ${animation.width}x${animation.height}px</p>
                                    <p>Frame Size: ${Math.round(animation.frameWidth)}x${Math.round(animation.frameHeight)}px</p>
                                    <p>Frames Per Row: ${animation.framesPerRow}</p>
                                    <p>Total Frames: ${animation.totalFrames}</p>
                                </div>
                            </div>
                        </div>
                        
                        <div class="modal-buttons">
                            <button onclick="this.closest('.modal').remove()" style="background: #95a5a6;">Close</button>
                            <button id="updateAnimBtn" style="background: #27ae60; cursor: pointer;">Save Changes</button>
                        </div>
                    </div>
                `;
                
                document.body.appendChild(modal);
                updatePreview();
                
                modal.querySelector('#animNameEdit').addEventListener('input', (e) => {
                    e.target.value = e.target.value.replace(/[^a-zA-Z0-9\s_]/g, '');
                });
                
                modal.querySelector('#prevFrameBtn').addEventListener('click', () => {
                    currentFrame = (currentFrame - 1 + animation.totalFrames) % animation.totalFrames;
                    updatePreview();
                    modal.querySelector('#frameIndicator').textContent = `Frame ${currentFrame} / ${animation.totalFrames}`;
                });
                
                modal.querySelector('#nextFrameBtn').addEventListener('click', () => {
                    currentFrame = (currentFrame + 1) % animation.totalFrames;
                    updatePreview();
                    modal.querySelector('#frameIndicator').textContent = `Frame ${currentFrame} / ${animation.totalFrames}`;
                });
                
                modal.querySelector('#playPreviewBtn').addEventListener('click', () => {
                    let frame = 0;
                    const play = () => {
                        updatePreview();
                        currentFrame = frame;
                        modal.querySelector('#frameIndicator').textContent = `Frame ${currentFrame} / ${animation.totalFrames}`;
                        frame = (frame + 1) % animation.totalFrames;
                        setTimeout(play, animation.frameDuration);
                    };
                    play();
                });
                
                modal.querySelector('#updateAnimBtn').addEventListener('click', () => {
                    const newName = modal.querySelector('#animNameEdit').value.trim();
                    const newDuration = parseInt(modal.querySelector('#frameDurationEdit').value);
                    
                    if (!newName) {
                        alert('Animation name cannot be empty');
                        return;
                    }
                    
                    if (!/^[a-zA-Z0-9\s_]+$/.test(newName)) {
                        alert('Animation name can only contain letters, numbers, spaces, and underscores');
                        return;
                    }
                    
                    if (newDuration < 10) {
                        alert('Frame duration must be at least 10ms');
                        return;
                    }
                    
                    animation.name = newName;
                    animation.frameDuration = newDuration;
                    AssetManager.saveAssets();
                    modal.remove();
                    AssetManager.render();
                    showToast('üé¨ Animation updated!');
                });
            }
        };

        const KeyframeManager = {
            keyframes: {},
            currentKeyframe: null,

            init() {
                this.loadKeyframes();
            },

            loadKeyframes() {
                const saved = localStorage.getItem('lupiforge_keyframes');
                if (saved) {
                    this.keyframes = JSON.parse(saved);
                }
            },

            saveKeyframes() {
                localStorage.setItem('lupiforge_keyframes', JSON.stringify(this.keyframes));
            },

            createKeyframeForTag(tag, timeMs) {
                if (!this.keyframes[tag]) {
                    this.keyframes[tag] = [];
                }
                
                const keyframe = {
                    id: Date.now() + Math.random(),
                    tag: tag,
                    time: timeMs,
                    properties: {},
                    createdAt: new Date().toISOString()
                };
                
                this.keyframes[tag].push(keyframe);
                this.keyframes[tag].sort((a, b) => a.time - b.time);
                this.currentKeyframe = keyframe;
                this.saveKeyframes();
                
                console.log(`‚úÖ Created keyframe for tag "${tag}" at ${timeMs}ms`);
                return keyframe;
            },

            setKeyframeProperty(property, value) {
                if (this.currentKeyframe) {
                    this.currentKeyframe.properties[property] = value;
                    this.saveKeyframes();
                    console.log(`üìù Set ${property} = ${value} for keyframe`);
                }
            },

            getKeyframesForTag(tag) {
                return this.keyframes[tag] || [];
            },

            interpolateValue(startVal, endVal, progress, easing) {
                let t = progress;
                
                switch(easing) {
                    case 'easeIn':
                        t = t * t;
                        break;
                    case 'easeOut':
                        t = t * (2 - t);
                        break;
                    case 'easeInOut':
                        t = t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t;
                        break;
                    default:
                        break;
                }
                
                return startVal + (endVal - startVal) * t;
            },

            animateKeyframes(tag, startTimeMs, endTimeMs, easing = 'linear') {
                const keyframesForTag = this.getKeyframesForTag(tag);
                
                if (keyframesForTag.length === 0) {
                    console.warn(`‚ö†Ô∏è No keyframes found for tag "${tag}"`);
                    return;
                }
                
                const filteredFrames = keyframesForTag.filter(kf => 
                    kf.time >= startTimeMs && kf.time <= endTimeMs
                );
                
                if (filteredFrames.length < 2) {
                    console.warn(`‚ö†Ô∏è Need at least 2 keyframes for animation. Found: ${filteredFrames.length}`);
                    return;
                }
                
                const duration = endTimeMs - startTimeMs;
                const startTime = performance.now();
                
                const animate = (currentTime) => {
                    const elapsed = currentTime - startTime;
                    const progress = Math.min(elapsed / duration, 1);
                    
                    for (let i = 0; i < filteredFrames.length - 1; i++) {
                        const current = filteredFrames[i];
                        const next = filteredFrames[i + 1];
                        
                        const segmentStart = (current.time - startTimeMs) / duration;
                        const segmentEnd = (next.time - startTimeMs) / duration;
                        
                        if (progress >= segmentStart && progress <= segmentEnd) {
                            const segmentProgress = (progress - segmentStart) / (segmentEnd - segmentStart);
                            
                            Object.keys(current.properties).forEach(prop => {
                                const startVal = current.properties[prop];
                                const endVal = next.properties[prop];
                                const interpolated = this.interpolateValue(startVal, endVal, segmentProgress, easing);
                                console.log(`üé¨ Animating ${tag}.${prop} = ${interpolated.toFixed(2)}`);
                            });
                        }
                    }
                    
                    if (progress < 1) {
                        requestAnimationFrame(animate);
                    } else {
                        console.log(`‚úÖ Animation complete for tag "${tag}"`);
                    }
                };
                
                requestAnimationFrame(animate);
            },

            getAllTagKeyframes() {
                return this.keyframes;
            },

            clearKeyframesForTag(tag) {
                delete this.keyframes[tag];
                this.saveKeyframes();
                console.log(`üóëÔ∏è Cleared all keyframes for tag "${tag}"`);
            }
        };

        const gameAnimationRuntime = {
            animationInstances: new Map(),
            spriteSheetCache: new Map(),
            loadingCache: new Map(),

            preloadSpriteSheet(animation) {
                if (this.spriteSheetCache.has(animation.id) || this.loadingCache.has(animation.id)) {
                    return Promise.resolve(this.spriteSheetCache.get(animation.id));
                }

                return new Promise((resolve) => {
                    const img = new Image();
                    img.crossOrigin = 'anonymous';
                    img.onload = () => {
                        this.spriteSheetCache.set(animation.id, img);
                        this.loadingCache.delete(animation.id);
                        resolve(img);
                    };
                    img.onerror = () => {
                        console.error(`Failed to load sprite sheet for "${animation.name}"`);
                        this.loadingCache.delete(animation.id);
                        resolve(null);
                    };
                    this.loadingCache.set(animation.id, img);
                    img.src = animation.spriteSheet;
                });
            },

            playAnimationOnTag(animationName, tag, options = {}) {
                const animation = Object.values(AssetManager.assets.animations || []).find(a => a.name === animationName);
                if (!animation) {
                    console.warn(`Animation "${animationName}" not found`);
                    return null;
                }

                const animId = `${tag}-${animationName}-${Date.now()}`;
                
                this.preloadSpriteSheet(animation);
                
                const playFrame = (frameIndex) => {
                    if (PreviewManager.runtime) {
                        const spriteImg = this.spriteSheetCache.get(animation.id);
                        if (spriteImg) {
                            const entities = PreviewManager.runtime.entities.filter(e => 
                                e.tags && e.tags.includes(tag)
                            );
                            
                            entities.forEach(entity => {
                                entity.currentAnimationFrame = {
                                    animation: animation,
                                    frameIndex: frameIndex,
                                    spriteImage: spriteImg
                                };
                            });
                        }
                    }
                };
                
                const animationId = AnimationManager.playAnimation(tag, animationName, {
                    loop: options.loop !== false,
                    duration: options.duration,
                    playbackRate: options.playbackRate || 1,
                    onFrame: playFrame
                });
                
                this.animationInstances.set(animId, animationId);
                return animId;
            },

            stopAnimationOnTag(animationName, tag) {
                const animId = `${tag}-${animationName}`;
                const animationId = this.animationInstances.get(animId);
                if (animationId) {
                    AnimationManager.stopAnimation(animationId);
                    this.animationInstances.delete(animId);
                }
            },

            playAnimationWithKeyframes(animationName, tag, duration, keyframeSetup) {
                KeyframeManager.currentTag = tag;
                KeyframeManager.currentAnimation = animationName;
                
                keyframeSetup();
                
                this.playAnimationOnTag(animationName, tag, { duration });
                
                setTimeout(() => {
                    KeyframeManager.animateKeyframes(tag, 0, duration, 'linear');
                }, 0);
            }
        };

        window.playAnimationOnTag = (name, tag, opts) => gameAnimationRuntime.playAnimationOnTag(name, tag, opts);
        window.stopAnimationOnTag = (name, tag) => gameAnimationRuntime.stopAnimationOnTag(name, tag);
        window.playAnimationWithKeyframes = (name, tag, dur, setup) => gameAnimationRuntime.playAnimationWithKeyframes(name, tag, dur, setup);
        window.createKeyframeForTag = (tag, time) => KeyframeManager.createKeyframeForTag(tag, time);
        window.setKeyframeProperty = (prop, val) => KeyframeManager.setKeyframeProperty(prop, val);
        window.animateKeyframes = (tag, start, end, easing) => KeyframeManager.animateKeyframes(tag, start, end, easing);

        window.stateStore = stateStore;
        window.saveGame = (slot, meta) => stateStore?.saveGame(slot, meta);
        window.loadGame = (slot) => stateStore?.loadGame(slot);
        window.getState = (key, def) => stateStore?.getState(key, def);
        window.setState = (key, value) => stateStore?.setState(key, value);

        let debugOverlaySystem = null;
        try {
            const canvas = document.getElementById('gameCanvas') || document.querySelector('canvas');
            if (canvas) {
                debugOverlaySystem = new DebugOverlaySystem(
                    { getCameraPosition: () => ({x: 0, y: 0}), getCameraZoom: () => 1 },
                    { getAllEntities: () => [], getEntityCount: () => 0, getEntitiesNear: () => [] },
                    canvas
                );
                console.log('‚úÖ DebugOverlaySystem initialized');
            } else {
                debugOverlaySystem = new DebugOverlaySystem(null, null, null);
                console.log('‚ö†Ô∏è DebugOverlaySystem initialized without canvas');
            }
        } catch (error) {
            console.error('‚ùå DebugOverlaySystem initialization failed:', error);
        }

        window.debugOverlaySystem = debugOverlaySystem;
        window.toggleDebug = () => debugOverlaySystem?.toggle();
        window.toggleDebugHitboxes = () => debugOverlaySystem?.toggleHitboxes();
        window.toggleDebugPerformance = () => debugOverlaySystem?.togglePerformance();
        window.toggleDebugEntityInfo = () => debugOverlaySystem?.toggleEntityInfo();
        window.debugLog = (message, category) => debugOverlaySystem?.log(message, category);

        KeyframeManager.init();
        AssetTagSystem.init();

        // === LEVEL EDITOR REMOVED (Not part of V1) ===
    </script>
    
    <!-- === LEVEL EDITOR SCRIPT REMOVED (Not part of V1) === -->
    
    <!-- Fixed JavaScript Classes - NOTE: These are already loaded earlier via Django static tags -->
    <!-- <script src="/static/js/ai_suggestion_system.js"></script> -->
    <!-- <script src="/static/js/mobile_exporter.js"></script> -->
    <!-- <script src="/static/js/asset_tagging_system.js"></script> -->
    <!-- <script src="/static/js/state_store.js"></script> -->
</body>
</html>